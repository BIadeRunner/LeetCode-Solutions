{"question_id": "3578", "problem_slug": "construct-2d-grid-matching-graph-layout", "problem_title": "Construct 2D Grid Matching Graph Layout", "content": "You are given a 2D integer array edges representing an undirected graph having n nodes, where edges[i] = [ui, vi] denotes an edge between nodes ui and vi.\nConstruct a 2D grid that satisfies these conditions:\n\nThe grid contains all nodes from 0 to n - 1 in its cells, with each node appearing exactly once.\nTwo nodes should be in adjacent grid cells (horizontally or vertically) if and only if there is an edge between them in edges.\n\nIt is guaranteed that edges can form a 2D grid that satisfies the conditions.\nReturn a 2D integer array satisfying the conditions above. If there are multiple solutions, return any of them.\n \nExample 1:\n\nInput: n = 4, edges = [[0,1],[0,2],[1,3],[2,3]]\nOutput: [[3,1],[2,0]]\nExplanation:\n\n\nExample 2:\n\nInput: n = 5, edges = [[0,1],[1,3],[2,3],[2,4]]\nOutput: [[4,2,3,1,0]]\nExplanation:\n\n\nExample 3:\n\nInput: n = 9, edges = [[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]]\nOutput: [[8,6,3],[7,4,2],[1,0,5]]\nExplanation:\n\n\n \nConstraints:\n\n2 <= n <= 5 * 104\n1 <= edges.length <= 105\nedges[i] = [ui, vi]\n0 <= ui < vi < n\nAll the edges are distinct.\nThe input is generated such that edges can form a 2D grid that satisfies the conditions.\n\n", "hints": ["Observe the indegrees of the nodes.", "The case where there are two nodes with an indegree of 1, and all the others have an indegree of 2 can be handled separately.", "The nodes with the smallest degrees are the corners.", "You can simulate the grid creation process using BFS or a similar approach after making some observations on the indegrees."], "exampleTestcases": "4\n[[0,1],[0,2],[1,3],[2,3]]\n5\n[[0,1],[1,3],[2,3],[2,4]]\n9\n[[0,1],[0,4],[0,5],[1,7],[2,3],[2,4],[2,5],[3,6],[4,6],[4,7],[6,8],[7,8]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<vector<int>> constructGridLayout(int n, vector<vector<int>>& edges) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[][] constructGridLayout(int n, int[][] edges) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def constructGridLayout(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def constructGridLayout(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** constructGridLayout(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[][] ConstructGridLayout(int n, int[][] edges) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[][]}\n */\nvar constructGridLayout = function(n, edges) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function constructGridLayout(n: number, edges: number[][]): number[][] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[][]\n     */\n    function constructGridLayout($n, $edges) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func constructGridLayout(_ n: Int, _ edges: [[Int]]) -> [[Int]] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun constructGridLayout(n: Int, edges: Array<IntArray>): Array<IntArray> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<List<int>> constructGridLayout(int n, List<List<int>> edges) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func constructGridLayout(n int, edges [][]int) [][]int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[][]}\ndef construct_grid_layout(n, edges)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def constructGridLayout(n: Int, edges: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn construct_grid_layout(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (construct-grid-layout n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec construct_grid_layout(N :: integer(), Edges :: [[integer()]]) -> [[integer()]].\nconstruct_grid_layout(N, Edges) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec construct_grid_layout(n :: integer, edges :: [[integer]]) :: [[integer]]\n  def construct_grid_layout(n, edges) do\n    \n  end\nend"}}}