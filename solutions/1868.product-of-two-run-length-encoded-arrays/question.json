{"questionId": "2019", "acRate": 58.73369239976062, "difficulty": "Medium", "freqBar": 62.07864341679884, "frontendQuestionId": "1868", "paidOnly": true, "status": "ac", "title": "Product of Two Run-Length Encoded Arrays", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Two Pointers", "id": "VG9waWNUYWdOb2RlOjk=", "slug": "two-pointers"}], "titleSlug": "product-of-two-run-length-encoded-arrays", "content": "<p><strong>Run-length encoding</strong> is a compression algorithm that allows for an integer array <code>nums</code> with many segments of <strong>consecutive repeated</strong> numbers to be represented by a (generally smaller) 2D array <code>encoded</code>. Each <code>encoded[i] = [val<sub>i</sub>, freq<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> segment of repeated numbers in <code>nums</code> where <code>val<sub>i</sub></code> is the value that is repeated <code>freq<sub>i</sub></code> times.</p>\n\n<ul>\n\t<li>For example, <code>nums = [1,1,1,2,2,2,2,2]</code> is represented by the <strong>run-length encoded</strong> array <code>encoded = [[1,3],[2,5]]</code>. Another way to read this is &quot;three <code>1</code>&#39;s followed by five <code>2</code>&#39;s&quot;.</li>\n</ul>\n\n<p>The <strong>product</strong> of two run-length encoded arrays <code>encoded1</code> and <code>encoded2</code> can be calculated using the following steps:</p>\n\n<ol>\n\t<li><strong>Expand</strong> both <code>encoded1</code> and <code>encoded2</code> into the full arrays <code>nums1</code> and <code>nums2</code> respectively.</li>\n\t<li>Create a new array <code>prodNums</code> of length <code>nums1.length</code> and set <code>prodNums[i] = nums1[i] * nums2[i]</code>.</li>\n\t<li><strong>Compress</strong> <code>prodNums</code> into a run-length encoded array and return it.</li>\n</ol>\n\n<p>You are given two <strong>run-length encoded</strong> arrays <code>encoded1</code> and <code>encoded2</code> representing full arrays <code>nums1</code> and <code>nums2</code> respectively. Both <code>nums1</code> and <code>nums2</code> have the <strong>same length</strong>. Each <code>encoded1[i] = [val<sub>i</sub>, freq<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> segment of <code>nums1</code>, and each <code>encoded2[j] = [val<sub>j</sub>, freq<sub>j</sub>]</code> describes the <code>j<sup>th</sup></code> segment of <code>nums2</code>.</p>\n\n<p>Return <i>the <strong>product</strong> of </i><code>encoded1</code><em> and </em><code>encoded2</code>.</p>\n\n<p><strong>Note:</strong> Compression should be done such that the run-length encoded array has the <strong>minimum</strong> possible length.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]\n<strong>Output:</strong> [[6,6]]\n<strong>Explanation:</strong> encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3].\nprodNums = [6,6,6,6,6,6], which is compressed into the run-length encoded array [[6,6]].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]\n<strong>Output:</strong> [[2,3],[6,1],[9,2]]\n<strong>Explanation:</strong> encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3].\nprodNums = [2,2,2,6,9,9], which is compressed into the run-length encoded array [[2,3],[6,1],[9,2]].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= encoded1.length, encoded2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>encoded1[i].length == 2</code></li>\n\t<li><code>encoded2[j].length == 2</code></li>\n\t<li><code>1 &lt;= val<sub>i</sub>, freq<sub>i</sub> &lt;= 10<sup>4</sup></code> for each <code>encoded1[i]</code>.</li>\n\t<li><code>1 &lt;= val<sub>j</sub>, freq<sub>j</sub> &lt;= 10<sup>4</sup></code> for each <code>encoded2[j]</code>.</li>\n\t<li>The full arrays that <code>encoded1</code> and <code>encoded2</code> represent are the same length.</li>\n</ul>\n", "hints": ["Keep track of the indices on both RLE arrays and join the parts together.", "What is the maximum number of segments if we took the minimum number of elements left on both the current segments every time?"], "exampleTestcases": "[[1,3],[2,3]]\n[[6,3],[3,3]]\n[[1,3],[2,1],[3,2]]\n[[2,3],[3,3]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<vector<int>> findRLEArray(vector<vector<int>>& encoded1, vector<vector<int>>& encoded2) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public List<List<Integer>> findRLEArray(int[][] encoded1, int[][] encoded2) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def findRLEArray(self, encoded1, encoded2):\n        \"\"\"\n        :type encoded1: List[List[int]]\n        :type encoded2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def findRLEArray(self, encoded1: List[List[int]], encoded2: List[List[int]]) -> List[List[int]]:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findRLEArray(int** encoded1, int encoded1Size, int* encoded1ColSize, int** encoded2, int encoded2Size, int* encoded2ColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public IList<IList<int>> FindRLEArray(int[][] encoded1, int[][] encoded2) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number[][]} encoded1\n * @param {number[][]} encoded2\n * @return {number[][]}\n */\nvar findRLEArray = function(encoded1, encoded2) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function findRLEArray(encoded1: number[][], encoded2: number[][]): number[][] {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $encoded1\n     * @param Integer[][] $encoded2\n     * @return Integer[][]\n     */\n    function findRLEArray($encoded1, $encoded2) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func findRLEArray(_ encoded1: [[Int]], _ encoded2: [[Int]]) -> [[Int]] {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun findRLEArray(encoded1: Array<IntArray>, encoded2: Array<IntArray>): List<List<Int>> {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  List<List<int>> findRLEArray(List<List<int>> encoded1, List<List<int>> encoded2) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func findRLEArray(encoded1 [][]int, encoded2 [][]int) [][]int {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer[][]} encoded1\n# @param {Integer[][]} encoded2\n# @return {Integer[][]}\ndef find_rle_array(encoded1, encoded2)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def findRLEArray(encoded1: Array[Array[Int]], encoded2: Array[Array[Int]]): List[List[Int]] = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn find_rle_array(encoded1: Vec<Vec<i32>>, encoded2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (find-rle-array encoded1 encoded2)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec find_rle_array(Encoded1 :: [[integer()]], Encoded2 :: [[integer()]]) -> [[integer()]].\nfind_rle_array(Encoded1, Encoded2) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec find_rle_array(encoded1 :: [[integer]], encoded2 :: [[integer]]) :: [[integer]]\n  def find_rle_array(encoded1, encoded2) do\n    \n  end\nend"}], "similarQuestionList": []}