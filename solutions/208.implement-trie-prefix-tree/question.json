{"question_id": "208", "problem_slug": "implement-trie-prefix-tree", "problem_title": "Implement Trie (Prefix Tree)", "content": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\n \nExample 1:\n\nInput\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True\n\n \nConstraints:\n\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.\n\n", "hints": [], "exampleTestcases": "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]\n[[],[\"apple\"],[\"apple\"],[\"app\"],[\"app\"],[\"app\"],[\"app\"]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Trie {\npublic:\n    Trie() {\n        \n    }\n    \n    void insert(string word) {\n        \n    }\n    \n    bool search(string word) {\n        \n    }\n    \n    bool startsWith(string prefix) {\n        \n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */"}, "Java": {"langSlug": "java", "code": "class Trie {\n\n    public Trie() {\n        \n    }\n    \n    public void insert(String word) {\n        \n    }\n    \n    public boolean search(String word) {\n        \n    }\n    \n    public boolean startsWith(String prefix) {\n        \n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */"}, "Python": {"langSlug": "python", "code": "class Trie(object):\n\n    def __init__(self):\n        \n\n    def insert(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        \n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n\n    def startsWith(self, prefix):\n        \"\"\"\n        :type prefix: str\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)"}, "Python3": {"langSlug": "python3", "code": "class Trie:\n\n    def __init__(self):\n        \n\n    def insert(self, word: str) -> None:\n        \n\n    def search(self, word: str) -> bool:\n        \n\n    def startsWith(self, prefix: str) -> bool:\n        \n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} Trie;\n\n\nTrie* trieCreate() {\n    \n}\n\nvoid trieInsert(Trie* obj, char* word) {\n    \n}\n\nbool trieSearch(Trie* obj, char* word) {\n    \n}\n\nbool trieStartsWith(Trie* obj, char* prefix) {\n    \n}\n\nvoid trieFree(Trie* obj) {\n    \n}\n\n/**\n * Your Trie struct will be instantiated and called as such:\n * Trie* obj = trieCreate();\n * trieInsert(obj, word);\n \n * bool param_2 = trieSearch(obj, word);\n \n * bool param_3 = trieStartsWith(obj, prefix);\n \n * trieFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class Trie {\n\n    public Trie() {\n        \n    }\n    \n    public void Insert(string word) {\n        \n    }\n    \n    public bool Search(string word) {\n        \n    }\n    \n    public bool StartsWith(string prefix) {\n        \n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.Insert(word);\n * bool param_2 = obj.Search(word);\n * bool param_3 = obj.StartsWith(prefix);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "\nvar Trie = function() {\n    \n};\n\n/** \n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function(word) {\n    \n};\n\n/** \n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function(word) {\n    \n};\n\n/** \n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function(prefix) {\n    \n};\n\n/** \n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class Trie {\n    constructor() {\n        \n    }\n\n    insert(word: string): void {\n        \n    }\n\n    search(word: string): boolean {\n        \n    }\n\n    startsWith(prefix: string): boolean {\n        \n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */"}, "PHP": {"langSlug": "php", "code": "class Trie {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param String $word\n     * @return NULL\n     */\n    function insert($word) {\n        \n    }\n  \n    /**\n     * @param String $word\n     * @return Boolean\n     */\n    function search($word) {\n        \n    }\n  \n    /**\n     * @param String $prefix\n     * @return Boolean\n     */\n    function startsWith($prefix) {\n        \n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * $obj = Trie();\n * $obj->insert($word);\n * $ret_2 = $obj->search($word);\n * $ret_3 = $obj->startsWith($prefix);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass Trie {\n\n    init() {\n        \n    }\n    \n    func insert(_ word: String) {\n        \n    }\n    \n    func search(_ word: String) -> Bool {\n        \n    }\n    \n    func startsWith(_ prefix: String) -> Bool {\n        \n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * let obj = Trie()\n * obj.insert(word)\n * let ret_2: Bool = obj.search(word)\n * let ret_3: Bool = obj.startsWith(prefix)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class Trie() {\n\n    fun insert(word: String) {\n        \n    }\n\n    fun search(word: String): Boolean {\n        \n    }\n\n    fun startsWith(prefix: String): Boolean {\n        \n    }\n\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */"}, "Dart": {"langSlug": "dart", "code": "class Trie {\n\n  Trie() {\n    \n  }\n  \n  void insert(String word) {\n    \n  }\n  \n  bool search(String word) {\n    \n  }\n  \n  bool startsWith(String prefix) {\n    \n  }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = Trie();\n * obj.insert(word);\n * bool param2 = obj.search(word);\n * bool param3 = obj.startsWith(prefix);\n */"}, "Go": {"langSlug": "golang", "code": "type Trie struct {\n    \n}\n\n\nfunc Constructor() Trie {\n    \n}\n\n\nfunc (this *Trie) Insert(word string)  {\n    \n}\n\n\nfunc (this *Trie) Search(word string) bool {\n    \n}\n\n\nfunc (this *Trie) StartsWith(prefix string) bool {\n    \n}\n\n\n/**\n * Your Trie object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Insert(word);\n * param_2 := obj.Search(word);\n * param_3 := obj.StartsWith(prefix);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class Trie\n    def initialize()\n        \n    end\n\n\n=begin\n    :type word: String\n    :rtype: Void\n=end\n    def insert(word)\n        \n    end\n\n\n=begin\n    :type word: String\n    :rtype: Boolean\n=end\n    def search(word)\n        \n    end\n\n\n=begin\n    :type prefix: String\n    :rtype: Boolean\n=end\n    def starts_with(prefix)\n        \n    end\n\n\nend\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie.new()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.starts_with(prefix)"}, "Scala": {"langSlug": "scala", "code": "class Trie() {\n\n    def insert(word: String): Unit = {\n        \n    }\n\n    def search(word: String): Boolean = {\n        \n    }\n\n    def startsWith(prefix: String): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * val obj = new Trie()\n * obj.insert(word)\n * val param_2 = obj.search(word)\n * val param_3 = obj.startsWith(prefix)\n */"}, "Rust": {"langSlug": "rust", "code": "struct Trie {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Trie {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn insert(&self, word: String) {\n        \n    }\n    \n    fn search(&self, word: String) -> bool {\n        \n    }\n    \n    fn starts_with(&self, prefix: String) -> bool {\n        \n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * let obj = Trie::new();\n * obj.insert(word);\n * let ret_2: bool = obj.search(word);\n * let ret_3: bool = obj.starts_with(prefix);\n */"}, "Racket": {"langSlug": "racket", "code": "(define trie%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; insert : string? -> void?\n    (define/public (insert word)\n      )\n    ; search : string? -> boolean?\n    (define/public (search word)\n      )\n    ; starts-with : string? -> boolean?\n    (define/public (starts-with prefix)\n      )))\n\n;; Your trie% object will be instantiated and called as such:\n;; (define obj (new trie%))\n;; (send obj insert word)\n;; (define param_2 (send obj search word))\n;; (define param_3 (send obj starts-with prefix))"}, "Erlang": {"langSlug": "erlang", "code": "-spec trie_init_() -> any().\ntrie_init_() ->\n  .\n\n-spec trie_insert(Word :: unicode:unicode_binary()) -> any().\ntrie_insert(Word) ->\n  .\n\n-spec trie_search(Word :: unicode:unicode_binary()) -> boolean().\ntrie_search(Word) ->\n  .\n\n-spec trie_starts_with(Prefix :: unicode:unicode_binary()) -> boolean().\ntrie_starts_with(Prefix) ->\n  .\n\n\n%% Your functions will be called as such:\n%% trie_init_(),\n%% trie_insert(Word),\n%% Param_2 = trie_search(Word),\n%% Param_3 = trie_starts_with(Prefix),\n\n%% trie_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Trie do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec insert(word :: String.t) :: any\n  def insert(word) do\n    \n  end\n\n  @spec search(word :: String.t) :: boolean\n  def search(word) do\n    \n  end\n\n  @spec starts_with(prefix :: String.t) :: boolean\n  def starts_with(prefix) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Trie.init_()\n# Trie.insert(word)\n# param_2 = Trie.search(word)\n# param_3 = Trie.starts_with(prefix)\n\n# Trie.init_ will be called before every test case, in which you can do some necessary initializations."}}}