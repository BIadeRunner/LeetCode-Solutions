{"question_id": "642", "problem_slug": "design-search-autocomplete-system", "problem_title": "Design Search Autocomplete System", "content": "Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#').\nYou are given a string array sentences and an integer array times both of length n where sentences[i] is a previously typed sentence and times[i] is the corresponding number of times the sentence was typed. For each input character except '#', return the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed.\nHere are the specific rules:\n\nThe hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.\nThe returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first).\nIf less than 3 hot sentences exist, return as many as you can.\nWhen the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.\n\nImplement the AutocompleteSystem class:\n\nAutocompleteSystem(String[] sentences, int[] times) Initializes the object with the sentences and times arrays.\nList<String> input(char c) This indicates that the user typed the character c.\n\t\nReturns an empty array [] if c == '#' and stores the inputted sentence in the system.\nReturns the top 3 historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than 3 matches, return them all.\n\n\n\n \nExample 1:\n\nInput\n[\"AutocompleteSystem\", \"input\", \"input\", \"input\", \"input\"]\n[[[\"i love you\", \"island\", \"iroman\", \"i love leetcode\"], [5, 3, 2, 2]], [\"i\"], [\" \"], [\"a\"], [\"#\"]]\nOutput\n[null, [\"i love you\", \"island\", \"i love leetcode\"], [\"i love you\", \"i love leetcode\"], [], []]\n\nExplanation\nAutocompleteSystem obj = new AutocompleteSystem([\"i love you\", \"island\", \"iroman\", \"i love leetcode\"], [5, 3, 2, 2]);\nobj.input(\"i\"); // return [\"i love you\", \"island\", \"i love leetcode\"]. There are four sentences that have prefix \"i\". Among them, \"ironman\" and \"i love leetcode\" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, \"i love leetcode\" should be in front of \"ironman\". Also we only need to output top 3 hot sentences, so \"ironman\" will be ignored.\nobj.input(\" \"); // return [\"i love you\", \"i love leetcode\"]. There are only two sentences that have prefix \"i \".\nobj.input(\"a\"); // return []. There are no sentences that have prefix \"i a\".\nobj.input(\"#\"); // return []. The user finished the input, the sentence \"i a\" should be saved as a historical sentence in system. And the following input will be counted as a new search.\n\n \nConstraints:\n\nn == sentences.length\nn == times.length\n1 <= n <= 100\n1 <= sentences[i].length <= 100\n1 <= times[i] <= 50\nc is a lowercase English letter, a hash '#', or space ' '.\nEach tested sentence will be a sequence of characters c that end with the character '#'.\nEach tested sentence will have a length in the range [1, 200].\nThe words in each input sentence are separated by single spaces.\nAt most 5000 calls will be made to input.\n\n", "hints": [], "exampleTestcases": "[\"AutocompleteSystem\",\"input\",\"input\",\"input\",\"input\"]\n[[[\"i love you\",\"island\",\"iroman\",\"i love leetcode\"],[5,3,2,2]],[\"i\"],[\" \"],[\"a\"],[\"#\"]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class AutocompleteSystem {\npublic:\n    AutocompleteSystem(vector<string>& sentences, vector<int>& times) {\n        \n    }\n    \n    vector<string> input(char c) {\n        \n    }\n};\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * AutocompleteSystem* obj = new AutocompleteSystem(sentences, times);\n * vector<string> param_1 = obj->input(c);\n */"}, "Java": {"langSlug": "java", "code": "class AutocompleteSystem {\n\n    public AutocompleteSystem(String[] sentences, int[] times) {\n        \n    }\n    \n    public List<String> input(char c) {\n        \n    }\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);\n * List<String> param_1 = obj.input(c);\n */"}, "Python": {"langSlug": "python", "code": "class AutocompleteSystem(object):\n\n    def __init__(self, sentences, times):\n        \"\"\"\n        :type sentences: List[str]\n        :type times: List[int]\n        \"\"\"\n        \n\n    def input(self, c):\n        \"\"\"\n        :type c: str\n        :rtype: List[str]\n        \"\"\"\n        \n\n\n# Your AutocompleteSystem object will be instantiated and called as such:\n# obj = AutocompleteSystem(sentences, times)\n# param_1 = obj.input(c)"}, "Python3": {"langSlug": "python3", "code": "class AutocompleteSystem:\n\n    def __init__(self, sentences: List[str], times: List[int]):\n        \n\n    def input(self, c: str) -> List[str]:\n        \n\n\n# Your AutocompleteSystem object will be instantiated and called as such:\n# obj = AutocompleteSystem(sentences, times)\n# param_1 = obj.input(c)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} AutocompleteSystem;\n\n\nAutocompleteSystem* autocompleteSystemCreate(char ** sentences, int sentencesSize, int* times, int timesSize) {\n    \n}\n\nchar ** autocompleteSystemInput(AutocompleteSystem* obj, char c, int* retSize) {\n  \n}\n\nvoid autocompleteSystemFree(AutocompleteSystem* obj) {\n    \n}\n\n/**\n * Your AutocompleteSystem struct will be instantiated and called as such:\n * AutocompleteSystem* obj = autocompleteSystemCreate(sentences, sentencesSize, times, timesSize);\n * char ** param_1 = autocompleteSystemInput(obj, c, retSize);\n \n * autocompleteSystemFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class AutocompleteSystem {\n\n    public AutocompleteSystem(string[] sentences, int[] times) {\n        \n    }\n    \n    public IList<string> Input(char c) {\n        \n    }\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);\n * IList<string> param_1 = obj.Input(c);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string[]} sentences\n * @param {number[]} times\n */\nvar AutocompleteSystem = function(sentences, times) {\n    \n};\n\n/** \n * @param {character} c\n * @return {string[]}\n */\nAutocompleteSystem.prototype.input = function(c) {\n    \n};\n\n/** \n * Your AutocompleteSystem object will be instantiated and called as such:\n * var obj = new AutocompleteSystem(sentences, times)\n * var param_1 = obj.input(c)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class AutocompleteSystem {\n    constructor(sentences: string[], times: number[]) {\n\n    }\n\n    input(c: string): string[] {\n\n    }\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * var obj = new AutocompleteSystem(sentences, times)\n * var param_1 = obj.input(c)\n */"}, "PHP": {"langSlug": "php", "code": "class AutocompleteSystem {\n    /**\n     * @param String[] $sentences\n     * @param Integer[] $times\n     */\n    function __construct($sentences, $times) {\n        \n    }\n  \n    /**\n     * @param String $c\n     * @return String[]\n     */\n    function input($c) {\n        \n    }\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * $obj = AutocompleteSystem($sentences, $times);\n * $ret_1 = $obj->input($c);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass AutocompleteSystem {\n\n    init(_ sentences: [String], _ times: [Int]) {\n        \n    }\n    \n    func input(_ c: Character) -> [String] {\n        \n    }\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * let obj = AutocompleteSystem(sentences, times)\n * let ret_1: [String] = obj.input(c)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class AutocompleteSystem(sentences: Array<String>, times: IntArray) {\n\n    fun input(c: Char): List<String> {\n        \n    }\n\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * var obj = AutocompleteSystem(sentences, times)\n * var param_1 = obj.input(c)\n */"}, "Dart": {"langSlug": "dart", "code": "class AutocompleteSystem {\n\n  AutocompleteSystem(List<String> sentences, List<int> times) {\n\n  }\n  \n  List<String> input(String c) {\n\n  }\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * AutocompleteSystem obj = AutocompleteSystem(sentences, times);\n * List<String> param1 = obj.input(c);\n */"}, "Go": {"langSlug": "golang", "code": "type AutocompleteSystem struct {\n    \n}\n\n\nfunc Constructor(sentences []string, times []int) AutocompleteSystem {\n    \n}\n\n\nfunc (this *AutocompleteSystem) Input(c byte) []string {\n    \n}\n\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * obj := Constructor(sentences, times);\n * param_1 := obj.Input(c);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class AutocompleteSystem\n\n=begin\n    :type sentences: String[]\n    :type times: Integer[]\n=end\n    def initialize(sentences, times)\n        \n    end\n\n\n=begin\n    :type c: Character\n    :rtype: String[]\n=end\n    def input(c)\n        \n    end\n\n\nend\n\n# Your AutocompleteSystem object will be instantiated and called as such:\n# obj = AutocompleteSystem.new(sentences, times)\n# param_1 = obj.input(c)"}, "Scala": {"langSlug": "scala", "code": "class AutocompleteSystem(_sentences: Array[String], _times: Array[Int]) {\n\n    def input(c: Char): List[String] = {\n        \n    }\n\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * var obj = new AutocompleteSystem(sentences, times)\n * var param_1 = obj.input(c)\n */"}, "Rust": {"langSlug": "rust", "code": "struct AutocompleteSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl AutocompleteSystem {\n\n    fn new(sentences: Vec<String>, times: Vec<i32>) -> Self {\n        \n    }\n    \n    fn input(&self, c: char) -> Vec<String> {\n        \n    }\n}\n\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * let obj = AutocompleteSystem::new(sentences, times);\n * let ret_1: Vec<String> = obj.input(c);\n */"}, "Racket": {"langSlug": "racket", "code": "(define autocomplete-system%\n  (class object%\n    (super-new)\n\n    ; sentences : (listof string?)\n\n    ; times : (listof exact-integer?)\n    (init-field\n      sentences\n      times)\n    \n    ; input : char? -> (listof string?)\n    (define/public (input c)\n\n      )))\n\n;; Your autocomplete-system% object will be instantiated and called as such:\n;; (define obj (new autocomplete-system% [sentences sentences] [times times]))\n;; (define param_1 (send obj input c))"}, "Erlang": {"langSlug": "erlang", "code": "-spec autocomplete_system_init_(Sentences :: [unicode:unicode_binary()], Times :: [integer()]) -> any().\nautocomplete_system_init_(Sentences, Times) ->\n  .\n\n-spec autocomplete_system_input(C :: char()) -> [unicode:unicode_binary()].\nautocomplete_system_input(C) ->\n  .\n\n\n%% Your functions will be called as such:\n%% autocomplete_system_init_(Sentences, Times),\n%% Param_1 = autocomplete_system_input(C),\n\n%% autocomplete_system_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule AutocompleteSystem do\n  @spec init_(sentences :: [String.t], times :: [integer]) :: any\n  def init_(sentences, times) do\n    \n  end\n\n  @spec input(c :: char) :: [String.t]\n  def input(c) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# AutocompleteSystem.init_(sentences, times)\n# param_1 = AutocompleteSystem.input(c)\n\n# AutocompleteSystem.init_ will be called before every test case, in which you can do some necessary initializations."}}}