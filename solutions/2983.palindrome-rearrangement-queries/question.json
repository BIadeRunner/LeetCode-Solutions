{"questionId": "3203", "acRate": 25.791352637842124, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "2983", "paidOnly": false, "status": "ac", "title": "Palindrome Rearrangement Queries", "topicTags": [{"name": "Hash Table", "id": "VG9waWNUYWdOb2RlOjY=", "slug": "hash-table"}, {"name": "String", "id": "VG9waWNUYWdOb2RlOjEw", "slug": "string"}, {"name": "Prefix Sum", "id": "VG9waWNUYWdOb2RlOjYxMDY4", "slug": "prefix-sum"}], "titleSlug": "palindrome-rearrangement-queries", "content": "<p>You are given a <strong>0-indexed</strong> string <code>s</code> having an <strong>even</strong> length <code>n</code>.</p>\n\n<p>You are also given a <strong>0-indexed</strong> 2D integer array, <code>queries</code>, where <code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, d<sub>i</sub>]</code>.</p>\n\n<p>For each query <code>i</code>, you are allowed to perform the following operations:</p>\n\n<ul>\n\t<li>Rearrange the characters within the <strong>substring</strong> <code>s[a<sub>i</sub>:b<sub>i</sub>]</code>, where <code>0 &lt;= a<sub>i</sub> &lt;= b<sub>i</sub> &lt; n / 2</code>.</li>\n\t<li>Rearrange the characters within the <strong>substring</strong> <code>s[c<sub>i</sub>:d<sub>i</sub>]</code>, where <code>n / 2 &lt;= c<sub>i</sub> &lt;= d<sub>i</sub> &lt; n</code>.</li>\n</ul>\n\n<p>For each query, your task is to determine whether it is possible to make <code>s</code> a <strong>palindrome</strong> by performing the operations.</p>\n\n<p>Each query is answered <strong>independently</strong> of the others.</p>\n\n<p>Return <em>a <strong>0-indexed</strong> array </em><code>answer</code><em>, where </em><code>answer[i] == true</code><em> if it is possible to make </em><code>s</code><em> a palindrome by performing operations specified by the </em><code>i<sup>th</sup></code><em> query, and </em><code>false</code><em> otherwise.</em></p>\n\n<ul>\n\t<li>A <strong>substring</strong> is a contiguous sequence of characters within a string.</li>\n\t<li><code>s[x:y]</code> represents the substring consisting of characters from the index <code>x</code> to index <code>y</code> in <code>s</code>, <strong>both inclusive</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabc&quot;, queries = [[1,1,3,5],[0,2,5,5]]\n<strong>Output:</strong> [true,true]\n<strong>Explanation:</strong> In this example, there are two queries:\nIn the first query:\n- a<sub>0</sub> = 1, b<sub>0</sub> = 1, c<sub>0</sub> = 3, d<sub>0</sub> = 5.\n- So, you are allowed to rearrange s[1:1] =&gt; a<u>b</u>cabc and s[3:5] =&gt; abc<u>abc</u>.\n- To make s a palindrome, s[3:5] can be rearranged to become =&gt; abc<u>cba</u>.\n- Now, s is a palindrome. So, answer[0] = true.\nIn the second query:\n- a<sub>1</sub> = 0, b<sub>1</sub> = 2, c<sub>1</sub> = 5, d<sub>1</sub> = 5.\n- So, you are allowed to rearrange s[0:2] =&gt; <u>abc</u>abc and s[5:5] =&gt; abcab<u>c</u>.\n- To make s a palindrome, s[0:2] can be rearranged to become =&gt; <u>cba</u>abc.\n- Now, s is a palindrome. So, answer[1] = true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abbcdecbba&quot;, queries = [[0,2,7,9]]\n<strong>Output:</strong> [false]\n<strong>Explanation:</strong> In this example, there is only one query.\na<sub>0</sub> = 0, b<sub>0</sub> = 2, c<sub>0</sub> = 7, d<sub>0</sub> = 9.\nSo, you are allowed to rearrange s[0:2] =&gt; <u>abb</u>cdecbba and s[7:9] =&gt; abbcdec<u>bba</u>.\nIt is not possible to make s a palindrome by rearranging these substrings because s[3:6] is not a palindrome.\nSo, answer[0] = false.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;acbcab&quot;, queries = [[1,2,4,5]]\n<strong>Output:</strong> [true]\n<strong>Explanation: </strong>In this example, there is only one query.\na<sub>0</sub> = 1, b<sub>0</sub> = 2, c<sub>0</sub> = 4, d<sub>0</sub> = 5.\nSo, you are allowed to rearrange s[1:2] =&gt; a<u>cb</u>cab and s[4:5] =&gt; acbc<u>ab</u>.\nTo make s a palindrome s[1:2] can be rearranged to become a<u>bc</u>cab.\nThen, s[4:5] can be rearranged to become abcc<u>ba</u>.\nNow, s is a palindrome. So, answer[0] = true.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 4</code></li>\n\t<li><code>a<sub>i</sub> == queries[i][0], b<sub>i</sub> == queries[i][1]</code></li>\n\t<li><code>c<sub>i</sub> == queries[i][2], d<sub>i</sub> == queries[i][3]</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub> &lt;= b<sub>i</sub> &lt; n / 2</code></li>\n\t<li><code>n / 2 &lt;= c<sub>i</sub> &lt;= d<sub>i</sub> &lt; n </code></li>\n\t<li><code>n</code> is even.</li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n</ul>\n", "hints": ["Consider two indices, <code>x</code> on the left side and its symmetrical index <code>y</code> on the right side.", "Store the frequencies of all of the letters in both intervals <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>[c<sub>i</sub>, d<sub>i</sub>]</code> in a query.", "If <code>x</code> is not in <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>y</code> is not in <code>[c<sub>i</sub>, d<sub>i</sub>]</code>, they must be the same.", "If <code>x</code> is in <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>y</code> is not in <code>[c<sub>i</sub>, d<sub>i</sub>]</code>, remove one occurrence of the character at index <code>y</code> from the frequency array on the left side.", "Similarly, if <code>x</code> is not in <code>[a<sub>i</sub>, b<sub>i</sub>]</code> and <code>y</code> is in <code>[c<sub>i</sub>, d<sub>i</sub>]</code>, remove one occurrence of the character at index <code>x</code> from the frequency array on the right side.", "Finally, check whether the two frequency arrays are the same, and the indices that don't fall into any of the intervals are the same as well.", "Use prefix-sum + hashing to improve the time complexity."], "exampleTestcases": "\"abcabc\"\n[[1,1,3,5],[0,2,5,5]]\n\"abbcdecbba\"\n[[0,2,7,9]]\n\"acbcab\"\n[[1,2,4,5]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<bool> canMakePalindromeQueries(string s, vector<vector<int>>& queries) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public boolean[] canMakePalindromeQueries(String s, int[][] queries) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def canMakePalindromeQueries(self, s, queries):\n        \"\"\"\n        :type s: str\n        :type queries: List[List[int]]\n        :rtype: List[bool]\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nbool* canMakePalindromeQueries(char* s, int** queries, int queriesSize, int* queriesColSize, int* returnSize) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public bool[] CanMakePalindromeQueries(string s, int[][] queries) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {string} s\n * @param {number[][]} queries\n * @return {boolean[]}\n */\nvar canMakePalindromeQueries = function(s, queries) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function canMakePalindromeQueries(s: string, queries: number[][]): boolean[] {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer[][] $queries\n     * @return Boolean[]\n     */\n    function canMakePalindromeQueries($s, $queries) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func canMakePalindromeQueries(_ s: String, _ queries: [[Int]]) -> [Bool] {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun canMakePalindromeQueries(s: String, queries: Array<IntArray>): BooleanArray {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  List<bool> canMakePalindromeQueries(String s, List<List<int>> queries) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func canMakePalindromeQueries(s string, queries [][]int) []bool {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {String} s\n# @param {Integer[][]} queries\n# @return {Boolean[]}\ndef can_make_palindrome_queries(s, queries)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def canMakePalindromeQueries(s: String, queries: Array[Array[Int]]): Array[Boolean] = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn can_make_palindrome_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<bool> {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (can-make-palindrome-queries s queries)\n  (-> string? (listof (listof exact-integer?)) (listof boolean?))\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec can_make_palindrome_queries(S :: unicode:unicode_binary(), Queries :: [[integer()]]) -> [boolean()].\ncan_make_palindrome_queries(S, Queries) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec can_make_palindrome_queries(s :: String.t, queries :: [[integer]]) :: [boolean]\n  def can_make_palindrome_queries(s, queries) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Hard", "titleSlug": "longest-chunked-palindrome-decomposition", "title": "Longest Chunked Palindrome Decomposition", "isPaidOnly": false}]}