{"question_id": "771", "problem_slug": "encode-n-ary-tree-to-binary-tree", "problem_title": "Encode N-ary Tree to Binary Tree", "content": "Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See following example).\nFor example, you may encode the following 3-ary tree to a binary tree in this way:\n\n\nInput: root = [1,null,3,2,4,null,5,6]\n\nNote that the above is just an example which might or might not work. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n \nExample 1:\nInput: root = [1,null,3,2,4,null,5,6]\nOutput: [1,null,3,2,4,null,5,6]\nExample 2:\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nExample 3:\nInput: root = []\nOutput: []\n\n \nConstraints:\n\nThe number of nodes in the tree is in the range [0, 104].\n0 <= Node.val <= 104\nThe height of the n-ary tree is less than or equal to 1000\nDo not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\n\n", "hints": [], "exampleTestcases": "[1,null,3,2,4,null,5,6]\n[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n[]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Codec {\npublic:\n    // Encodes an n-ary tree to a binary tree.\n    TreeNode* encode(Node* root) {\n        \n    }\n\t\n    // Decodes your binary tree to an n-ary tree.\n    Node* decode(TreeNode* root) {\n        \n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.decode(codec.encode(root));"}, "Java": {"langSlug": "java", "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Codec {\n    // Encodes an n-ary tree to a binary tree.\n    public TreeNode encode(Node root) {\n        \n    }\n\t\n    // Decodes your binary tree to an n-ary tree.\n    public Node decode(TreeNode root) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));"}, "Python": {"langSlug": "python", "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\"\"\"\n\nclass Codec:\n    def encode(self, root):\n        \"\"\"Encodes an n-ary tree to a binary tree.\n        :type root: Node\n        :rtype: TreeNode\n        \"\"\"\n        \n\t\n    def decode(self, data):\n        \"\"\"Decodes your binary tree to an n-ary tree.\n        :type data: TreeNode\n        :rtype: Node\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(root))"}, "Python3": {"langSlug": "python3", "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\"\"\"\n\nclass Codec:\n    # Encodes an n-ary tree to a binary tree.\n    def encode(self, root: 'Optional[Node]') -> Optional[TreeNode]:\n        \n\t\n\t# Decodes your binary tree to an n-ary tree.\n    def decode(self, data: Optional[TreeNode]) -> 'Optional[Node]':\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(root))"}, "C#": {"langSlug": "csharp", "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, IList<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n*/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\n\npublic class Codec {\n    // Encodes an n-ary tree to a binary tree.\n    public TreeNode encode(Node root) {\n        \n    }\n    \n    // Decodes your binary tree to an n-ary tree.\n    public Node decode(TreeNode root) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * // Definition for a _Node.\n * function _Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\nclass Codec {\n  \tconstructor() {\n    }\n    \n    /** \n     * @param {_Node|null} root\n     * @return {TreeNode|null}\n     */\n    // Encodes an n-ary tree to a binary tree.\n    encode = function(root) {\n\t\t\n    };\n\t\n    /** \n     * @param {TreeNode|null} root \n     * @return {_Node|null}\n     */\n    // Decodes your binary tree to an n-ary tree.\n    decode = function(root) {\n\t\t\n    };\n}\n\n/*\n* Your Codec object will be instantiated and called as such:\n* codec = Codec()\n* codec.decode(codec.encode(root))\n*/"}, "TypeScript": {"langSlug": "typescript", "code": "/**\n * Definition for _Node.\n * class _Node {\n *     val: number\n *     children: _Node[]\n *     \n *     constructor(v: number) {\n *         this.val = v;\n *         this.children = [];\n *     }\n * }\n */\n\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass Codec {\n  \tconstructor() {\n        \n    }\n    \n    // Encodes a tree to a binary tree.\n    serialize(root: _Node | null): TreeNode | null {\n        \n    };\n\t\n    // Decodes your encoded data to tree.\n    deserialize(root: TreeNode | null): _Node | null {\n        \n    };\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));"}, "PHP": {"langSlug": "php", "code": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $children = null;\n *     function __construct($val = 0) {\n *         $this->val = $val;\n *         $this->children = array();\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\n\nclass Codec {\n    /**\n     * @param Node $root\n     * @return TreeNode\n     */\n    function encode($root) {\n    \t\n    }\n    \n    /**\n     * @param TreeNode $root\n     * @return Node\n     */\n    function decode($root) {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $obj = Codec();\n * $ret_1 = $obj->encode($root);\n * $ret_2 = $obj->decode($root);\n */"}, "Swift": {"langSlug": "swift", "code": "/**\n * Definition for a Node.\n * public class Node {\n *     public var val: Int\n *     public var children: [Node]\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.children = []\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\n\nclass Codec {\n    func encode(_ root: Node?) -> TreeNode? {\n        \n    }\n    \n    func decode(_ root: TreeNode?) -> Node? {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * let obj = Codec()\n * let ret_1: TreeNode? = obj.encode(root)\n * let ret_2: Node? = obj.decode(root)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "/**\n * Definition for a Node.\n * class Node(var `val`: Int) {\n *     var children: List<Node?> = listOf()\n * }\n */\n\n/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n\nclass Codec {\n    // Encodes a tree to a single string.\n    fun encode(root: Node?): TreeNode? {\n        \n    }\n    \n    // Decodes your encoded data to tree.\n    fun decode(root: TreeNode?): Node? {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = Codec()\n * var data = obj.encode(root)\n * var ans = obj.decode(data)\n */"}, "Go": {"langSlug": "golang", "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\ntype Codec struct {\n    \n}\n\nfunc Constructor() *Codec {\n    \n}\n\nfunc (this *Codec) encode(root *Node) *TreeNode {\n    \n}\n\nfunc (this *Codec) decode(root *TreeNode) *Node {\n    \n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * obj := Constructor();\n * bst := obj.encode(root);\n * ans := obj.decode(bst);\n */"}, "Ruby": {"langSlug": "ruby", "code": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :children\n#     def initialize(val=0, children=[])\n#         @val = val\n#         @children = children\n#     end\n# end\n\n# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\nclass Codec\n    # Encodes an n-ary tree to a binary tree.\n    # @param {Node} root\n\t# @return {TreeNode}\n    def encode(root)\n    \t\n    end\n    \n    # Decodes your binary tree to an n-ary tree.\n    # @param {TreeNode} root\n\t# @return {Node}\n    def decode(root)\n        \n    end\nend\n\n# Your Codec object will be instantiated and called as such:\n# obj = Codec.new()\n# data = obj.encode(root)\n# ans = obj.decode(data)"}, "Scala": {"langSlug": "scala", "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var children: List[Node] = List()\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\n\nclass Codec {\n    // Encodes an n-ary tree to a binary tree.\n    def encode(root: Node): TreeNode = {\n        \n    }\n    \n    // Decodes your binary tree to an n-ary tree.\n    def decode(root: TreeNode): Node = {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = new Codec()\n * var data = obj.encode(root)\n * var ans = obj.decode(data)\n */"}}}