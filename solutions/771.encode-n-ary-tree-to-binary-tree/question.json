{"questionId": "771", "acRate": 79.7713717693837, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "431", "paidOnly": true, "status": "ac", "title": "Encode N-ary Tree to Binary Tree", "topicTags": [{"name": "Tree", "id": "VG9waWNUYWdOb2RlOjIw", "slug": "tree"}, {"name": "Depth-First Search", "id": "VG9waWNUYWdOb2RlOjIx", "slug": "depth-first-search"}, {"name": "Breadth-First Search", "id": "VG9waWNUYWdOb2RlOjIy", "slug": "breadth-first-search"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}, {"name": "Binary Tree", "id": "VG9waWNUYWdOb2RlOjYxMDU3", "slug": "binary-tree"}], "titleSlug": "encode-n-ary-tree-to-binary-tree", "content": "<p>Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See following example).</em></p>\n\n<p>For example, you may encode the following <code>3-ary</code> tree to a binary tree in this way:</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreebinarytreeexample.png\" style=\"width: 100%; max-width: 640px\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n</pre>\n\n<p>Note that the above is just an example which <em>might or might not</em> work. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [1,null,3,2,4,null,5,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</li>\n</ul>\n", "hints": [], "exampleTestcases": "[1,null,3,2,4,null,5,6]\n[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n[]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Codec {\npublic:\n    // Encodes an n-ary tree to a binary tree.\n    TreeNode* encode(Node* root) {\n        \n    }\n\t\n    // Decodes your binary tree to an n-ary tree.\n    Node* decode(TreeNode* root) {\n        \n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.decode(codec.encode(root));"}, {"lang": "Java", "langSlug": "java", "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Codec {\n    // Encodes an n-ary tree to a binary tree.\n    public TreeNode encode(Node root) {\n        \n    }\n\t\n    // Decodes your binary tree to an n-ary tree.\n    public Node decode(TreeNode root) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));"}, {"lang": "Python", "langSlug": "python", "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\"\"\"\n\nclass Codec:\n    def encode(self, root):\n        \"\"\"Encodes an n-ary tree to a binary tree.\n        :type root: Node\n        :rtype: TreeNode\n        \"\"\"\n        \n\t\n    def decode(self, data):\n        \"\"\"Decodes your binary tree to an n-ary tree.\n        :type data: TreeNode\n        :rtype: Node\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(root))"}, {"lang": "Python3", "langSlug": "python3", "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children\n\"\"\"\n\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\"\"\"\n\nclass Codec:\n    # Encodes an n-ary tree to a binary tree.\n    def encode(self, root: 'Optional[Node]') -> Optional[TreeNode]:\n        \n\t\n\t# Decodes your binary tree to an n-ary tree.\n    def decode(self, data: Optional[TreeNode]) -> 'Optional[Node]':\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(root))"}, {"lang": "C#", "langSlug": "csharp", "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, IList<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n*/\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\n\npublic class Codec {\n    // Encodes an n-ary tree to a binary tree.\n    public TreeNode encode(Node root) {\n        \n    }\n    \n    // Decodes your binary tree to an n-ary tree.\n    public Node decode(TreeNode root) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * // Definition for a _Node.\n * function _Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\nclass Codec {\n  \tconstructor() {\n    }\n    \n    /** \n     * @param {_Node|null} root\n     * @return {TreeNode|null}\n     */\n    // Encodes an n-ary tree to a binary tree.\n    encode = function(root) {\n\t\t\n    };\n\t\n    /** \n     * @param {TreeNode|null} root \n     * @return {_Node|null}\n     */\n    // Decodes your binary tree to an n-ary tree.\n    decode = function(root) {\n\t\t\n    };\n}\n\n/*\n* Your Codec object will be instantiated and called as such:\n* codec = Codec()\n* codec.decode(codec.encode(root))\n*/"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "/**\n * Definition for _Node.\n * class _Node {\n *     val: number\n *     children: _Node[]\n *     \n *     constructor(v: number) {\n *         this.val = v;\n *         this.children = [];\n *     }\n * }\n */\n\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass Codec {\n  \tconstructor() {\n        \n    }\n    \n    // Encodes a tree to a binary tree.\n    serialize(root: _Node | null): TreeNode | null {\n        \n    };\n\t\n    // Decodes your encoded data to tree.\n    deserialize(root: TreeNode | null): _Node | null {\n        \n    };\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));"}, {"lang": "PHP", "langSlug": "php", "code": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $children = null;\n *     function __construct($val = 0) {\n *         $this->val = $val;\n *         $this->children = array();\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\n\nclass Codec {\n    /**\n     * @param Node $root\n     * @return TreeNode\n     */\n    function encode($root) {\n    \t\n    }\n    \n    /**\n     * @param TreeNode $root\n     * @return Node\n     */\n    function decode($root) {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $obj = Codec();\n * $ret_1 = $obj->encode($root);\n * $ret_2 = $obj->decode($root);\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "/**\n * Definition for a Node.\n * public class Node {\n *     public var val: Int\n *     public var children: [Node]\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.children = []\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\n\nclass Codec {\n    func encode(_ root: Node?) -> TreeNode? {\n        \n    }\n    \n    func decode(_ root: TreeNode?) -> Node? {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * let obj = Codec()\n * let ret_1: TreeNode? = obj.encode(root)\n * let ret_2: Node? = obj.decode(root)\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "/**\n * Definition for a Node.\n * class Node(var `val`: Int) {\n *     var children: List<Node?> = listOf()\n * }\n */\n\n/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\n\nclass Codec {\n    // Encodes a tree to a single string.\n    fun encode(root: Node?): TreeNode? {\n        \n    }\n    \n    // Decodes your encoded data to tree.\n    fun decode(root: TreeNode?): Node? {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = Codec()\n * var data = obj.encode(root)\n * var ans = obj.decode(data)\n */"}, {"lang": "Go", "langSlug": "golang", "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\ntype Codec struct {\n    \n}\n\nfunc Constructor() *Codec {\n    \n}\n\nfunc (this *Codec) encode(root *Node) *TreeNode {\n    \n}\n\nfunc (this *Codec) decode(root *TreeNode) *Node {\n    \n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * obj := Constructor();\n * bst := obj.encode(root);\n * ans := obj.decode(bst);\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :children\n#     def initialize(val=0, children=[])\n#         @val = val\n#         @children = children\n#     end\n# end\n\n# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\nclass Codec\n    # Encodes an n-ary tree to a binary tree.\n    # @param {Node} root\n\t# @return {TreeNode}\n    def encode(root)\n    \t\n    end\n    \n    # Decodes your binary tree to an n-ary tree.\n    # @param {TreeNode} root\n\t# @return {Node}\n    def decode(root)\n        \n    end\nend\n\n# Your Codec object will be instantiated and called as such:\n# obj = Codec.new()\n# data = obj.encode(root)\n# ans = obj.decode(data)"}, {"lang": "Scala", "langSlug": "scala", "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var children: List[Node] = List()\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\n\nclass Codec {\n    // Encodes an n-ary tree to a binary tree.\n    def encode(root: Node): TreeNode = {\n        \n    }\n    \n    // Decodes your binary tree to an n-ary tree.\n    def decode(root: TreeNode): Node = {\n        \n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * var obj = new Codec()\n * var data = obj.encode(root)\n * var ans = obj.decode(data)\n */"}], "similarQuestionList": [{"difficulty": "Hard", "titleSlug": "serialize-and-deserialize-n-ary-tree", "title": "Serialize and Deserialize N-ary Tree", "isPaidOnly": true}]}