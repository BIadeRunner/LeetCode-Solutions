{"question_id": "511", "problem_slug": "all-paths-from-source-lead-to-destination", "problem_title": "All Paths from Source Lead to Destination", "content": "Given the edges of a directed graph where edges[i] = [ai, bi] indicates there is an edge between nodes ai and bi, and two nodes source and destination of this graph, determine whether or not all paths starting from source eventually, end at destination, that is:\n\nAt least one path exists from the source node to the destination node\nIf a path exists from the source node to a node with no outgoing edges, then that node is equal to destination.\nThe number of possible paths from source to destination is a finite number.\n\nReturn true if and only if all roads from source lead to destination.\n \nExample 1:\n\n\nInput: n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2\nOutput: false\nExplanation: It is possible to reach and get stuck on both node 1 and node 2.\n\nExample 2:\n\n\nInput: n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3\nOutput: false\nExplanation: We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely.\n\nExample 3:\n\n\nInput: n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3\nOutput: true\n\n \nConstraints:\n\n1 <= n <= 104\n0 <= edges.length <= 104\nedges.length == 2\n0 <= ai, bi <= n - 1\n0 <= source <= n - 1\n0 <= destination <= n - 1\nThe given graph may have self-loops and parallel edges.\n\n", "hints": ["What if we can reach to a cycle from the source node?", "Then the answer will be false, because we eventually get trapped in the cycle forever.", "What if the we can't reach to a cycle from the source node? Then we need to ensure that from all visited nodes from source the unique node with indegree = 0 is the destination node."], "exampleTestcases": "3\n[[0,1],[0,2]]\n0\n2\n4\n[[0,1],[0,3],[1,2],[2,1]]\n0\n3\n4\n[[0,1],[0,2],[1,3],[2,3]]\n0\n3", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool leadsToDestination(int n, vector<vector<int>>& edges, int source, int destination) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean leadsToDestination(int n, int[][] edges, int source, int destination) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def leadsToDestination(self, n, edges, source, destination):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type source: int\n        :type destination: int\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def leadsToDestination(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool leadsToDestination(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool LeadsToDestination(int n, int[][] edges, int source, int destination) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} source\n * @param {number} destination\n * @return {boolean}\n */\nvar leadsToDestination = function(n, edges, source, destination) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function leadsToDestination(n: number, edges: number[][], source: number, destination: number): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer $source\n     * @param Integer $destination\n     * @return Boolean\n     */\n    function leadsToDestination($n, $edges, $source, $destination) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func leadsToDestination(_ n: Int, _ edges: [[Int]], _ source: Int, _ destination: Int) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun leadsToDestination(n: Int, edges: Array<IntArray>, source: Int, destination: Int): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool leadsToDestination(int n, List<List<int>> edges, int source, int destination) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func leadsToDestination(n int, edges [][]int, source int, destination int) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer} source\n# @param {Integer} destination\n# @return {Boolean}\ndef leads_to_destination(n, edges, source, destination)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def leadsToDestination(n: Int, edges: Array[Array[Int]], source: Int, destination: Int): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn leads_to_destination(n: i32, edges: Vec<Vec<i32>>, source: i32, destination: i32) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (leads-to-destination n edges source destination)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer? boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec leads_to_destination(N :: integer(), Edges :: [[integer()]], Source :: integer(), Destination :: integer()) -> boolean().\nleads_to_destination(N, Edges, Source, Destination) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec leads_to_destination(n :: integer, edges :: [[integer]], source :: integer, destination :: integer) :: boolean\n  def leads_to_destination(n, edges, source, destination) do\n    \n  end\nend"}}}