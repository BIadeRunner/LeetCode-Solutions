{"question_id": "699", "problem_slug": "falling-squares", "problem_title": "Falling Squares", "content": "There are several squares being dropped onto the X-axis of a 2D plane.\nYou are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\nAfter each square is dropped, you must record the height of the current tallest stack of squares.\nReturn an integer array ans where ans[i] represents the height described above after dropping the ith square.\n \nExample 1:\n\n\nInput: positions = [[1,2],[2,3],[6,1]]\nOutput: [2,5,5]\nExplanation:\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of [2, 5, 5].\n\nExample 2:\n\nInput: positions = [[100,100],[200,100]]\nOutput: [100,100]\nExplanation:\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of [100, 100].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it.\n\n \nConstraints:\n\n1 <= positions.length <= 1000\n1 <= lefti <= 108\n1 <= sideLengthi <= 106\n\n", "hints": ["If positions = [[10, 20], [20, 30]], this is the same as [[1, 2], [2, 3]].  Currently, the values of positions are very large.  Can you generalize this approach so as to make the values in positions manageable?"], "exampleTestcases": "[[1,2],[2,3],[6,1]]\n[[100,100],[200,100]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> fallingSquares(vector<vector<int>>& positions) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public List<Integer> fallingSquares(int[][] positions) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def fallingSquares(self, positions: List[List[int]]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* fallingSquares(int** positions, int positionsSize, int* positionsColSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public IList<int> FallingSquares(int[][] positions) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} positions\n * @return {number[]}\n */\nvar fallingSquares = function(positions) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function fallingSquares(positions: number[][]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $positions\n     * @return Integer[]\n     */\n    function fallingSquares($positions) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func fallingSquares(_ positions: [[Int]]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun fallingSquares(positions: Array<IntArray>): List<Int> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> fallingSquares(List<List<int>> positions) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func fallingSquares(positions [][]int) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[][]} positions\n# @return {Integer[]}\ndef falling_squares(positions)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def fallingSquares(positions: Array[Array[Int]]): List[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn falling_squares(positions: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (falling-squares positions)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec falling_squares(Positions :: [[integer()]]) -> [integer()].\nfalling_squares(Positions) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec falling_squares(positions :: [[integer]]) :: [integer]\n  def falling_squares(positions) do\n    \n  end\nend"}}}