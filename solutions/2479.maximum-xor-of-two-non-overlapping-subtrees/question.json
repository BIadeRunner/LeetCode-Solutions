{"questionId": "2623", "acRate": 49.502133712660026, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "2479", "paidOnly": true, "status": "ac", "title": "Maximum XOR of Two Non-Overlapping Subtrees", "topicTags": [{"name": "Tree", "id": "VG9waWNUYWdOb2RlOjIw", "slug": "tree"}, {"name": "Depth-First Search", "id": "VG9waWNUYWdOb2RlOjIx", "slug": "depth-first-search"}, {"name": "Graph", "id": "VG9waWNUYWdOb2RlOjI0", "slug": "graph"}, {"name": "Trie", "id": "VG9waWNUYWdOb2RlOjI3", "slug": "trie"}], "titleSlug": "maximum-xor-of-two-non-overlapping-subtrees", "content": "<p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given the integer <code>n</code> and a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree. The root of the tree is the node labeled <code>0</code>.</p>\n\n<p>Each node has an associated <strong>value</strong>. You are given an array <code>values</code> of length <code>n</code>, where <code>values[i]</code> is the <strong>value</strong> of the <code>i<sup>th</sup></code> node.</p>\n\n<p>Select any two <strong>non-overlapping</strong> subtrees. Your <strong>score</strong> is the bitwise XOR of the sum of the values within those subtrees.</p>\n\n<p>Return <em>the</em> <em><strong>maximum</strong></em> <i>possible <strong>score</strong> you can achieve</i>. <em>If it is impossible to find two nonoverlapping subtrees</em>, return <code>0</code>.</p>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>The <strong>subtree</strong> of a node is the tree consisting of that node and all of its descendants.</li>\n\t<li>Two subtrees are <strong>non-overlapping </strong>if they do not share <strong>any common</strong> node.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/22/treemaxxor.png\" style=\"width: 346px; height: 249px;\" />\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]\n<strong>Output:</strong> 24\n<strong>Explanation:</strong> Node 1&#39;s subtree has sum of values 16, while node 2&#39;s subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/22/tree3drawio.png\" style=\"width: 240px; height: 261px;\" />\n<pre>\n<strong>Input:</strong> n = 3, edges = [[0,1],[1,2]], values = [4,6,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no possible way to select two non-overlapping subtrees, so we just return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>values.length == n</code></li>\n\t<li><code>1 &lt;= values[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>It is guaranteed that <code>edges</code> represents a valid tree.</li>\n</ul>\n", "hints": ["Try to build the answer bit by bit from the most significant bit to the least significant.", "Use the Trie Data Structure to decide for each bit if it exists in the final answer."], "exampleTestcases": "6\n[[0,1],[0,2],[1,3],[1,4],[2,5]]\n[2,8,3,6,2,5]\n3\n[[0,1],[1,2]]\n[4,6,1]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    long long maxXor(int n, vector<vector<int>>& edges, vector<int>& values) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public long maxXor(int n, int[][] edges, int[] values) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def maxXor(self, n, edges, values):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def maxXor(self, n: int, edges: List[List[int]], values: List[int]) -> int:\n        "}, {"lang": "C", "langSlug": "c", "code": "long long maxXor(int n, int** edges, int edgesSize, int* edgesColSize, int* values, int valuesSize) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public long MaxXor(int n, int[][] edges, int[] values) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} values\n * @return {number}\n */\nvar maxXor = function(n, edges, values) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function maxXor(n: number, edges: number[][], values: number[]): number {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer[] $values\n     * @return Integer\n     */\n    function maxXor($n, $edges, $values) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func maxXor(_ n: Int, _ edges: [[Int]], _ values: [Int]) -> Int {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun maxXor(n: Int, edges: Array<IntArray>, values: IntArray): Long {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  int maxXor(int n, List<List<int>> edges, List<int> values) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func maxXor(n int, edges [][]int, values []int) int64 {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer[]} values\n# @return {Integer}\ndef max_xor(n, edges, values)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def maxXor(n: Int, edges: Array[Array[Int]], values: Array[Int]): Long = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn max_xor(n: i32, edges: Vec<Vec<i32>>, values: Vec<i32>) -> i64 {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (max-xor n edges values)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec max_xor(N :: integer(), Edges :: [[integer()]], Values :: [integer()]) -> integer().\nmax_xor(N, Edges, Values) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec max_xor(n :: integer, edges :: [[integer]], values :: [integer]) :: integer\n  def max_xor(n, edges, values) do\n    \n  end\nend"}], "similarQuestionList": []}