{"question_id": "293", "problem_slug": "flip-game", "problem_title": "Flip Game", "content": "You are playing a Flip Game with your friend.\nYou are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move, and therefore the other person will be the winner.\nReturn all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].\n \nExample 1:\n\nInput: currentState = \"++++\"\nOutput: [\"--++\",\"+--+\",\"++--\"]\n\nExample 2:\n\nInput: currentState = \"+\"\nOutput: []\n\n \nConstraints:\n\n1 <= currentState.length <= 500\ncurrentState[i] is either '+' or '-'.\n\n", "hints": [], "exampleTestcases": "\"++++\"\n\"+\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<string> generatePossibleNextMoves(string currentState) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public List<String> generatePossibleNextMoves(String currentState) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def generatePossibleNextMoves(self, currentState):\n        \"\"\"\n        :type currentState: str\n        :rtype: List[str]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def generatePossibleNextMoves(self, currentState: str) -> List[str]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** generatePossibleNextMoves(char* currentState, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public IList<string> GeneratePossibleNextMoves(string currentState) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} currentState\n * @return {string[]}\n */\nvar generatePossibleNextMoves = function(currentState) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function generatePossibleNextMoves(currentState: string): string[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $currentState\n     * @return String[]\n     */\n    function generatePossibleNextMoves($currentState) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func generatePossibleNextMoves(_ currentState: String) -> [String] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun generatePossibleNextMoves(currentState: String): List<String> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<String> generatePossibleNextMoves(String currentState) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func generatePossibleNextMoves(currentState string) []string {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} current_state\n# @return {String[]}\ndef generate_possible_next_moves(current_state)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def generatePossibleNextMoves(currentState: String): List[String] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn generate_possible_next_moves(current_state: String) -> Vec<String> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (generate-possible-next-moves currentState)\n  (-> string? (listof string?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec generate_possible_next_moves(CurrentState :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\ngenerate_possible_next_moves(CurrentState) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec generate_possible_next_moves(current_state :: String.t) :: [String.t]\n  def generate_possible_next_moves(current_state) do\n    \n  end\nend"}}}