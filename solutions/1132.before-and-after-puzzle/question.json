{"question_id": "1132", "problem_slug": "before-and-after-puzzle", "problem_title": "Before and After Puzzle", "content": "Given a list of phrases, generate a list of Before and After puzzles.\nA phrase is a string that consists of lowercase English letters and spaces only. No space appears in the start or the end of a phrase. There are no consecutive spaces in a phrase.\nBefore and After puzzles are phrases that are formed by merging two phrases where the last word of the first phrase is the same as the first word of the second phrase.\nReturn the Before and After puzzles that can be formed by every two phrases phrases[i] and phrases[j] where i != j. Note that the order of matching two phrases matters, we want to consider both orders.\nYou should return a list of distinct strings sorted lexicographically.\n \nExample 1:\n\nInput: phrases = [\"writing code\",\"code rocks\"]\nOutput: [\"writing code rocks\"]\n\nExample 2:\n\nInput: phrases = [\"mission statement\",\n                  \"a quick bite to eat\",\n                  \"a chip off the old block\",\n                  \"chocolate bar\",\n                  \"mission impossible\",\n                  \"a man on a mission\",\n                  \"block party\",\n                  \"eat my words\",\n                  \"bar of soap\"]\nOutput: [\"a chip off the old block party\",\n         \"a man on a mission impossible\",\n         \"a man on a mission statement\",\n         \"a quick bite to eat my words\",\n         \"chocolate bar of soap\"]\n\nExample 3:\n\nInput: phrases = [\"a\",\"b\",\"a\"]\nOutput: [\"a\"]\n\n \nConstraints:\n\n1 <= phrases.length <= 100\n1 <= phrases[i].length <= 100\n\n", "hints": ["What if you check every pair of strings (bruteforce)?", "For every two strings, check if they can form a puzzle by comparing their last and first words."], "exampleTestcases": "[\"writing code\",\"code rocks\"]\n[\"mission statement\",\"a quick bite to eat\",\"a chip off the old block\",\"chocolate bar\",\"mission impossible\",\"a man on a mission\",\"block party\",\"eat my words\",\"bar of soap\"]\n[\"a\",\"b\",\"a\"]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<string> beforeAndAfterPuzzles(vector<string>& phrases) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public List<String> beforeAndAfterPuzzles(String[] phrases) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def beforeAndAfterPuzzles(self, phrases):\n        \"\"\"\n        :type phrases: List[str]\n        :rtype: List[str]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def beforeAndAfterPuzzles(self, phrases: List[str]) -> List[str]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** beforeAndAfterPuzzles(char** phrases, int phrasesSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public IList<string> BeforeAndAfterPuzzles(string[] phrases) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string[]} phrases\n * @return {string[]}\n */\nvar beforeAndAfterPuzzles = function(phrases) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function beforeAndAfterPuzzles(phrases: string[]): string[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String[] $phrases\n     * @return String[]\n     */\n    function beforeAndAfterPuzzles($phrases) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func beforeAndAfterPuzzles(_ phrases: [String]) -> [String] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun beforeAndAfterPuzzles(phrases: Array<String>): List<String> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<String> beforeAndAfterPuzzles(List<String> phrases) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func beforeAndAfterPuzzles(phrases []string) []string {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String[]} phrases\n# @return {String[]}\ndef before_and_after_puzzles(phrases)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def beforeAndAfterPuzzles(phrases: Array[String]): List[String] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn before_and_after_puzzles(phrases: Vec<String>) -> Vec<String> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (before-and-after-puzzles phrases)\n  (-> (listof string?) (listof string?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec before_and_after_puzzles(Phrases :: [unicode:unicode_binary()]) -> [unicode:unicode_binary()].\nbefore_and_after_puzzles(Phrases) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec before_and_after_puzzles(phrases :: [String.t]) :: [String.t]\n  def before_and_after_puzzles(phrases) do\n    \n  end\nend"}}}