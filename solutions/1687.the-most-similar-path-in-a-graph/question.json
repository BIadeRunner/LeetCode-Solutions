{"question_id": "1687", "problem_slug": "the-most-similar-path-in-a-graph", "problem_title": "The Most Similar Path in a Graph", "content": "We have n cities and m bi-directional roads where roads[i] = [ai, bi] connects city ai with city bi. Each city has a name consisting of exactly three upper-case English letters given in the string array names. Starting at any city x, you can reach any city y where y != x (i.e., the cities and the roads are forming an undirected connected graph).\nYou will be given a string array targetPath. You should find a path in the graph of the same length and with the minimum edit distance to targetPath.\nYou need to return the order of the nodes in the path with the minimum edit distance. The path should be of the same length of targetPath and should be valid (i.e., there should be a direct road between ans[i] and ans[i + 1]). If there are multiple answers return any one of them.\nThe edit distance is defined as follows:\n\n \nExample 1:\n\n\nInput: n = 5, roads = [[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]], names = [\"ATL\",\"PEK\",\"LAX\",\"DXB\",\"HND\"], targetPath = [\"ATL\",\"DXB\",\"HND\",\"LAX\"]\nOutput: [0,2,4,2]\nExplanation: [0,2,4,2], [0,3,0,2] and [0,3,1,2] are accepted answers.\n[0,2,4,2] is equivalent to [\"ATL\",\"LAX\",\"HND\",\"LAX\"] which has edit distance = 1 with targetPath.\n[0,3,0,2] is equivalent to [\"ATL\",\"DXB\",\"ATL\",\"LAX\"] which has edit distance = 1 with targetPath.\n[0,3,1,2] is equivalent to [\"ATL\",\"DXB\",\"PEK\",\"LAX\"] which has edit distance = 1 with targetPath.\n\nExample 2:\n\n\nInput: n = 4, roads = [[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]], names = [\"ATL\",\"PEK\",\"LAX\",\"DXB\"], targetPath = [\"ABC\",\"DEF\",\"GHI\",\"JKL\",\"MNO\",\"PQR\",\"STU\",\"VWX\"]\nOutput: [0,1,0,1,0,1,0,1]\nExplanation: Any path in this graph has edit distance = 8 with targetPath.\n\nExample 3:\n\n\nInput: n = 6, roads = [[0,1],[1,2],[2,3],[3,4],[4,5]], names = [\"ATL\",\"PEK\",\"LAX\",\"ATL\",\"DXB\",\"HND\"], targetPath = [\"ATL\",\"DXB\",\"HND\",\"DXB\",\"ATL\",\"LAX\",\"PEK\"]\nOutput: [3,4,5,4,3,2,1]\nExplanation: [3,4,5,4,3,2,1] is the only path with edit distance = 0 with targetPath.\nIt's equivalent to [\"ATL\",\"DXB\",\"HND\",\"DXB\",\"ATL\",\"LAX\",\"PEK\"]\n\n \nConstraints:\n\n2 <= n <= 100\nm == roads.length\nn - 1 <= m <= (n * (n - 1) / 2)\n0 <= ai, bi <= n - 1\nai != bi\nThe graph is guaranteed to be connected and each pair of nodes may have at most one direct road.\nnames.length == n\nnames[i].length == 3\nnames[i] consists of upper-case English letters.\nThere can be two cities with the same name.\n1 <= targetPath.length <= 100\ntargetPath[i].length == 3\ntargetPath[i] consists of upper-case English letters.\n\n \nFollow up: If each node can be visited only once in the path, What should you change in your solution?\n", "hints": ["Create an array dp where dp[i][j] is the min edit distance for the path starting at node i and compared to index j of the targetPath.", "Traverse the dp array to obtain a valid answer."], "exampleTestcases": "5\n[[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]]\n[\"ATL\",\"PEK\",\"LAX\",\"DXB\",\"HND\"]\n[\"ATL\",\"DXB\",\"HND\",\"LAX\"]\n4\n[[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]]\n[\"ATL\",\"PEK\",\"LAX\",\"DXB\"]\n[\"ABC\",\"DEF\",\"GHI\",\"JKL\",\"MNO\",\"PQR\",\"STU\",\"VWX\"]\n6\n[[0,1],[1,2],[2,3],[3,4],[4,5]]\n[\"ATL\",\"PEK\",\"LAX\",\"ATL\",\"DXB\",\"HND\"]\n[\"ATL\",\"DXB\",\"HND\",\"DXB\",\"ATL\",\"LAX\",\"PEK\"]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> mostSimilar(int n, vector<vector<int>>& roads, vector<string>& names, vector<string>& targetPath) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public List<Integer> mostSimilar(int n, int[][] roads, String[] names, String[] targetPath) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def mostSimilar(self, n, roads, names, targetPath):\n        \"\"\"\n        :type n: int\n        :type roads: List[List[int]]\n        :type names: List[str]\n        :type targetPath: List[str]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def mostSimilar(self, n: int, roads: List[List[int]], names: List[str], targetPath: List[str]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* mostSimilar(int n, int** roads, int roadsSize, int* roadsColSize, char** names, int namesSize, char** targetPath, int targetPathSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public IList<int> MostSimilar(int n, int[][] roads, string[] names, string[] targetPath) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} roads\n * @param {string[]} names\n * @param {string[]} targetPath\n * @return {number[]}\n */\nvar mostSimilar = function(n, roads, names, targetPath) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function mostSimilar(n: number, roads: number[][], names: string[], targetPath: string[]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $roads\n     * @param String[] $names\n     * @param String[] $targetPath\n     * @return Integer[]\n     */\n    function mostSimilar($n, $roads, $names, $targetPath) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func mostSimilar(_ n: Int, _ roads: [[Int]], _ names: [String], _ targetPath: [String]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun mostSimilar(n: Int, roads: Array<IntArray>, names: Array<String>, targetPath: Array<String>): List<Int> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> mostSimilar(int n, List<List<int>> roads, List<String> names, List<String> targetPath) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func mostSimilar(n int, roads [][]int, names []string, targetPath []string) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} roads\n# @param {String[]} names\n# @param {String[]} target_path\n# @return {Integer[]}\ndef most_similar(n, roads, names, target_path)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def mostSimilar(n: Int, roads: Array[Array[Int]], names: Array[String], targetPath: Array[String]): List[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn most_similar(n: i32, roads: Vec<Vec<i32>>, names: Vec<String>, target_path: Vec<String>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (most-similar n roads names targetPath)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof string?) (listof string?) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec most_similar(N :: integer(), Roads :: [[integer()]], Names :: [unicode:unicode_binary()], TargetPath :: [unicode:unicode_binary()]) -> [integer()].\nmost_similar(N, Roads, Names, TargetPath) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec most_similar(n :: integer, roads :: [[integer]], names :: [String.t], target_path :: [String.t]) :: [integer]\n  def most_similar(n, roads, names, target_path) do\n    \n  end\nend"}}}