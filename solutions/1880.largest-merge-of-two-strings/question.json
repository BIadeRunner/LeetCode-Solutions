{"questionId": "1880", "acRate": 49.18195339613287, "difficulty": "Medium", "freqBar": 0.0, "frontendQuestionId": "1754", "paidOnly": false, "status": "ac", "title": "Largest Merge Of Two Strings", "topicTags": [{"name": "Two Pointers", "id": "VG9waWNUYWdOb2RlOjk=", "slug": "two-pointers"}, {"name": "String", "id": "VG9waWNUYWdOb2RlOjEw", "slug": "string"}, {"name": "Greedy", "id": "VG9waWNUYWdOb2RlOjE3", "slug": "greedy"}], "titleSlug": "largest-merge-of-two-strings", "content": "<p>You are given two strings <code>word1</code> and <code>word2</code>. You want to construct a string <code>merge</code> in the following way: while either <code>word1</code> or <code>word2</code> are non-empty, choose <strong>one</strong> of the following options:</p>\n\n<ul>\n\t<li>If <code>word1</code> is non-empty, append the <strong>first</strong> character in <code>word1</code> to <code>merge</code> and delete it from <code>word1</code>.\n\n\t<ul>\n\t\t<li>For example, if <code>word1 = &quot;abc&quot; </code>and <code>merge = &quot;dv&quot;</code>, then after choosing this operation, <code>word1 = &quot;bc&quot;</code> and <code>merge = &quot;dva&quot;</code>.</li>\n\t</ul>\n\t</li>\n\t<li>If <code>word2</code> is non-empty, append the <strong>first</strong> character in <code>word2</code> to <code>merge</code> and delete it from <code>word2</code>.\n\t<ul>\n\t\t<li>For example, if <code>word2 = &quot;abc&quot; </code>and <code>merge = &quot;&quot;</code>, then after choosing this operation, <code>word2 = &quot;bc&quot;</code> and <code>merge = &quot;a&quot;</code>.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <em>the lexicographically <strong>largest</strong> </em><code>merge</code><em> you can construct</em>.</p>\n\n<p>A string <code>a</code> is lexicographically larger than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, <code>a</code> has a character strictly larger than the corresponding character in <code>b</code>. For example, <code>&quot;abcd&quot;</code> is lexicographically larger than <code>&quot;abcc&quot;</code> because the first position they differ is at the fourth character, and <code>d</code> is greater than <code>c</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;cabaa&quot;, word2 = &quot;bcaaa&quot;\n<strong>Output:</strong> &quot;cbcabaaaaa&quot;\n<strong>Explanation:</strong> One way to get the lexicographically largest merge is:\n- Take from word1: merge = &quot;c&quot;, word1 = &quot;abaa&quot;, word2 = &quot;bcaaa&quot;\n- Take from word2: merge = &quot;cb&quot;, word1 = &quot;abaa&quot;, word2 = &quot;caaa&quot;\n- Take from word2: merge = &quot;cbc&quot;, word1 = &quot;abaa&quot;, word2 = &quot;aaa&quot;\n- Take from word1: merge = &quot;cbca&quot;, word1 = &quot;baa&quot;, word2 = &quot;aaa&quot;\n- Take from word1: merge = &quot;cbcab&quot;, word1 = &quot;aa&quot;, word2 = &quot;aaa&quot;\n- Append the remaining 5 a&#39;s from word1 and word2 at the end of merge.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;abcabc&quot;, word2 = &quot;abdcaba&quot;\n<strong>Output:</strong> &quot;abdcabcabcaba&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 3000</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist only of lowercase English letters.</li>\n</ul>\n", "hints": ["Build the result character by character. At each step, you choose a character from one of the two strings.", "If the next character of the first string is larger than that of the second string, or vice versa, it's optimal to use the larger one.", "If both are equal, think of a criteria that lets you decide which string to consume the next character from.", "You should choose the next character from the larger string."], "exampleTestcases": "\"cabaa\"\n\"bcaaa\"\n\"abcabc\"\n\"abdcaba\"", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    string largestMerge(string word1, string word2) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public String largestMerge(String word1, String word2) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def largestMerge(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: str\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def largestMerge(self, word1: str, word2: str) -> str:\n        "}, {"lang": "C", "langSlug": "c", "code": "char* largestMerge(char* word1, char* word2) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public string LargestMerge(string word1, string word2) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {string}\n */\nvar largestMerge = function(word1, word2) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function largestMerge(word1: string, word2: string): string {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $word1\n     * @param String $word2\n     * @return String\n     */\n    function largestMerge($word1, $word2) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func largestMerge(_ word1: String, _ word2: String) -> String {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun largestMerge(word1: String, word2: String): String {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  String largestMerge(String word1, String word2) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func largestMerge(word1 string, word2 string) string {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {String} word1\n# @param {String} word2\n# @return {String}\ndef largest_merge(word1, word2)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def largestMerge(word1: String, word2: String): String = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn largest_merge(word1: String, word2: String) -> String {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (largest-merge word1 word2)\n  (-> string? string? string?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec largest_merge(Word1 :: unicode:unicode_binary(), Word2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\nlargest_merge(Word1, Word2) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec largest_merge(word1 :: String.t, word2 :: String.t) :: String.t\n  def largest_merge(word1, word2) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "maximum-matching-of-players-with-trainers", "title": "Maximum Matching of Players With Trainers", "isPaidOnly": false}, {"difficulty": "Medium", "titleSlug": "decremental-string-concatenation", "title": "Decremental String Concatenation", "isPaidOnly": false}]}