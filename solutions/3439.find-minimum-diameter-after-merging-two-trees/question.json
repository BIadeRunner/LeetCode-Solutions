{"question_id": "3439", "problem_slug": "find-minimum-diameter-after-merging-two-trees", "problem_title": "Find Minimum Diameter After Merging Two Trees", "content": "There exist two undirected trees with n and m nodes, numbered from 0 to n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree.\nYou must connect one node from the first tree with another node from the second tree with an edge.\nReturn the minimum possible diameter of the resulting tree.\nThe diameter of a tree is the length of the longest path between any two nodes in the tree.\n \nExample 1:\n\nInput: edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]\nOutput: 3\nExplanation:\nWe can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.\n\nExample 2:\n\n\nInput: edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\nOutput: 5\nExplanation:\nWe can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.\n\n \nConstraints:\n\n1 <= n, m <= 105\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [ai, bi]\n0 <= ai, bi < n\nedges2[i] = [ui, vi]\n0 <= ui, vi < m\nThe input is generated such that edges1 and edges2 represent valid trees.\n\n", "hints": ["Suppose that we connected node <code>a</code> in tree1 with node <code>b</code> in tree2. The diameter length of the resulting tree will be the largest of the following 3 values: \r\n<ol>\r\n<li>The diameter of tree 1.</li>\r\n<li>The diameter of tree 2.</li>\r\n<li>The length of the longest path that starts at node <code>a</code> and that is completely within Tree 1 + The length of the longest path that starts at node <code>b</code> and that is completely within Tree 2 + 1.</li>\r\n</ol> \r\nThe added one in the third value is due to the additional edge that we have added between trees 1 and 2.", "Values 1 and 2 are constant regardless of our choice of <code>a</code> and <code>b</code>. Therefore, we need to pick <code>a</code> and <code>b</code> in such a way that minimizes value 3.", "If we pick <code>a</code> and <code>b</code> optimally, they will be in the diameters of Tree 1 and Tree 2, respectively. Exactly which nodes of the diameter should we pick?", "<code>a</code> is the center of the diameter of tree 1, and <code>b</code> is the center of the diameter of tree 2."], "exampleTestcases": "[[0,1],[0,2],[0,3]]\n[[0,1]]\n[[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]\n[[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int minimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def minimumDiameterAfterMerge(self, edges1, edges2):\n        \"\"\"\n        :type edges1: List[List[int]]\n        :type edges2: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        "}, "C": {"langSlug": "c", "code": "int minimumDiameterAfterMerge(int** edges1, int edges1Size, int* edges1ColSize, int** edges2, int edges2Size, int* edges2ColSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int MinimumDiameterAfterMerge(int[][] edges1, int[][] edges2) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} edges1\n * @param {number[][]} edges2\n * @return {number}\n */\nvar minimumDiameterAfterMerge = function(edges1, edges2) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function minimumDiameterAfterMerge(edges1: number[][], edges2: number[][]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $edges1\n     * @param Integer[][] $edges2\n     * @return Integer\n     */\n    function minimumDiameterAfterMerge($edges1, $edges2) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func minimumDiameterAfterMerge(_ edges1: [[Int]], _ edges2: [[Int]]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun minimumDiameterAfterMerge(edges1: Array<IntArray>, edges2: Array<IntArray>): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int minimumDiameterAfterMerge(List<List<int>> edges1, List<List<int>> edges2) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func minimumDiameterAfterMerge(edges1 [][]int, edges2 [][]int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[][]} edges1\n# @param {Integer[][]} edges2\n# @return {Integer}\ndef minimum_diameter_after_merge(edges1, edges2)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def minimumDiameterAfterMerge(edges1: Array[Array[Int]], edges2: Array[Array[Int]]): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn minimum_diameter_after_merge(edges1: Vec<Vec<i32>>, edges2: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (minimum-diameter-after-merge edges1 edges2)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec minimum_diameter_after_merge(Edges1 :: [[integer()]], Edges2 :: [[integer()]]) -> integer().\nminimum_diameter_after_merge(Edges1, Edges2) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec minimum_diameter_after_merge(edges1 :: [[integer]], edges2 :: [[integer]]) :: integer\n  def minimum_diameter_after_merge(edges1, edges2) do\n    \n  end\nend"}}}