{"questionId": "1778", "acRate": 39.968195070235886, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "1659", "paidOnly": false, "status": "ac", "title": "Maximize Grid Happiness", "topicTags": [{"name": "Dynamic Programming", "id": "VG9waWNUYWdOb2RlOjEz", "slug": "dynamic-programming"}, {"name": "Bit Manipulation", "id": "VG9waWNUYWdOb2RlOjE5", "slug": "bit-manipulation"}, {"name": "Memoization", "id": "VG9waWNUYWdOb2RlOjMz", "slug": "memoization"}, {"name": "Bitmask", "id": "VG9waWNUYWdOb2RlOjYxMDc4", "slug": "bitmask"}], "titleSlug": "maximize-grid-happiness", "content": "<p>You are given four integers, <code>m</code>, <code>n</code>, <code>introvertsCount</code>, and <code>extrovertsCount</code>. You have an <code>m x n</code> grid, and there are two types of people: introverts and extroverts. There are <code>introvertsCount</code> introverts and <code>extrovertsCount</code> extroverts.</p>\n\n<p>You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you <strong>do not</strong> have to have all the people living in the grid.</p>\n\n<p>The <strong>happiness</strong> of each person is calculated as follows:</p>\n\n<ul>\n\t<li>Introverts <strong>start</strong> with <code>120</code> happiness and <strong>lose</strong> <code>30</code> happiness for each neighbor (introvert or extrovert).</li>\n\t<li>Extroverts <strong>start</strong> with <code>40</code> happiness and <strong>gain</strong> <code>20</code> happiness for each neighbor (introvert or extrovert).</li>\n</ul>\n\n<p>Neighbors live in the directly adjacent cells north, east, south, and west of a person&#39;s cell.</p>\n\n<p>The <strong>grid happiness</strong> is the <strong>sum</strong> of each person&#39;s happiness. Return<em> the <strong>maximum possible grid happiness</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/grid_happiness.png\" style=\"width: 261px; height: 121px;\" />\n<pre>\n<strong>Input:</strong> m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n<strong>Output:</strong> 240\n<strong>Explanation:</strong> Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person&#39;s happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n<strong>Output:</strong> 260\n<strong>Explanation:</strong> Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n<strong>Output:</strong> 240\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 5</code></li>\n\t<li><code>0 &lt;= introvertsCount, extrovertsCount &lt;= min(m * n, 6)</code></li>\n</ul>\n", "hints": ["For each cell, it has 3 options, either it is empty, or contains an introvert, or an extrovert.", "You can do DP where you maintain the state of the previous row, the number of remaining introverts and extroverts, the current row and column, and try the 3 options for each cell.", "Assume that the previous columns in the current row already belong to the previous row."], "exampleTestcases": "2\n3\n1\n2\n3\n1\n2\n1\n2\n2\n4\n0", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type introvertsCount: int\n        :type extrovertsCount: int\n        :rtype: int\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:\n        "}, {"lang": "C", "langSlug": "c", "code": "int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public int GetMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number} m\n * @param {number} n\n * @param {number} introvertsCount\n * @param {number} extrovertsCount\n * @return {number}\n */\nvar getMaxGridHappiness = function(m, n, introvertsCount, extrovertsCount) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function getMaxGridHappiness(m: number, n: number, introvertsCount: number, extrovertsCount: number): number {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer $introvertsCount\n     * @param Integer $extrovertsCount\n     * @return Integer\n     */\n    function getMaxGridHappiness($m, $n, $introvertsCount, $extrovertsCount) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func getMaxGridHappiness(_ m: Int, _ n: Int, _ introvertsCount: Int, _ extrovertsCount: Int) -> Int {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun getMaxGridHappiness(m: Int, n: Int, introvertsCount: Int, extrovertsCount: Int): Int {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func getMaxGridHappiness(m int, n int, introvertsCount int, extrovertsCount int) int {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer} m\n# @param {Integer} n\n# @param {Integer} introverts_count\n# @param {Integer} extroverts_count\n# @return {Integer}\ndef get_max_grid_happiness(m, n, introverts_count, extroverts_count)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def getMaxGridHappiness(m: Int, n: Int, introvertsCount: Int, extrovertsCount: Int): Int = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn get_max_grid_happiness(m: i32, n: i32, introverts_count: i32, extroverts_count: i32) -> i32 {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (get-max-grid-happiness m n introvertsCount extrovertsCount)\n  (-> exact-integer? exact-integer? exact-integer? exact-integer? exact-integer?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec get_max_grid_happiness(M :: integer(), N :: integer(), IntrovertsCount :: integer(), ExtrovertsCount :: integer()) -> integer().\nget_max_grid_happiness(M, N, IntrovertsCount, ExtrovertsCount) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec get_max_grid_happiness(m :: integer, n :: integer, introverts_count :: integer, extroverts_count :: integer) :: integer\n  def get_max_grid_happiness(m, n, introverts_count, extroverts_count) do\n    \n  end\nend"}], "similarQuestionList": []}