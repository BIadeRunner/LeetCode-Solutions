{"questionId": "2259", "acRate": 40.16771488469602, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "2123", "paidOnly": true, "status": "ac", "title": "Minimum Operations to Remove Adjacent Ones in Matrix", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Graph", "id": "VG9waWNUYWdOb2RlOjI0", "slug": "graph"}, {"name": "Matrix", "id": "VG9waWNUYWdOb2RlOjYxMDUz", "slug": "matrix"}], "titleSlug": "minimum-operations-to-remove-adjacent-ones-in-matrix", "content": "<p>You are given a <strong>0-indexed</strong> binary matrix <code>grid</code>. In one operation, you can flip any <code>1</code> in <code>grid</code> to be <code>0</code>.</p>\n\n<p>A binary matrix is <strong>well-isolated</strong> if there is no <code>1</code> in the matrix that is <strong>4-directionally connected</strong> (i.e., horizontal and vertical) to another <code>1</code>.</p>\n\n<p>Return <em>the minimum number of operations to make </em><code>grid</code><em> <strong>well-isolated</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2021/12/23/image-20211223181501-1.png\" style=\"width: 644px; height: 250px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,1,0],[0,1,1],[1,1,1]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Use 3 operations to change grid[0][1], grid[1][2], and grid[2][1] to 0.\nAfter, no more 1&#39;s are 4-directionally connected and grid is well-isolated.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2021/12/23/image-20211223181518-2.png\" style=\"height: 250px; width: 255px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,0],[0,0,0],[0,0,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no 1&#39;s in grid and it is well-isolated.\nNo operations were done so return 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2021/12/23/image-20211223181817-3.png\" style=\"width: 165px; height: 167px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1],[1,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> None of the 1&#39;s are 4-directionally connected and grid is well-isolated.\nNo operations were done so return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n", "hints": ["Consider each cell containing a 1 as a vertex whose neighbors are the cells 4-directionally connected to it. The grid then becomes a bipartite graph.", "You want to find the smallest set of vertices such that every edge in the graph has an endpoint in this set. If you remove every vertex in this set from the graph, then all the 1\u2019s will be disconnected. Are there any well-known algorithms for finding this set?", "This set of vertices is called a minimum vertex cover. You can find the size of a minimum vertex cover by finding the size of a maximum matching (Konig\u2019s theorem).", "There are well-known algorithms such as Kuhn\u2019s algorithm and Hopcroft-Karp-Karzanov algorithm which can find a maximum matching in a bipartite graph quickly."], "exampleTestcases": "[[1,1,0],[0,1,1],[1,1,1]]\n[[0,0,0],[0,0,0],[0,0,0]]\n[[0,1],[1,0]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    int minimumOperations(vector<vector<int>>& grid) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public int minimumOperations(int[][] grid) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def minimumOperations(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n        "}, {"lang": "C", "langSlug": "c", "code": "int minimumOperations(int** grid, int gridSize, int* gridColSize) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public int MinimumOperations(int[][] grid) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumOperations = function(grid) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function minimumOperations(grid: number[][]): number {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function minimumOperations($grid) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func minimumOperations(_ grid: [[Int]]) -> Int {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun minimumOperations(grid: Array<IntArray>): Int {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  int minimumOperations(List<List<int>> grid) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func minimumOperations(grid [][]int) int {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef minimum_operations(grid)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def minimumOperations(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn minimum_operations(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (minimum-operations grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec minimum_operations(Grid :: [[integer()]]) -> integer().\nminimum_operations(Grid) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec minimum_operations(grid :: [[integer]]) :: integer\n  def minimum_operations(grid) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "set-matrix-zeroes", "title": "Set Matrix Zeroes", "isPaidOnly": false}, {"difficulty": "Medium", "titleSlug": "01-matrix", "title": "01 Matrix", "isPaidOnly": false}, {"difficulty": "Hard", "titleSlug": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix", "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "isPaidOnly": false}, {"difficulty": "Medium", "titleSlug": "remove-all-ones-with-row-and-column-flips", "title": "Remove All Ones With Row and Column Flips", "isPaidOnly": true}]}