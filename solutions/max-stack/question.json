{"questionId": "716", "acRate": 45.09567700747159, "difficulty": "Hard", "freqBar": 80.83518384133468, "frontendQuestionId": "716", "paidOnly": true, "status": "ac", "title": "Max Stack", "topicTags": [{"name": "Linked List", "id": "VG9waWNUYWdOb2RlOjc=", "slug": "linked-list"}, {"name": "Stack", "id": "VG9waWNUYWdOb2RlOjE1", "slug": "stack"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}, {"name": "Doubly-Linked List", "id": "VG9waWNUYWdOb2RlOjYxMDU4", "slug": "doubly-linked-list"}, {"name": "Ordered Set", "id": "VG9waWNUYWdOb2RlOjYxMDcw", "slug": "ordered-set"}], "titleSlug": "max-stack", "content": "<p>Design a max stack data structure that supports the stack operations and supports finding the stack&#39;s maximum element.</p>\n\n<p>Implement the <code>MaxStack</code> class:</p>\n\n<ul>\n\t<li><code>MaxStack()</code> Initializes the stack object.</li>\n\t<li><code>void push(int x)</code> Pushes element <code>x</code> onto the stack.</li>\n\t<li><code>int pop()</code> Removes the element on top of the stack and returns it.</li>\n\t<li><code>int top()</code> Gets the element on the top of the stack without removing it.</li>\n\t<li><code>int peekMax()</code> Retrieves the maximum element in the stack without removing it.</li>\n\t<li><code>int popMax()</code> Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the <strong>top-most</strong> one.</li>\n</ul>\n\n<p>You must come up with a solution that supports <code>O(1)</code> for each <code>top</code> call and <code>O(logn)</code> for each other call.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MaxStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;popMax&quot;, &quot;top&quot;, &quot;peekMax&quot;, &quot;pop&quot;, &quot;top&quot;]\n[[], [5], [1], [5], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, null, null, null, 5, 5, 1, 5, 1, 5]\n\n<strong>Explanation</strong>\nMaxStack stk = new MaxStack();\nstk.push(5);   // [<strong><u>5</u></strong>] the top of the stack and the maximum number is 5.\nstk.push(1);   // [<u>5</u>, <strong>1</strong>] the top of the stack is 1, but the maximum is 5.\nstk.push(5);   // [5, 1, <strong><u>5</u></strong>] the top of the stack is 5, which is also the maximum, because it is the top most one.\nstk.top();     // return 5, [5, 1, <strong><u>5</u></strong>] the stack did not change.\nstk.popMax();  // return 5, [<u>5</u>, <strong>1</strong>] the stack is changed now, and the top is different from the max.\nstk.top();     // return 1, [<u>5</u>, <strong>1</strong>] the stack did not change.\nstk.peekMax(); // return 5, [<u>5</u>, <strong>1</strong>] the stack did not change.\nstk.pop();     // return 1, [<strong><u>5</u></strong>] the top of the stack and the max element is now 5.\nstk.top();     // return 5, [<strong><u>5</u></strong>] the stack did not change.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>7</sup> &lt;= x &lt;= 10<sup>7</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code>&nbsp;calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, <code>peekMax</code>, and <code>popMax</code>.</li>\n\t<li>There will be <strong>at least one element</strong> in the stack when <code>pop</code>, <code>top</code>, <code>peekMax</code>, or <code>popMax</code> is called.</li>\n</ul>\n", "hints": [], "exampleTestcases": "[\"MaxStack\",\"push\",\"push\",\"push\",\"top\",\"popMax\",\"top\",\"peekMax\",\"pop\",\"top\"]\n[[],[5],[1],[5],[],[],[],[],[],[]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class MaxStack {\npublic:\n    MaxStack() {\n        \n    }\n    \n    void push(int x) {\n        \n    }\n    \n    int pop() {\n        \n    }\n    \n    int top() {\n        \n    }\n    \n    int peekMax() {\n        \n    }\n    \n    int popMax() {\n        \n    }\n};\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack* obj = new MaxStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->peekMax();\n * int param_5 = obj->popMax();\n */"}, {"lang": "Java", "langSlug": "java", "code": "class MaxStack {\n\n    public MaxStack() {\n        \n    }\n    \n    public void push(int x) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int top() {\n        \n    }\n    \n    public int peekMax() {\n        \n    }\n    \n    public int popMax() {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = new MaxStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.peekMax();\n * int param_5 = obj.popMax();\n */"}, {"lang": "Python", "langSlug": "python", "code": "class MaxStack(object):\n\n    def __init__(self):\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def top(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def peekMax(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def popMax(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your MaxStack object will be instantiated and called as such:\n# obj = MaxStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.peekMax()\n# param_5 = obj.popMax()"}, {"lang": "Python3", "langSlug": "python3", "code": "class MaxStack:\n\n    def __init__(self):\n        \n\n    def push(self, x: int) -> None:\n        \n\n    def pop(self) -> int:\n        \n\n    def top(self) -> int:\n        \n\n    def peekMax(self) -> int:\n        \n\n    def popMax(self) -> int:\n        \n\n\n# Your MaxStack object will be instantiated and called as such:\n# obj = MaxStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.peekMax()\n# param_5 = obj.popMax()"}, {"lang": "C", "langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} MaxStack;\n\n\nMaxStack* maxStackCreate() {\n    \n}\n\nvoid maxStackPush(MaxStack* obj, int x) {\n    \n}\n\nint maxStackPop(MaxStack* obj) {\n    \n}\n\nint maxStackTop(MaxStack* obj) {\n    \n}\n\nint maxStackPeekMax(MaxStack* obj) {\n    \n}\n\nint maxStackPopMax(MaxStack* obj) {\n    \n}\n\nvoid maxStackFree(MaxStack* obj) {\n    \n}\n\n/**\n * Your MaxStack struct will be instantiated and called as such:\n * MaxStack* obj = maxStackCreate();\n * maxStackPush(obj, x);\n \n * int param_2 = maxStackPop(obj);\n \n * int param_3 = maxStackTop(obj);\n \n * int param_4 = maxStackPeekMax(obj);\n \n * int param_5 = maxStackPopMax(obj);\n \n * maxStackFree(obj);\n*/"}, {"lang": "C#", "langSlug": "csharp", "code": "public class MaxStack {\n\n    public MaxStack() {\n        \n    }\n    \n    public void Push(int x) {\n        \n    }\n    \n    public int Pop() {\n        \n    }\n    \n    public int Top() {\n        \n    }\n    \n    public int PeekMax() {\n        \n    }\n    \n    public int PopMax() {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = new MaxStack();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Top();\n * int param_4 = obj.PeekMax();\n * int param_5 = obj.PopMax();\n */"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "\nvar MaxStack = function() {\n    \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMaxStack.prototype.push = function(x) {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.pop = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.top = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.peekMax = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.popMax = function() {\n    \n};\n\n/** \n * Your MaxStack object will be instantiated and called as such:\n * var obj = new MaxStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.peekMax()\n * var param_5 = obj.popMax()\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "class MaxStack {\n    constructor() {\n        \n    }\n\n    push(x: number): void {\n        \n    }\n\n    pop(): number {\n        \n    }\n\n    top(): number {\n        \n    }\n\n    peekMax(): number {\n        \n    }\n\n    popMax(): number {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * var obj = new MaxStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.peekMax()\n * var param_5 = obj.popMax()\n */"}, {"lang": "PHP", "langSlug": "php", "code": "class MaxStack {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function top() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function peekMax() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function popMax() {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * $obj = MaxStack();\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->top();\n * $ret_4 = $obj->peekMax();\n * $ret_5 = $obj->popMax();\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "\nclass MaxStack {\n\n    init() {\n        \n    }\n    \n    func push(_ x: Int) {\n        \n    }\n    \n    func pop() -> Int {\n        \n    }\n    \n    func top() -> Int {\n        \n    }\n    \n    func peekMax() -> Int {\n        \n    }\n    \n    func popMax() -> Int {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * let obj = MaxStack()\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.top()\n * let ret_4: Int = obj.peekMax()\n * let ret_5: Int = obj.popMax()\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class MaxStack() {\n\n    fun push(x: Int) {\n        \n    }\n\n    fun pop(): Int {\n        \n    }\n\n    fun top(): Int {\n        \n    }\n\n    fun peekMax(): Int {\n        \n    }\n\n    fun popMax(): Int {\n        \n    }\n\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * var obj = MaxStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.peekMax()\n * var param_5 = obj.popMax()\n */"}, {"lang": "Dart", "langSlug": "dart", "code": "class MaxStack {\n\n  MaxStack() {\n    \n  }\n  \n  void push(int x) {\n    \n  }\n  \n  int pop() {\n    \n  }\n  \n  int top() {\n    \n  }\n  \n  int peekMax() {\n    \n  }\n  \n  int popMax() {\n    \n  }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = MaxStack();\n * obj.push(x);\n * int param2 = obj.pop();\n * int param3 = obj.top();\n * int param4 = obj.peekMax();\n * int param5 = obj.popMax();\n */"}, {"lang": "Go", "langSlug": "golang", "code": "type MaxStack struct {\n    \n}\n\n\nfunc Constructor() MaxStack {\n    \n}\n\n\nfunc (this *MaxStack) Push(x int)  {\n    \n}\n\n\nfunc (this *MaxStack) Pop() int {\n    \n}\n\n\nfunc (this *MaxStack) Top() int {\n    \n}\n\n\nfunc (this *MaxStack) PeekMax() int {\n    \n}\n\n\nfunc (this *MaxStack) PopMax() int {\n    \n}\n\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.PeekMax();\n * param_5 := obj.PopMax();\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "class MaxStack\n    def initialize()\n        \n    end\n\n\n=begin\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def top()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def peek_max()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop_max()\n        \n    end\n\n\nend\n\n# Your MaxStack object will be instantiated and called as such:\n# obj = MaxStack.new()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.peek_max()\n# param_5 = obj.pop_max()"}, {"lang": "Scala", "langSlug": "scala", "code": "class MaxStack() {\n\n    def push(x: Int): Unit = {\n        \n    }\n\n    def pop(): Int = {\n        \n    }\n\n    def top(): Int = {\n        \n    }\n\n    def peekMax(): Int = {\n        \n    }\n\n    def popMax(): Int = {\n        \n    }\n\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * val obj = new MaxStack()\n * obj.push(x)\n * val param_2 = obj.pop()\n * val param_3 = obj.top()\n * val param_4 = obj.peekMax()\n * val param_5 = obj.popMax()\n */"}, {"lang": "Rust", "langSlug": "rust", "code": "struct MaxStack {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MaxStack {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn push(&self, x: i32) {\n        \n    }\n    \n    fn pop(&self) -> i32 {\n        \n    }\n    \n    fn top(&self) -> i32 {\n        \n    }\n    \n    fn peek_max(&self) -> i32 {\n        \n    }\n    \n    fn pop_max(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * let obj = MaxStack::new();\n * obj.push(x);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.top();\n * let ret_4: i32 = obj.peek_max();\n * let ret_5: i32 = obj.pop_max();\n */"}, {"lang": "Racket", "langSlug": "racket", "code": "(define max-stack%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push x)\n      )\n    ; pop : -> exact-integer?\n    (define/public (pop)\n      )\n    ; top : -> exact-integer?\n    (define/public (top)\n      )\n    ; peek-max : -> exact-integer?\n    (define/public (peek-max)\n      )\n    ; pop-max : -> exact-integer?\n    (define/public (pop-max)\n      )))\n\n;; Your max-stack% object will be instantiated and called as such:\n;; (define obj (new max-stack%))\n;; (send obj push x)\n;; (define param_2 (send obj pop))\n;; (define param_3 (send obj top))\n;; (define param_4 (send obj peek-max))\n;; (define param_5 (send obj pop-max))"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec max_stack_init_() -> any().\nmax_stack_init_() ->\n  .\n\n-spec max_stack_push(X :: integer()) -> any().\nmax_stack_push(X) ->\n  .\n\n-spec max_stack_pop() -> integer().\nmax_stack_pop() ->\n  .\n\n-spec max_stack_top() -> integer().\nmax_stack_top() ->\n  .\n\n-spec max_stack_peek_max() -> integer().\nmax_stack_peek_max() ->\n  .\n\n-spec max_stack_pop_max() -> integer().\nmax_stack_pop_max() ->\n  .\n\n\n%% Your functions will be called as such:\n%% max_stack_init_(),\n%% max_stack_push(X),\n%% Param_2 = max_stack_pop(),\n%% Param_3 = max_stack_top(),\n%% Param_4 = max_stack_peek_max(),\n%% Param_5 = max_stack_pop_max(),\n\n%% max_stack_init_ will be called before every test case, in which you can do some necessary initializations."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule MaxStack do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec push(x :: integer) :: any\n  def push(x) do\n    \n  end\n\n  @spec pop() :: integer\n  def pop() do\n    \n  end\n\n  @spec top() :: integer\n  def top() do\n    \n  end\n\n  @spec peek_max() :: integer\n  def peek_max() do\n    \n  end\n\n  @spec pop_max() :: integer\n  def pop_max() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MaxStack.init_()\n# MaxStack.push(x)\n# param_2 = MaxStack.pop()\n# param_3 = MaxStack.top()\n# param_4 = MaxStack.peek_max()\n# param_5 = MaxStack.pop_max()\n\n# MaxStack.init_ will be called before every test case, in which you can do some necessary initializations."}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "min-stack", "title": "Min Stack", "isPaidOnly": false}]}