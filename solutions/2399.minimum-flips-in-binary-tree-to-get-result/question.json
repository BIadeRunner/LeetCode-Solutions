{"question_id": "2399", "problem_slug": "minimum-flips-in-binary-tree-to-get-result", "problem_title": "Minimum Flips in Binary Tree to Get Result", "content": "You are given the root of a binary tree with the following properties:\n\nLeaf nodes have either the value 0 or 1, representing false and true respectively.\nNon-leaf nodes have either the value 2, 3, 4, or 5, representing the boolean operations OR, AND, XOR, and NOT, respectively.\n\nYou are also given a boolean result, which is the desired result of the evaluation of the root node.\nThe evaluation of a node is as follows:\n\nIf the node is a leaf node, the evaluation is the value of the node, i.e. true or false.\nOtherwise, evaluate the node's children and apply the boolean operation of its value with the children's evaluations.\n\nIn one operation, you can flip a leaf node, which causes a false node to become true, and a true node to become false.\nReturn the minimum number of operations that need to be performed such that the evaluation of root yields result. It can be shown that there is always a way to achieve result.\nA leaf node is a node that has zero children.\nNote: NOT nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child.\n \nExample 1:\n\n\nInput: root = [3,5,4,2,null,1,1,1,0], result = true\nOutput: 2\nExplanation:\nIt can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree\nevaluate to true. One way to achieve this is shown in the diagram above.\n\nExample 2:\n\nInput: root = [0], result = false\nOutput: 0\nExplanation:\nThe root of the tree already evaluates to false, so 0 nodes have to be flipped.\n\n \nConstraints:\n\nThe number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 5\nOR, AND, and XOR nodes have 2 children.\nNOT nodes have 1 child.\nLeaf nodes have a value of 0 or 1.\nNon-leaf nodes have a value of 2, 3, 4, or 5.\n\n", "hints": ["Try using tree DP to solve this problem.", "Find the minimum operations to change each subtree to true and to false separately.", "For nodes representing boolean operations, find the minimum operations by trying all combinations of values to which the child nodes can evaluate."], "exampleTestcases": "[3,5,4,2,null,1,1,1,0]\ntrue\n[0]\nfalse", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minimumFlips(TreeNode* root, bool result) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minimumFlips(TreeNode root, boolean result) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minimumFlips(self, root, result):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type result: bool\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint minimumFlips(struct TreeNode* root, bool result) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MinimumFlips(TreeNode root, bool result) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {boolean} result\n * @return {number}\n */\nvar minimumFlips = function(root, result) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction minimumFlips(root: TreeNode | null, result: boolean): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Boolean $result\n     * @return Integer\n     */\n    function minimumFlips($root, $result) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func minimumFlips(_ root: TreeNode?, _ result: Bool) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun minimumFlips(root: TreeNode?, result: Boolean): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int minimumFlips(TreeNode? root, bool result) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc minimumFlips(root *TreeNode, result bool) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Boolean} result\n# @return {Integer}\ndef minimum_flips(root, result)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def minimumFlips(root: TreeNode, result: Boolean): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn minimum_flips(root: Option<Rc<RefCell<TreeNode>>>, result: bool) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (minimum-flips root result)\n  (-> (or/c tree-node? #f) boolean? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec minimum_flips(Root :: #tree_node{} | null, Result :: boolean()) -> integer().\nminimum_flips(Root, Result) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec minimum_flips(root :: TreeNode.t | nil, result :: boolean) :: integer\n  def minimum_flips(root, result) do\n    \n  end\nend"}}}