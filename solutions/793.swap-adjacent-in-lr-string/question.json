{"question_id": "793", "problem_slug": "swap-adjacent-in-lr-string", "problem_title": "Swap Adjacent in LR String", "content": "In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform start to end.\n \nExample 1:\n\nInput: start = \"RXXLRXRXL\", end = \"XRLXXRRLX\"\nOutput: true\nExplanation: We can transform start to end following these steps:\nRXXLRXRXL ->\nXRXLRXRXL ->\nXRLXRXRXL ->\nXRLXXRRXL ->\nXRLXXRRLX\n\nExample 2:\n\nInput: start = \"X\", end = \"L\"\nOutput: false\n\n \nConstraints:\n\n1 <= start.length <= 104\nstart.length == end.length\nBoth start and end will only consist of characters in 'L', 'R', and 'X'.\n\n", "hints": ["Think of the L and R's as people on a horizontal line, where X is a space.  The people can't cross each other, and also you can't go from XRX to RXX."], "exampleTestcases": "\"RXXLRXRXL\"\n\"XRLXXRRLX\"\n\"X\"\n\"L\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool canTransform(string start, string end) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean canTransform(String start, String end) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def canTransform(self, start, end):\n        \"\"\"\n        :type start: str\n        :type end: str\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def canTransform(self, start: str, end: str) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool canTransform(char* start, char* end) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool CanTransform(string start, string end) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} start\n * @param {string} end\n * @return {boolean}\n */\nvar canTransform = function(start, end) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function canTransform(start: string, end: string): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $start\n     * @param String $end\n     * @return Boolean\n     */\n    function canTransform($start, $end) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func canTransform(_ start: String, _ end: String) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun canTransform(start: String, end: String): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool canTransform(String start, String end) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func canTransform(start string, end string) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} start\n# @param {String} end\n# @return {Boolean}\ndef can_transform(start, end)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def canTransform(start: String, end: String): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn can_transform(start: String, end: String) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (can-transform start end)\n  (-> string? string? boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec can_transform(Start :: unicode:unicode_binary(), End :: unicode:unicode_binary()) -> boolean().\ncan_transform(Start, End) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec can_transform(start :: String.t, end :: String.t) :: boolean\n  def can_transform(start, end) do\n    \n  end\nend"}}}