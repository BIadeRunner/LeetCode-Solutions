{"question_id": "816", "problem_slug": "design-hashset", "problem_title": "Design HashSet", "content": "Design a HashSet without using any built-in hash table libraries.\nImplement MyHashSet class:\n\nvoid add(key) Inserts the value key into the HashSet.\nbool contains(key) Returns whether the value key exists in the HashSet or not.\nvoid remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.\n\n \nExample 1:\n\nInput\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\nOutput\n[null, null, null, true, false, null, true, null, false]\n\nExplanation\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)\n \nConstraints:\n\n0 <= key <= 106\nAt most 104 calls will be made to add, remove, and contains.\n\n", "hints": [], "exampleTestcases": "[\"MyHashSet\",\"add\",\"add\",\"contains\",\"contains\",\"add\",\"contains\",\"remove\",\"contains\"]\n[[],[1],[2],[1],[3],[2],[2],[2],[2]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class MyHashSet {\npublic:\n    MyHashSet() {\n        \n    }\n    \n    void add(int key) {\n        \n    }\n    \n    void remove(int key) {\n        \n    }\n    \n    bool contains(int key) {\n        \n    }\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet* obj = new MyHashSet();\n * obj->add(key);\n * obj->remove(key);\n * bool param_3 = obj->contains(key);\n */"}, "Java": {"langSlug": "java", "code": "class MyHashSet {\n\n    public MyHashSet() {\n        \n    }\n    \n    public void add(int key) {\n        \n    }\n    \n    public void remove(int key) {\n        \n    }\n    \n    public boolean contains(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * boolean param_3 = obj.contains(key);\n */"}, "Python": {"langSlug": "python", "code": "class MyHashSet(object):\n\n    def __init__(self):\n        \n\n    def add(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: None\n        \"\"\"\n        \n\n    def remove(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: None\n        \"\"\"\n        \n\n    def contains(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)"}, "Python3": {"langSlug": "python3", "code": "class MyHashSet:\n\n    def __init__(self):\n        \n\n    def add(self, key: int) -> None:\n        \n\n    def remove(self, key: int) -> None:\n        \n\n    def contains(self, key: int) -> bool:\n        \n\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} MyHashSet;\n\n\nMyHashSet* myHashSetCreate() {\n    \n}\n\nvoid myHashSetAdd(MyHashSet* obj, int key) {\n    \n}\n\nvoid myHashSetRemove(MyHashSet* obj, int key) {\n    \n}\n\nbool myHashSetContains(MyHashSet* obj, int key) {\n    \n}\n\nvoid myHashSetFree(MyHashSet* obj) {\n    \n}\n\n/**\n * Your MyHashSet struct will be instantiated and called as such:\n * MyHashSet* obj = myHashSetCreate();\n * myHashSetAdd(obj, key);\n \n * myHashSetRemove(obj, key);\n \n * bool param_3 = myHashSetContains(obj, key);\n \n * myHashSetFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class MyHashSet {\n\n    public MyHashSet() {\n        \n    }\n    \n    public void Add(int key) {\n        \n    }\n    \n    public void Remove(int key) {\n        \n    }\n    \n    public bool Contains(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.Add(key);\n * obj.Remove(key);\n * bool param_3 = obj.Contains(key);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "\nvar MyHashSet = function() {\n    \n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.add = function(key) {\n    \n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.remove = function(key) {\n    \n};\n\n/** \n * @param {number} key\n * @return {boolean}\n */\nMyHashSet.prototype.contains = function(key) {\n    \n};\n\n/** \n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class MyHashSet {\n    constructor() {\n        \n    }\n\n    add(key: number): void {\n        \n    }\n\n    remove(key: number): void {\n        \n    }\n\n    contains(key: number): boolean {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */"}, "PHP": {"langSlug": "php", "code": "class MyHashSet {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function add($key) {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function remove($key) {\n        \n    }\n  \n    /**\n     * @param Integer $key\n     * @return Boolean\n     */\n    function contains($key) {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * $obj = MyHashSet();\n * $obj->add($key);\n * $obj->remove($key);\n * $ret_3 = $obj->contains($key);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass MyHashSet {\n\n    init() {\n        \n    }\n    \n    func add(_ key: Int) {\n        \n    }\n    \n    func remove(_ key: Int) {\n        \n    }\n    \n    func contains(_ key: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * let obj = MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * let ret_3: Bool = obj.contains(key)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class MyHashSet() {\n\n    fun add(key: Int) {\n        \n    }\n\n    fun remove(key: Int) {\n        \n    }\n\n    fun contains(key: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */"}, "Dart": {"langSlug": "dart", "code": "class MyHashSet {\n\n  MyHashSet() {\n    \n  }\n  \n  void add(int key) {\n    \n  }\n  \n  void remove(int key) {\n    \n  }\n  \n  bool contains(int key) {\n    \n  }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * bool param3 = obj.contains(key);\n */"}, "Go": {"langSlug": "golang", "code": "type MyHashSet struct {\n    \n}\n\n\nfunc Constructor() MyHashSet {\n    \n}\n\n\nfunc (this *MyHashSet) Add(key int)  {\n    \n}\n\n\nfunc (this *MyHashSet) Remove(key int)  {\n    \n}\n\n\nfunc (this *MyHashSet) Contains(key int) bool {\n    \n}\n\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(key);\n * obj.Remove(key);\n * param_3 := obj.Contains(key);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class MyHashSet\n    def initialize()\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Void\n=end\n    def add(key)\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Void\n=end\n    def remove(key)\n        \n    end\n\n\n=begin\n    :type key: Integer\n    :rtype: Boolean\n=end\n    def contains(key)\n        \n    end\n\n\nend\n\n# Your MyHashSet object will be instantiated and called as such:\n# obj = MyHashSet.new()\n# obj.add(key)\n# obj.remove(key)\n# param_3 = obj.contains(key)"}, "Scala": {"langSlug": "scala", "code": "class MyHashSet() {\n\n    def add(key: Int): Unit = {\n        \n    }\n\n    def remove(key: Int): Unit = {\n        \n    }\n\n    def contains(key: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * val obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * val param_3 = obj.contains(key)\n */"}, "Rust": {"langSlug": "rust", "code": "struct MyHashSet {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyHashSet {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, key: i32) {\n        \n    }\n    \n    fn remove(&self, key: i32) {\n        \n    }\n    \n    fn contains(&self, key: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * let obj = MyHashSet::new();\n * obj.add(key);\n * obj.remove(key);\n * let ret_3: bool = obj.contains(key);\n */"}, "Racket": {"langSlug": "racket", "code": "(define my-hash-set%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add key)\n      )\n    ; remove : exact-integer? -> void?\n    (define/public (remove key)\n      )\n    ; contains : exact-integer? -> boolean?\n    (define/public (contains key)\n      )))\n\n;; Your my-hash-set% object will be instantiated and called as such:\n;; (define obj (new my-hash-set%))\n;; (send obj add key)\n;; (send obj remove key)\n;; (define param_3 (send obj contains key))"}, "Erlang": {"langSlug": "erlang", "code": "-spec my_hash_set_init_() -> any().\nmy_hash_set_init_() ->\n  .\n\n-spec my_hash_set_add(Key :: integer()) -> any().\nmy_hash_set_add(Key) ->\n  .\n\n-spec my_hash_set_remove(Key :: integer()) -> any().\nmy_hash_set_remove(Key) ->\n  .\n\n-spec my_hash_set_contains(Key :: integer()) -> boolean().\nmy_hash_set_contains(Key) ->\n  .\n\n\n%% Your functions will be called as such:\n%% my_hash_set_init_(),\n%% my_hash_set_add(Key),\n%% my_hash_set_remove(Key),\n%% Param_3 = my_hash_set_contains(Key),\n\n%% my_hash_set_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule MyHashSet do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(key :: integer) :: any\n  def add(key) do\n    \n  end\n\n  @spec remove(key :: integer) :: any\n  def remove(key) do\n    \n  end\n\n  @spec contains(key :: integer) :: boolean\n  def contains(key) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MyHashSet.init_()\n# MyHashSet.add(key)\n# MyHashSet.remove(key)\n# param_3 = MyHashSet.contains(key)\n\n# MyHashSet.init_ will be called before every test case, in which you can do some necessary initializations."}}}