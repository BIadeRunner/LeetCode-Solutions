{"question_id": "1729", "problem_slug": "binary-search-tree-iterator-ii", "problem_title": "Binary Search Tree Iterator II", "content": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\nboolean hasPrev() Returns true if there exists a number in the traversal to the left of the pointer, otherwise returns false.\nint prev() Moves the pointer to the left, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() and prev() calls will always be valid. That is, there will be at least a next/previous number in the in-order traversal when next()/prev() is called.\n \nExample 1:\n\n\nInput\n[\"BSTIterator\", \"next\", \"next\", \"prev\", \"next\", \"hasNext\", \"next\", \"next\", \"next\", \"hasNext\", \"hasPrev\", \"prev\", \"prev\"]\n[[[7, 3, 15, null, null, 9, 20]], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null], [null]]\nOutput\n[null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9]\n\nExplanation\n// The underlined element is where the pointer currently is.\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); // state is   [3, 7, 9, 15, 20]\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 3\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7\nbSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 3\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 7\nbSTIterator.hasNext(); // return true\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 9\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 15\nbSTIterator.next(); // state becomes [3, 7, 9, 15, 20], return 20\nbSTIterator.hasNext(); // return false\nbSTIterator.hasPrev(); // return true\nbSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 15\nbSTIterator.prev(); // state becomes [3, 7, 9, 15, 20], return 9\n\n \nConstraints:\n\nThe number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, next, hasPrev, and prev.\n\n \nFollow up: Could you solve the problem without precalculating the values of the tree?", "hints": ["The inorder traversal of a BST gives us the elements in a sorted order.", "We can use a stack to simulate the inorder traversal of the BST.", "We can use another stack as a buffer to store numbers returned from calls to next and use this buffer whenever prev is called."], "exampleTestcases": "[\"BSTIterator\",\"next\",\"next\",\"prev\",\"next\",\"hasNext\",\"next\",\"next\",\"next\",\"hasNext\",\"hasPrev\",\"prev\",\"prev\"]\n[[[7,3,15,null,null,9,20]],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null],[null]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass BSTIterator {\npublic:\n    BSTIterator(TreeNode* root) {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n    \n    int next() {\n        \n    }\n    \n    bool hasPrev() {\n        \n    }\n    \n    int prev() {\n        \n    }\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator* obj = new BSTIterator(root);\n * bool param_1 = obj->hasNext();\n * int param_2 = obj->next();\n * bool param_3 = obj->hasPrev();\n * int param_4 = obj->prev();\n */"}, "Java": {"langSlug": "java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n\n    public BSTIterator(TreeNode root) {\n        \n    }\n    \n    public boolean hasNext() {\n        \n    }\n    \n    public int next() {\n        \n    }\n    \n    public boolean hasPrev() {\n        \n    }\n    \n    public int prev() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * boolean param_1 = obj.hasNext();\n * int param_2 = obj.next();\n * boolean param_3 = obj.hasPrev();\n * int param_4 = obj.prev();\n */"}, "Python": {"langSlug": "python", "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator(object):\n\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasPrev(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n    def prev(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.hasNext()\n# param_2 = obj.next()\n# param_3 = obj.hasPrev()\n# param_4 = obj.prev()"}, "Python3": {"langSlug": "python3", "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        \n\n    def hasNext(self) -> bool:\n        \n\n    def next(self) -> int:\n        \n\n    def hasPrev(self) -> bool:\n        \n\n    def prev(self) -> int:\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.hasNext()\n# param_2 = obj.next()\n# param_3 = obj.hasPrev()\n# param_4 = obj.prev()"}, "C": {"langSlug": "c", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\n\ntypedef struct {\n    \n} BSTIterator;\n\n\nBSTIterator* bSTIteratorCreate(struct TreeNode* root) {\n    \n}\n\nbool bSTIteratorHasNext(BSTIterator* obj) {\n    \n}\n\nint bSTIteratorNext(BSTIterator* obj) {\n    \n}\n\nbool bSTIteratorHasPrev(BSTIterator* obj) {\n    \n}\n\nint bSTIteratorPrev(BSTIterator* obj) {\n    \n}\n\nvoid bSTIteratorFree(BSTIterator* obj) {\n    \n}\n\n/**\n * Your BSTIterator struct will be instantiated and called as such:\n * BSTIterator* obj = bSTIteratorCreate(root);\n * bool param_1 = bSTIteratorHasNext(obj);\n \n * int param_2 = bSTIteratorNext(obj);\n \n * bool param_3 = bSTIteratorHasPrev(obj);\n \n * int param_4 = bSTIteratorPrev(obj);\n \n * bSTIteratorFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class BSTIterator {\n\n    public BSTIterator(TreeNode root) {\n        \n    }\n    \n    public bool HasNext() {\n        \n    }\n    \n    public int Next() {\n        \n    }\n    \n    public bool HasPrev() {\n        \n    }\n    \n    public int Prev() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * bool param_1 = obj.HasNext();\n * int param_2 = obj.Next();\n * bool param_3 = obj.HasPrev();\n * int param_4 = obj.Prev();\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n    \n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n    \n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasPrev = function() {\n    \n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.prev = function() {\n    \n};\n\n/** \n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */"}, "TypeScript": {"langSlug": "typescript", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nclass BSTIterator {\n    constructor(root: TreeNode | null) {\n        \n    }\n\n    hasNext(): boolean {\n        \n    }\n\n    next(): number {\n        \n    }\n\n    hasPrev(): boolean {\n        \n    }\n\n    prev(): number {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */"}, "PHP": {"langSlug": "php", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass BSTIterator {\n    /**\n     * @param TreeNode $root\n     */\n    function __construct($root) {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasPrev() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function prev() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * $obj = BSTIterator($root);\n * $ret_1 = $obj->hasNext();\n * $ret_2 = $obj->next();\n * $ret_3 = $obj->hasPrev();\n * $ret_4 = $obj->prev();\n */"}, "Swift": {"langSlug": "swift", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\n\nclass BSTIterator {\n\n    init(_ root: TreeNode?) {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasPrev() -> Bool {\n        \n    }\n    \n    func prev() -> Int {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * let obj = BSTIterator(root)\n * let ret_1: Bool = obj.hasNext()\n * let ret_2: Int = obj.next()\n * let ret_3: Bool = obj.hasPrev()\n * let ret_4: Int = obj.prev()\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass BSTIterator(root: TreeNode?) {\n\n    fun hasNext(): Boolean {\n        \n    }\n\n    fun next(): Int {\n        \n    }\n\n    fun hasPrev(): Boolean {\n        \n    }\n\n    fun prev(): Int {\n        \n    }\n\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = BSTIterator(root)\n * var param_1 = obj.hasNext()\n * var param_2 = obj.next()\n * var param_3 = obj.hasPrev()\n * var param_4 = obj.prev()\n */"}, "Dart": {"langSlug": "dart", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass BSTIterator {\n\n  BSTIterator(TreeNode? root) {\n    \n  }\n  \n  bool hasNext() {\n    \n  }\n  \n  int next() {\n    \n  }\n  \n  bool hasPrev() {\n    \n  }\n  \n  int prev() {\n    \n  }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = BSTIterator(root);\n * bool param1 = obj.hasNext();\n * int param2 = obj.next();\n * bool param3 = obj.hasPrev();\n * int param4 = obj.prev();\n */"}, "Go": {"langSlug": "golang", "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\ntype BSTIterator struct {\n    \n}\n\n\nfunc Constructor(root *TreeNode) BSTIterator {\n    \n}\n\n\nfunc (this *BSTIterator) HasNext() bool {\n    \n}\n\n\nfunc (this *BSTIterator) Next() int {\n    \n}\n\n\nfunc (this *BSTIterator) HasPrev() bool {\n    \n}\n\n\nfunc (this *BSTIterator) Prev() int {\n    \n}\n\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * obj := Constructor(root);\n * param_1 := obj.HasNext();\n * param_2 := obj.Next();\n * param_3 := obj.HasPrev();\n * param_4 := obj.Prev();\n */"}, "Ruby": {"langSlug": "ruby", "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\nclass BSTIterator\n\n=begin\n    :type root: TreeNode\n=end\n    def initialize(root)\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_next()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def next()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_prev()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def prev()\n        \n    end\n\n\nend\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator.new(root)\n# param_1 = obj.has_next()\n# param_2 = obj.next()\n# param_3 = obj.has_prev()\n# param_4 = obj.prev()"}, "Scala": {"langSlug": "scala", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nclass BSTIterator(_root: TreeNode) {\n\n    def hasNext(): Boolean = {\n        \n    }\n\n    def next(): Int = {\n        \n    }\n\n    def hasPrev(): Boolean = {\n        \n    }\n\n    def prev(): Int = {\n        \n    }\n\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * val obj = new BSTIterator(root)\n * val param_1 = obj.hasNext()\n * val param_2 = obj.next()\n * val param_3 = obj.hasPrev()\n * val param_4 = obj.prev()\n */"}, "Rust": {"langSlug": "rust", "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nstruct BSTIterator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BSTIterator {\n\n    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_prev(&self) -> bool {\n        \n    }\n    \n    fn prev(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * let obj = BSTIterator::new(root);\n * let ret_1: bool = obj.has_next();\n * let ret_2: i32 = obj.next();\n * let ret_3: bool = obj.has_prev();\n * let ret_4: i32 = obj.prev();\n */"}, "Racket": {"langSlug": "racket", "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define bst-iterator%\n  (class object%\n    (super-new)\n    \n    ; root : (or/c tree-node? #f)\n    (init-field\n      root)\n    \n    ; has-next : -> boolean?\n    (define/public (has-next)\n      )\n    ; next : -> exact-integer?\n    (define/public (next)\n      )\n    ; has-prev : -> boolean?\n    (define/public (has-prev)\n      )\n    ; prev : -> exact-integer?\n    (define/public (prev)\n      )))\n\n;; Your bst-iterator% object will be instantiated and called as such:\n;; (define obj (new bst-iterator% [root root]))\n;; (define param_1 (send obj has-next))\n;; (define param_2 (send obj next))\n;; (define param_3 (send obj has-prev))\n;; (define param_4 (send obj prev))"}, "Erlang": {"langSlug": "erlang", "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec bst_iterator_init_(Root :: #tree_node{} | null) -> any().\nbst_iterator_init_(Root) ->\n  .\n\n-spec bst_iterator_has_next() -> boolean().\nbst_iterator_has_next() ->\n  .\n\n-spec bst_iterator_next() -> integer().\nbst_iterator_next() ->\n  .\n\n-spec bst_iterator_has_prev() -> boolean().\nbst_iterator_has_prev() ->\n  .\n\n-spec bst_iterator_prev() -> integer().\nbst_iterator_prev() ->\n  .\n\n\n%% Your functions will be called as such:\n%% bst_iterator_init_(Root),\n%% Param_1 = bst_iterator_has_next(),\n%% Param_2 = bst_iterator_next(),\n%% Param_3 = bst_iterator_has_prev(),\n%% Param_4 = bst_iterator_prev(),\n\n%% bst_iterator_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule BSTIterator do\n  @spec init_(root :: TreeNode.t | nil) :: any\n  def init_(root) do\n    \n  end\n\n  @spec has_next() :: boolean\n  def has_next() do\n    \n  end\n\n  @spec next() :: integer\n  def next() do\n    \n  end\n\n  @spec has_prev() :: boolean\n  def has_prev() do\n    \n  end\n\n  @spec prev() :: integer\n  def prev() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# BSTIterator.init_(root)\n# param_1 = BSTIterator.has_next()\n# param_2 = BSTIterator.next()\n# param_3 = BSTIterator.has_prev()\n# param_4 = BSTIterator.prev()\n\n# BSTIterator.init_ will be called before every test case, in which you can do some necessary initializations."}}}