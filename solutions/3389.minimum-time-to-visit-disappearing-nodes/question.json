{"question_id": "3389", "problem_slug": "minimum-time-to-visit-disappearing-nodes", "problem_title": "Minimum Time to Visit Disappearing Nodes", "content": "There is an undirected graph of n nodes. You are given a 2D array edges, where edges[i] = [ui, vi, lengthi] describes an edge between node ui and node vi with a traversal time of lengthi units.\nAdditionally, you are given an array disappear, where disappear[i] denotes the time when the node i disappears from the graph and you won't be able to visit it.\nNote that the graph might be disconnected and might contain multiple edges.\nReturn the array answer, with answer[i] denoting the minimum units of time required to reach node i from node 0. If node i is unreachable from node 0 then answer[i] is -1.\n \nExample 1:\n\nInput: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]\nOutput: [0,-1,4]\nExplanation:\n\nWe are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.\n\nFor node 0, we don't need any time as it is our starting point.\nFor node 1, we need at least 2 units of time to traverse edges[0]. Unfortunately, it disappears at that moment, so we won't be able to visit it.\nFor node 2, we need at least 4 units of time to traverse edges[2].\n\n\nExample 2:\n\nInput: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]\nOutput: [0,2,3]\nExplanation:\n\nWe are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.\n\nFor node 0, we don't need any time as it is the starting point.\nFor node 1, we need at least 2 units of time to traverse edges[0].\nFor node 2, we need at least 3 units of time to traverse edges[0] and edges[1].\n\n\nExample 3:\n\nInput: n = 2, edges = [[0,1,1]], disappear = [1,1]\nOutput: [0,-1]\nExplanation:\nExactly when we reach node 1, it disappears.\n\n \nConstraints:\n\n1 <= n <= 5 * 104\n0 <= edges.length <= 105\nedges[i] == [ui, vi, lengthi]\n0 <= ui, vi <= n - 1\n1 <= lengthi <= 105\ndisappear.length == n\n1 <= disappear[i] <= 105\n\n", "hints": ["Use Dijkstra’s algorithm, but only visit nodes if you can reach them before disappearance."], "exampleTestcases": "3\n[[0,1,2],[1,2,1],[0,2,4]]\n[1,1,5]\n3\n[[0,1,2],[1,2,1],[0,2,4]]\n[1,3,5]\n2\n[[0,1,1]]\n[1,1]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] disappear) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def minimumTime(self, n, edges, disappear):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type disappear: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* minimumTime(int n, int** edges, int edgesSize, int* edgesColSize, int* disappear, int disappearSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[] MinimumTime(int n, int[][] edges, int[] disappear) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} disappear\n * @return {number[]}\n */\nvar minimumTime = function(n, edges, disappear) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function minimumTime(n: number, edges: number[][], disappear: number[]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer[] $disappear\n     * @return Integer[]\n     */\n    function minimumTime($n, $edges, $disappear) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func minimumTime(_ n: Int, _ edges: [[Int]], _ disappear: [Int]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun minimumTime(n: Int, edges: Array<IntArray>, disappear: IntArray): IntArray {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> minimumTime(int n, List<List<int>> edges, List<int> disappear) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func minimumTime(n int, edges [][]int, disappear []int) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer[]} disappear\n# @return {Integer[]}\ndef minimum_time(n, edges, disappear)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def minimumTime(n: Int, edges: Array[Array[Int]], disappear: Array[Int]): Array[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn minimum_time(n: i32, edges: Vec<Vec<i32>>, disappear: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (minimum-time n edges disappear)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec minimum_time(N :: integer(), Edges :: [[integer()]], Disappear :: [integer()]) -> [integer()].\nminimum_time(N, Edges, Disappear) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec minimum_time(n :: integer, edges :: [[integer]], disappear :: [integer]) :: [integer]\n  def minimum_time(n, edges, disappear) do\n    \n  end\nend"}}}