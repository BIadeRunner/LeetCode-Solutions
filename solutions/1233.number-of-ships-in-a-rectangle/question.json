{"question_id": "1233", "problem_slug": "number-of-ships-in-a-rectangle", "problem_title": "Number of Ships in a Rectangle", "content": "(This problem is an interactive problem.)\nEach ship is located at an integer point on the sea represented by a cartesian plane, and each integer point may contain at most 1 ship.\nYou have a function Sea.hasShips(topRight, bottomLeft) which takes two points as arguments and returns true If there is at least one ship in the rectangle represented by the two points, including on the boundary.\nGiven two points: the top right and bottom left corners of a rectangle, return the number of ships present in that rectangle. It is guaranteed that there are at most 10 ships in that rectangle.\nSubmissions making more than 400 calls to hasShips will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n \nExample :\n\n\nInput: \nships = [[1,1],[2,2],[3,3],[5,5]], topRight = [4,4], bottomLeft = [0,0]\nOutput: 3\nExplanation: From [0,0] to [4,4] we can count 3 ships within the range.\n\nExample 2:\n\nInput: ans = [[1,1],[2,2],[3,3]], topRight = [1000,1000], bottomLeft = [0,0]\nOutput: 3\n\n \nConstraints:\n\nOn the input ships is only given to initialize the map internally. You must solve this problem \"blindfolded\". In other words, you must find the answer using the given hasShips API, without knowing the ships position.\n0 <= bottomLeft[0] <= topRight[0] <= 1000\n0 <= bottomLeft[1] <= topRight[1] <= 1000\ntopRight != bottomLeft\n\n", "hints": ["Use divide and conquer technique.", "Divide the query rectangle into 4 rectangles.", "Use recursion to continue with the rectangles that has ships only."], "exampleTestcases": "[[1,1],[2,2],[3,3],[5,5]]\n[4,4]\n[0,0]\n[[1,1],[2,2],[3,3]]\n[1000,1000]\n[0,0]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *   public:\n *     bool hasShips(vector<int> topRight, vector<int> bottomLeft);\n * };\n */\n\nclass Solution {\npublic:\n    int countShips(Sea sea, vector<int> topRight, vector<int> bottomLeft) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *     public boolean hasShips(int[] topRight, int[] bottomLeft);\n * }\n */\n\nclass Solution {\n    public int countShips(Sea sea, int[] topRight, int[] bottomLeft) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class Sea(object):\n#    def hasShips(self, topRight, bottomLeft):\n#        \"\"\"\n#        :type topRight: Point\n#\t\t :type bottomLeft: Point\n#        :rtype bool\n#        \"\"\"\n#\n#class Point(object):\n#\tdef __init__(self, x, y):\n#\t\tself.x = x\n#\t\tself.y = y\n\nclass Solution(object):\n    def countShips(self, sea, topRight, bottomLeft):\n        \"\"\"\n        :type sea: Sea\n        :type topRight: Point\n        :type bottomLeft: Point\n        :rtype: integer\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class Sea:\n#    def hasShips(self, topRight: 'Point', bottomLeft: 'Point') -> bool:\n#\n#class Point:\n#\tdef __init__(self, x: int, y: int):\n#\t\tself.x = x\n#\t\tself.y = y\n\nclass Solution:\n    def countShips(self, sea: 'Sea', topRight: 'Point', bottomLeft: 'Point') -> int:\n        "}, "C": {"langSlug": "c", "code": "/**\n * // The hasShips API is already defined for you.\n * // You should not implement it, or speculate about its implementation\n *     bool hasShips(int topRightX, int topRightY, int bottomLeftX, int bottomLeftY);\n */\n\nint countShips(int topRightX, int topRightY, int bottomLeftX, int bottomLeftY) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *     public bool HasShips(int[] topRight, int[] bottomLeft);\n * }\n */\n\nclass Solution {\n    public int CountShips(Sea sea, int[] topRight, int[] bottomLeft) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * function Sea() {\n *     @param {integer[]} topRight\n *     @param {integer[]} bottomLeft\n *     @return {boolean}\n *     this.hasShips = function(topRight, bottomLeft) {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {Sea} sea\n * @param {integer[]} topRight\n * @param {integer[]} bottomLeft\n * @return {integer}\n */\nvar countShips = function(sea, topRight, bottomLeft) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "/**\n * // This is the Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *      hasShips(topRight: number[], bottomLeft: number[]): boolean {}\n * }\n */\n\nfunction countShips(sea: Sea, topRight: number[], bottomLeft: number[]): number {\n\t\n};"}, "PHP": {"langSlug": "php", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *     function hasShips ($topRight, $bottomLeft) {}\n * }\n */\n\nclass Solution {\n    /**\n     * @param Sea $sea\n     * @param Integer[] $topRight\n     * @param Integer[] $bottomLeft\n     * @return Integer[]\n     */\n    function countShips ($sea, $topRight, $bottomLeft) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *     public func hasShips(_ topRight: [Int], _ bottomLeft: [Int]) -> Bool {}\n * }\n */\n\nclass Solution {\n    func countShips(_ sea: Sea, _ topRight: [Int], _ bottomLeft: [Int]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *     fun hasShips(topRight: IntArray, bottomLeft: IntArray): Boolean{}\n * }\n */\n\nclass Solution {\n    fun countShips(sea: Sea, topRight: IntArray, bottomLeft: IntArray): Int {\n        \n    }\n}"}, "Go": {"langSlug": "golang", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * type Sea struct {\n *     func hasShips(topRight, bottomLeft []int) bool {}\n * }\n */\n\nfunc countShips(sea Sea, topRight, bottomLeft []int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# class Sea\n#     def hasShips(topRight, bottomLeft)\n#\t\t\n#     end\n# end\n\n# @param {Sea} sea\n# @param {List[int]} topRight\n# @param {List[int]} bottomLeft\n# @return {int}\ndef countShips(sea, topRight, bottomLeft)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * class Sea {\n *     def hasShips(topRight: Array[Int], bottomLeft: Array[Int]): Boolean = {}\n * }\n */\n\nobject Solution {\n    def countShips(sea: Sea, topRight: Array[Int], bottomLeft: Array[Int]): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "/**\n * // This is Sea's API interface.\n * // You should not implement it, or speculate about its implementation\n * struct Sea;\n * impl Sea {\n *    pub fn hasShips(topRight: Vec<i32>,bottomLeft: Vec<i32>)->bool{}\n * }\n */\n\nimpl Solution {\n    pub fn count_ships(sea: &Sea, topRight: Vec<i32>, bottomLeft: Vec<i32>) -> i32 {\n\n    }\n}"}}}