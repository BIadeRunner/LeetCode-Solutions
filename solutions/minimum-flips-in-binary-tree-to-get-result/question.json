{"questionId": "2399", "acRate": 58.257741632780736, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "2313", "paidOnly": true, "status": "ac", "title": "Minimum Flips in Binary Tree to Get Result", "topicTags": [{"name": "Dynamic Programming", "id": "VG9waWNUYWdOb2RlOjEz", "slug": "dynamic-programming"}, {"name": "Tree", "id": "VG9waWNUYWdOb2RlOjIw", "slug": "tree"}, {"name": "Depth-First Search", "id": "VG9waWNUYWdOb2RlOjIx", "slug": "depth-first-search"}, {"name": "Binary Tree", "id": "VG9waWNUYWdOb2RlOjYxMDU3", "slug": "binary-tree"}], "titleSlug": "minimum-flips-in-binary-tree-to-get-result", "content": "<p>You are given the <code>root</code> of a <strong>binary tree</strong> with the following properties:</p>\n\n<ul>\n\t<li><strong>Leaf nodes</strong> have either the value <code>0</code> or <code>1</code>, representing <code>false</code> and <code>true</code> respectively.</li>\n\t<li><strong>Non-leaf nodes</strong> have either the value <code>2</code>, <code>3</code>, <code>4</code>, or <code>5</code>, representing the boolean operations <code>OR</code>, <code>AND</code>, <code>XOR</code>, and <code>NOT</code>, respectively.</li>\n</ul>\n\n<p>You are also given a boolean <code>result</code>, which is the desired result of the <strong>evaluation</strong> of the <code>root</code> node.</p>\n\n<p>The evaluation of a node is as follows:</p>\n\n<ul>\n\t<li>If the node is a leaf node, the evaluation is the <strong>value</strong> of the node, i.e. <code>true</code> or <code>false</code>.</li>\n\t<li>Otherwise, <strong>evaluate</strong> the node&#39;s children and <strong>apply</strong> the boolean operation of its value with the children&#39;s evaluations.</li>\n</ul>\n\n<p>In one operation, you can <strong>flip</strong> a leaf node, which causes a <code>false</code> node to become <code>true</code>, and a <code>true</code> node to become <code>false</code>.</p>\n\n<p>Return<em> the minimum number of operations that need to be performed such that the evaluation of </em><code>root</code><em> yields </em><code>result</code>. It can be shown that there is always a way to achieve <code>result</code>.</p>\n\n<p>A <strong>leaf node</strong> is a node that has zero children.</p>\n\n<p>Note: <code>NOT</code> nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/20/operationstree.png\" style=\"width: 500px; height: 179px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,4,2,null,1,1,1,0], result = true\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nIt can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree\nevaluate to true. One way to achieve this is shown in the diagram above.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0], result = false\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nThe root of the tree already evaluates to false, so 0 nodes have to be flipped.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5</code></li>\n\t<li><code>OR</code>, <code>AND</code>, and <code>XOR</code> nodes have <code>2</code> children.</li>\n\t<li><code>NOT</code> nodes have <code>1</code> child.</li>\n\t<li>Leaf nodes have a value of <code>0</code> or <code>1</code>.</li>\n\t<li>Non-leaf nodes have a value of <code>2</code>, <code>3</code>, <code>4</code>, or <code>5</code>.</li>\n</ul>\n", "hints": ["Try using tree DP to solve this problem.", "Find the minimum operations to change each subtree to true and to false separately.", "For nodes representing boolean operations, find the minimum operations by trying all combinations of values to which the child nodes can evaluate."], "exampleTestcases": "[3,5,4,2,null,1,1,1,0]\ntrue\n[0]\nfalse", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minimumFlips(TreeNode* root, bool result) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minimumFlips(TreeNode root, boolean result) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minimumFlips(self, root, result):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type result: bool\n        :rtype: int\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint minimumFlips(struct TreeNode* root, bool result) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MinimumFlips(TreeNode root, bool result) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {boolean} result\n * @return {number}\n */\nvar minimumFlips = function(root, result) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction minimumFlips(root: TreeNode | null, result: boolean): number {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Boolean $result\n     * @return Integer\n     */\n    function minimumFlips($root, $result) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func minimumFlips(_ root: TreeNode?, _ result: Bool) -> Int {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun minimumFlips(root: TreeNode?, result: Boolean): Int {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int minimumFlips(TreeNode? root, bool result) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc minimumFlips(root *TreeNode, result bool) int {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Boolean} result\n# @return {Integer}\ndef minimum_flips(root, result)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def minimumFlips(root: TreeNode, result: Boolean): Int = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn minimum_flips(root: Option<Rc<RefCell<TreeNode>>>, result: bool) -> i32 {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (minimum-flips root result)\n  (-> (or/c tree-node? #f) boolean? exact-integer?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec minimum_flips(Root :: #tree_node{} | null, Result :: boolean()) -> integer().\nminimum_flips(Root, Result) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec minimum_flips(root :: TreeNode.t | nil, result :: boolean) :: integer\n  def minimum_flips(root, result) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "check-if-two-expression-trees-are-equivalent", "title": "Check If Two Expression Trees are Equivalent", "isPaidOnly": true}, {"difficulty": "Medium", "titleSlug": "design-an-expression-tree-with-evaluate-function", "title": "Design an Expression Tree With Evaluate Function", "isPaidOnly": true}, {"difficulty": "Easy", "titleSlug": "evaluate-boolean-binary-tree", "title": "Evaluate Boolean Binary Tree", "isPaidOnly": false}]}