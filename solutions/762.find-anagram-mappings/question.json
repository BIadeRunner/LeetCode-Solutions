{"question_id": "762", "problem_slug": "find-anagram-mappings", "problem_title": "Find Anagram Mappings", "content": "You are given two integer arrays nums1 and nums2 where nums2 is an anagram of nums1. Both arrays may contain duplicates.\nReturn an index mapping array mapping from nums1 to nums2 where mapping[i] = j means the ith element in nums1 appears in nums2 at index j. If there are multiple answers, return any of them.\nAn array a is an anagram of an array b means b is made by randomizing the order of the elements in a.\n \nExample 1:\n\nInput: nums1 = [12,28,46,32,50], nums2 = [50,12,32,46,28]\nOutput: [1,4,3,2,0]\nExplanation: As mapping[0] = 1 because the 0th element of nums1 appears at nums2[1], and mapping[1] = 4 because the 1st element of nums1 appears at nums2[4], and so on.\n\nExample 2:\n\nInput: nums1 = [84,46], nums2 = [84,46]\nOutput: [0,1]\n\n \nConstraints:\n\n1 <= nums1.length <= 100\nnums2.length == nums1.length\n0 <= nums1[i], nums2[i] <= 105\nnums2 is an anagram of nums1.\n\n", "hints": ["Create a hashmap so that D[x] = i  whenever B[i] = x.  Then, the answer is [D[x] for x in A]."], "exampleTestcases": "[12,28,46,32,50]\n[50,12,32,46,28]\n[84,46]\n[84,46]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[] anagramMappings(int[] nums1, int[] nums2) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def anagramMappings(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def anagramMappings(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* anagramMappings(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[] AnagramMappings(int[] nums1, int[] nums2) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar anagramMappings = function(nums1, nums2) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function anagramMappings(nums1: number[], nums2: number[]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Integer[]\n     */\n    function anagramMappings($nums1, $nums2) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func anagramMappings(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun anagramMappings(nums1: IntArray, nums2: IntArray): IntArray {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> anagramMappings(List<int> nums1, List<int> nums2) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func anagramMappings(nums1 []int, nums2 []int) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Integer[]}\ndef anagram_mappings(nums1, nums2)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def anagramMappings(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn anagram_mappings(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (anagram-mappings nums1 nums2)\n  (-> (listof exact-integer?) (listof exact-integer?) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec anagram_mappings(Nums1 :: [integer()], Nums2 :: [integer()]) -> [integer()].\nanagram_mappings(Nums1, Nums2) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec anagram_mappings(nums1 :: [integer], nums2 :: [integer]) :: [integer]\n  def anagram_mappings(nums1, nums2) do\n    \n  end\nend"}}}