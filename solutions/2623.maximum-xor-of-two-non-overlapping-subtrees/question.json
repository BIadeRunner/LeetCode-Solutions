{"question_id": "2623", "problem_slug": "maximum-xor-of-two-non-overlapping-subtrees", "problem_title": "Maximum XOR of Two Non-Overlapping Subtrees", "content": "There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. The root of the tree is the node labeled 0.\nEach node has an associated value. You are given an array values of length n, where values[i] is the value of the ith node.\nSelect any two non-overlapping subtrees. Your score is the bitwise XOR of the sum of the values within those subtrees.\nReturn the maximum possible score you can achieve. If it is impossible to find two nonoverlapping subtrees, return 0.\nNote that:\n\nThe subtree of a node is the tree consisting of that node and all of its descendants.\nTwo subtrees are non-overlapping if they do not share any common node.\n\n \nExample 1:\n\n\nInput: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]\nOutput: 24\nExplanation: Node 1's subtree has sum of values 16, while node 2's subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain.\n\nExample 2:\n\n\nInput: n = 3, edges = [[0,1],[1,2]], values = [4,6,1]\nOutput: 0\nExplanation: There is no possible way to select two non-overlapping subtrees, so we just return 0.\n\n \nConstraints:\n\n2 <= n <= 5 * 104\nedges.length == n - 1\n0 <= ai, bi < n\nvalues.length == n\n1 <= values[i] <= 109\nIt is guaranteed that edges represents a valid tree.\n\n", "hints": ["Try to build the answer bit by bit from the most significant bit to the least significant.", "Use the Trie Data Structure to decide for each bit if it exists in the final answer."], "exampleTestcases": "6\n[[0,1],[0,2],[1,3],[1,4],[2,5]]\n[2,8,3,6,2,5]\n3\n[[0,1],[1,2]]\n[4,6,1]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    long long maxXor(int n, vector<vector<int>>& edges, vector<int>& values) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public long maxXor(int n, int[][] edges, int[] values) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def maxXor(self, n, edges, values):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type values: List[int]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def maxXor(self, n: int, edges: List[List[int]], values: List[int]) -> int:\n        "}, "C": {"langSlug": "c", "code": "long long maxXor(int n, int** edges, int edgesSize, int* edgesColSize, int* values, int valuesSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public long MaxXor(int n, int[][] edges, int[] values) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[]} values\n * @return {number}\n */\nvar maxXor = function(n, edges, values) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function maxXor(n: number, edges: number[][], values: number[]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer[] $values\n     * @return Integer\n     */\n    function maxXor($n, $edges, $values) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func maxXor(_ n: Int, _ edges: [[Int]], _ values: [Int]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun maxXor(n: Int, edges: Array<IntArray>, values: IntArray): Long {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int maxXor(int n, List<List<int>> edges, List<int> values) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func maxXor(n int, edges [][]int, values []int) int64 {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer[]} values\n# @return {Integer}\ndef max_xor(n, edges, values)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def maxXor(n: Int, edges: Array[Array[Int]], values: Array[Int]): Long = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn max_xor(n: i32, edges: Vec<Vec<i32>>, values: Vec<i32>) -> i64 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (max-xor n edges values)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec max_xor(N :: integer(), Edges :: [[integer()]], Values :: [integer()]) -> integer().\nmax_xor(N, Edges, Values) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec max_xor(n :: integer, edges :: [[integer]], values :: [integer]) :: integer\n  def max_xor(n, edges, values) do\n    \n  end\nend"}}}