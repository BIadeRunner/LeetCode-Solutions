{"question_id": "3533", "problem_slug": "snake-in-matrix", "problem_title": "Snake in Matrix", "content": "There is a snake in an n x n matrix grid and can move in four possible directions. Each cell in the grid is identified by the position: grid[i][j] = (i * n) + j.\nThe snake starts at cell 0 and follows a sequence of commands.\nYou are given an integer n representing the size of the grid and an array of strings commands where each command[i] is either \"UP\", \"RIGHT\", \"DOWN\", and \"LEFT\". It's guaranteed that the snake will remain within the grid boundaries throughout its movement.\nReturn the position of the final cell where the snake ends up after executing commands.\n \nExample 1:\n\nInput: n = 2, commands = [\"RIGHT\",\"DOWN\"]\nOutput: 3\nExplanation:\n\n\n\n\n0\n1\n\n\n2\n3\n\n\n\n\n\n\n0\n1\n\n\n2\n3\n\n\n\n\n\n\n0\n1\n\n\n2\n3\n\n\n\n\n\nExample 2:\n\nInput: n = 3, commands = [\"DOWN\",\"RIGHT\",\"UP\"]\nOutput: 1\nExplanation:\n\n\n\n\n0\n1\n2\n\n\n3\n4\n5\n\n\n6\n7\n8\n\n\n\n\n\n\n0\n1\n2\n\n\n3\n4\n5\n\n\n6\n7\n8\n\n\n\n\n\n\n0\n1\n2\n\n\n3\n4\n5\n\n\n6\n7\n8\n\n\n\n\n\n\n0\n1\n2\n\n\n3\n4\n5\n\n\n6\n7\n8\n\n\n\n\n\n \nConstraints:\n\n2 <= n <= 10\n1 <= commands.length <= 100\ncommands consists only of \"UP\", \"RIGHT\", \"DOWN\", and \"LEFT\".\nThe input is generated such the snake will not move outside of the boundaries.\n\n", "hints": ["Try to update the row and column of the snake after each command."], "exampleTestcases": "2\n[\"RIGHT\",\"DOWN\"]\n3\n[\"DOWN\",\"RIGHT\",\"UP\"]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int finalPositionOfSnake(int n, vector<string>& commands) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int finalPositionOfSnake(int n, List<String> commands) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def finalPositionOfSnake(self, n, commands):\n        \"\"\"\n        :type n: int\n        :type commands: List[str]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:\n        "}, "C": {"langSlug": "c", "code": "int finalPositionOfSnake(int n, char** commands, int commandsSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int FinalPositionOfSnake(int n, IList<string> commands) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {string[]} commands\n * @return {number}\n */\nvar finalPositionOfSnake = function(n, commands) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function finalPositionOfSnake(n: number, commands: string[]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param String[] $commands\n     * @return Integer\n     */\n    function finalPositionOfSnake($n, $commands) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func finalPositionOfSnake(_ n: Int, _ commands: [String]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun finalPositionOfSnake(n: Int, commands: List<String>): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int finalPositionOfSnake(int n, List<String> commands) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func finalPositionOfSnake(n int, commands []string) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {String[]} commands\n# @return {Integer}\ndef final_position_of_snake(n, commands)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def finalPositionOfSnake(n: Int, commands: List[String]): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn final_position_of_snake(n: i32, commands: Vec<String>) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (final-position-of-snake n commands)\n  (-> exact-integer? (listof string?) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec final_position_of_snake(N :: integer(), Commands :: [unicode:unicode_binary()]) -> integer().\nfinal_position_of_snake(N, Commands) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec final_position_of_snake(n :: integer, commands :: [String.t]) :: integer\n  def final_position_of_snake(n, commands) do\n    \n  end\nend"}}}