{"question_id": "2420", "problem_slug": "closest-node-to-path-in-tree", "problem_title": "Closest Node to Path in Tree", "content": "You are given a positive integer n representing the number of nodes in a tree, numbered from 0 to n - 1 (inclusive). You are also given a 2D integer array edges of length n - 1, where edges[i] = [node1i, node2i] denotes that there is a bidirectional edge connecting node1i and node2i in the tree.\nYou are given a 0-indexed integer array query of length m where query[i] = [starti, endi, nodei] means that for the ith query, you are tasked with finding the node on the path from starti to endi that is closest to nodei.\nReturn an integer array answer of length m, where answer[i] is the answer to the ith query.\n \nExample 1:\n\n\nInput: n = 7, edges = [[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]], query = [[5,3,4],[5,3,6]]\nOutput: [0,2]\nExplanation:\nThe path from node 5 to node 3 consists of the nodes 5, 2, 0, and 3.\nThe distance between node 4 and node 0 is 2.\nNode 0 is the node on the path closest to node 4, so the answer to the first query is 0.\nThe distance between node 6 and node 2 is 1.\nNode 2 is the node on the path closest to node 6, so the answer to the second query is 2.\n\nExample 2:\n\n\nInput: n = 3, edges = [[0,1],[1,2]], query = [[0,1,2]]\nOutput: [1]\nExplanation:\nThe path from node 0 to node 1 consists of the nodes 0, 1.\nThe distance between node 2 and node 1 is 1.\nNode 1 is the node on the path closest to node 2, so the answer to the first query is 1.\n\nExample 3:\n\n\nInput: n = 3, edges = [[0,1],[1,2]], query = [[0,0,0]]\nOutput: [0]\nExplanation:\nThe path from node 0 to node 0 consists of the node 0.\nSince 0 is the only node on the path, the answer to the first query is 0.\n \nConstraints:\n\n1 <= n <= 1000\nedges.length == n - 1\nedges[i].length == 2\n0 <= node1i, node2i <= n - 1\nnode1i != node2i\n1 <= query.length <= 1000\nquery[i].length == 3\n0 <= starti, endi, nodei <= n - 1\nThe graph is a tree.\n\n", "hints": ["For the ith query, find the distance from node_i to every other node in the tree.", "We can use a BFS to find the distances.", "Use DFS to find all the nodes on the path from start_i to end_i."], "exampleTestcases": "7\n[[0,1],[0,2],[0,3],[1,4],[2,5],[2,6]]\n[[5,3,4],[5,3,6]]\n3\n[[0,1],[1,2]]\n[[0,1,2]]\n3\n[[0,1],[1,2]]\n[[0,0,0]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> closestNode(int n, vector<vector<int>>& edges, vector<vector<int>>& query) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[] closestNode(int n, int[][] edges, int[][] query) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def closestNode(self, n, edges, query):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type query: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def closestNode(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* closestNode(int n, int** edges, int edgesSize, int* edgesColSize, int** query, int querySize, int* queryColSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[] ClosestNode(int n, int[][] edges, int[][] query) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number[][]} query\n * @return {number[]}\n */\nvar closestNode = function(n, edges, query) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function closestNode(n: number, edges: number[][], query: number[][]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer[][] $query\n     * @return Integer[]\n     */\n    function closestNode($n, $edges, $query) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func closestNode(_ n: Int, _ edges: [[Int]], _ query: [[Int]]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun closestNode(n: Int, edges: Array<IntArray>, query: Array<IntArray>): IntArray {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> closestNode(int n, List<List<int>> edges, List<List<int>> query) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func closestNode(n int, edges [][]int, query [][]int) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer[][]} query\n# @return {Integer[]}\ndef closest_node(n, edges, query)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def closestNode(n: Int, edges: Array[Array[Int]], query: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn closest_node(n: i32, edges: Vec<Vec<i32>>, query: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (closest-node n edges query)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec closest_node(N :: integer(), Edges :: [[integer()]], Query :: [[integer()]]) -> [integer()].\nclosest_node(N, Edges, Query) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec closest_node(n :: integer, edges :: [[integer]], query :: [[integer]]) :: [integer]\n  def closest_node(n, edges, query) do\n    \n  end\nend"}}}