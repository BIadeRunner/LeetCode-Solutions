{"question_id": "1713", "problem_slug": "dot-product-of-two-sparse-vectors", "problem_title": "Dot Product of Two Sparse Vectors", "content": "Given two sparse vectors, compute their dot product.\nImplement class SparseVector:\n\nSparseVector(nums) Initializes the object with the vector nums\ndotProduct(vec) Compute the dot product between the instance of SparseVector and vec\n\nA sparse vector is a vector that has mostly zero values, you should store the sparse vector efficiently and compute the dot product between two SparseVector.\nFollow up: What if only one of the vectors is sparse?\n \nExample 1:\n\nInput: nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]\nOutput: 8\nExplanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)\nv1.dotProduct(v2) = 1*0 + 0*3 + 0*0 + 2*4 + 3*0 = 8\n\nExample 2:\n\nInput: nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]\nOutput: 0\nExplanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)\nv1.dotProduct(v2) = 0*0 + 1*0 + 0*0 + 0*0 + 0*2 = 0\n\nExample 3:\n\nInput: nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]\nOutput: 6\n\n \nConstraints:\n\nn == nums1.length == nums2.length\n1 <= n <= 10^5\n0 <= nums1[i], nums2[i] <= 100\n\n", "hints": ["Because the vector is sparse, use a data structure that stores the index and value where the element is nonzero."], "exampleTestcases": "[1,0,0,2,3]\n[0,3,0,4,0]\n[0,1,0,0,0]\n[0,0,0,0,2]\n[0,1,0,0,2,0,0]\n[1,0,0,0,3,0,4]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class SparseVector {\npublic:\n    \n    SparseVector(vector<int> &nums) {\n        \n    }\n    \n    // Return the dotProduct of two sparse vectors\n    int dotProduct(SparseVector& vec) {\n        \n    }\n};\n\n// Your SparseVector object will be instantiated and called as such:\n// SparseVector v1(nums1);\n// SparseVector v2(nums2);\n// int ans = v1.dotProduct(v2);"}, "Java": {"langSlug": "java", "code": "class SparseVector {\n    \n    SparseVector(int[] nums) {\n        \n    }\n    \n\t// Return the dotProduct of two sparse vectors\n    public int dotProduct(SparseVector vec) {\n        \n    }\n}\n\n// Your SparseVector object will be instantiated and called as such:\n// SparseVector v1 = new SparseVector(nums1);\n// SparseVector v2 = new SparseVector(nums2);\n// int ans = v1.dotProduct(v2);"}, "Python": {"langSlug": "python", "code": "class SparseVector:\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        \n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec):\n        \"\"\"\n        :type vec: 'SparseVector'\n        :rtype: int\n        \"\"\"\n        \n\n# Your SparseVector object will be instantiated and called as such:\n# v1 = SparseVector(nums1)\n# v2 = SparseVector(nums2)\n# ans = v1.dotProduct(v2)"}, "Python3": {"langSlug": "python3", "code": "class SparseVector:\n    def __init__(self, nums: List[int]):\n        \n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec: 'SparseVector') -> int:\n        \n\n# Your SparseVector object will be instantiated and called as such:\n# v1 = SparseVector(nums1)\n# v2 = SparseVector(nums2)\n# ans = v1.dotProduct(v2)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} SparseVector;\n\n\nSparseVector* sparseVectorCreate(int* nums, int numsSize) {\n    \n}\n\n// Return the dotProduct of two sparse vectors\nint sparseVectordotProduct(SparseVector* obj, SparseVector* vec) {\n  \n}\n\n/**\n * Your SparseVector struct will be instantiated and called as such:\n * SparseVector* v1 = sparseVectorCreate(nums1, nums1Size);\n * SparseVector* v2 = sparseVectorCreate(nums2, nums2Size);\n * int ans = sparseVectordotProduct(v1, v2);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class SparseVector {\n    \n    public SparseVector(int[] nums) {\n        \n    }\n    \n    // Return the dotProduct of two sparse vectors\n    public int DotProduct(SparseVector vec) {\n        \n    }\n}\n\n// Your SparseVector object will be instantiated and called as such:\n// SparseVector v1 = new SparseVector(nums1);\n// SparseVector v2 = new SparseVector(nums2);\n// int ans = v1.DotProduct(v2);"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} nums\n * @return {SparseVector}\n */\nvar SparseVector = function(nums) {\n    \n};\n\n// Return the dotProduct of two sparse vectors\n/**\n * @param {SparseVector} vec\n * @return {number}\n */\nSparseVector.prototype.dotProduct = function(vec) {\n    \n};\n\n// Your SparseVector object will be instantiated and called as such:\n// let v1 = new SparseVector(nums1);\n// let v2 = new SparseVector(nums2);\n// let ans = v1.dotProduct(v2);"}, "TypeScript": {"langSlug": "typescript", "code": "class SparseVector {\n    constructor(nums: number[]) {\n\t\t\n    }\n\n\t// Return the dotProduct of two sparse vectors\n    dotProduct(vec: SparseVector): number {\n\t\t\n    }\n}\n\n/**\n * Your SparseVector object will be instantiated and called as such:\n * var v1 = new SparseVector(nums1)\n * var v2 = new SparseVector(nums1)\n * var ans = v1.dotProduct(v2)\n */"}, "PHP": {"langSlug": "php", "code": "class SparseVector {\n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        \n    }\n    \n    // Return the dotProduct of two sparse vectors\n    /**\n     * @param SparseVector $vec\n     * @return Integer\n     */\n    function dotProduct($vec) {\n        \n    }\n}\n\n/**\n * Your SparseVector object will be instantiated and called as such:\n * $v1 = new SparseVector($nums1);\n * $v2 = new SparseVector($nums2);\n * $ans = $v1->dotProduct($v2);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass SparseVector {\n    \n    init(_ nums: [Int]) {\n        \n    }\n\n    // Return the dotProduct of two sparse vectors\n    func dotProduct(_ vec: SparseVector) -> Int {\n        \n    }\n}\n\n/**\n * Your SparseVector object will be instantiated and called as such:\n * let v1 = SparseVector(nums1)\n * let v2 = SparseVector(nums2)\n * let ans = v1.dotProduct(v2)\n*/"}, "Kotlin": {"langSlug": "kotlin", "code": "class SparseVector(nums: IntArray) {\n    // Return the dotProduct of two sparse vectors\n    fun dotProduct(vec: SparseVector): Int {\n        \n    }\n}\n\n/**\n * Your SparseVector object will be instantiated and called as such:\n * var v1 = SparseVector(nums1)\n * var v2 = SparseVector(nums2)\n * val ans = v1.dotProduct(v2)\n */"}, "Go": {"langSlug": "golang", "code": "type SparseVector struct {\n    \n}\n\nfunc Constructor(nums []int) SparseVector {\n    \n}\n\n// Return the dotProduct of two sparse vectors\nfunc (this *SparseVector) dotProduct(vec SparseVector) int {\n    \n}\n\n/**\n * Your SparseVector object will be instantiated and called as such:\n * v1 := Constructor(nums1);\n * v2 := Constructor(nums2);\n * ans := v1.dotProduct(v2);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class SparseVector\n\n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n        \n    end\n\n# Return the dotProduct of two sparse vectors\n=begin\n    :type vec: SparseVector\n    :rtype: Integer\n=end\n    def dotProduct(vec)\n        \n    end\nend\n\n# Your SparseVector object will be instantiated and called as such:\n# v1 = SparseVector.new(nums1)\n# v2 = SparseVector.new(nums2)\n# ans = v1.dotProduct(v2)"}, "Scala": {"langSlug": "scala", "code": "class SparseVector(nums: Array[Int]) {\n    // Return the dotProduct of two sparse vectors\n    def dotProduct(vec: SparseVector): Int = {\n        \n    }\n}\n\n/**\n * Your SparseVector object will be instantiated and called as such:\n * var v1 = new SparseVector(nums1)\n * var v2 = new SparseVector(nums2)\n * val ans = v1.dotProduct(v2)\n */"}, "Rust": {"langSlug": "rust", "code": "struct SparseVector {\n\t\n}\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl SparseVector {\n    fn new(nums: Vec<i32>) -> Self {\n        \n    }\n\t\n    // Return the dotProduct of two sparse vectors\n    fn dot_product(&self, vec: SparseVector) -> i32 {\n        \n    }\n}\n\n/**\n * Your SparseVector object will be instantiated and called as such:\n * let v1 = SparseVector::new(nums1);\n * let v2 = SparseVector::new(nums2);\n * let ans = v1.dot_product(v2);\n */"}}}