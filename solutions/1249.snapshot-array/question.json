{"questionId": "1249", "acRate": 36.82589297294493, "difficulty": "Medium", "freqBar": 64.13404904395763, "frontendQuestionId": "1146", "paidOnly": false, "status": "ac", "title": "Snapshot Array", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Hash Table", "id": "VG9waWNUYWdOb2RlOjY=", "slug": "hash-table"}, {"name": "Binary Search", "id": "VG9waWNUYWdOb2RlOjEx", "slug": "binary-search"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}], "titleSlug": "snapshot-array", "content": "<p>Implement a SnapshotArray that supports the following interface:</p>\n\n<ul>\n\t<li><code>SnapshotArray(int length)</code> initializes an array-like data structure with the given length. <strong>Initially, each element equals 0</strong>.</li>\n\t<li><code>void set(index, val)</code> sets the element at the given <code>index</code> to be equal to <code>val</code>.</li>\n\t<li><code>int snap()</code> takes a snapshot of the array and returns the <code>snap_id</code>: the total number of times we called <code>snap()</code> minus <code>1</code>.</li>\n\t<li><code>int get(index, snap_id)</code> returns the value at the given <code>index</code>, at the time we took the snapshot with the given <code>snap_id</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]\n[[3],[0,5],[],[0,6],[0,0]]\n<strong>Output:</strong> [null,null,0,null,5]\n<strong>Explanation: </strong>\nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= index &lt; length</code></li>\n\t<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= snap_id &lt; </code>(the total number of times we call <code>snap()</code>)</li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>set</code>, <code>snap</code>, and <code>get</code>.</li>\n</ul>\n", "hints": ["Use a list of lists, adding both the element and the snap_id to each index."], "exampleTestcases": "[\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"]\n[[3],[0,5],[],[0,6],[0,0]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class SnapshotArray {\npublic:\n    SnapshotArray(int length) {\n        \n    }\n    \n    void set(int index, int val) {\n        \n    }\n    \n    int snap() {\n        \n    }\n    \n    int get(int index, int snap_id) {\n        \n    }\n};\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * SnapshotArray* obj = new SnapshotArray(length);\n * obj->set(index,val);\n * int param_2 = obj->snap();\n * int param_3 = obj->get(index,snap_id);\n */"}, {"lang": "Java", "langSlug": "java", "code": "class SnapshotArray {\n\n    public SnapshotArray(int length) {\n        \n    }\n    \n    public void set(int index, int val) {\n        \n    }\n    \n    public int snap() {\n        \n    }\n    \n    public int get(int index, int snap_id) {\n        \n    }\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * SnapshotArray obj = new SnapshotArray(length);\n * obj.set(index,val);\n * int param_2 = obj.snap();\n * int param_3 = obj.get(index,snap_id);\n */"}, {"lang": "Python", "langSlug": "python", "code": "class SnapshotArray(object):\n\n    def __init__(self, length):\n        \"\"\"\n        :type length: int\n        \"\"\"\n        \n\n    def set(self, index, val):\n        \"\"\"\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def snap(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def get(self, index, snap_id):\n        \"\"\"\n        :type index: int\n        :type snap_id: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your SnapshotArray object will be instantiated and called as such:\n# obj = SnapshotArray(length)\n# obj.set(index,val)\n# param_2 = obj.snap()\n# param_3 = obj.get(index,snap_id)"}, {"lang": "Python3", "langSlug": "python3", "code": "class SnapshotArray:\n\n    def __init__(self, length: int):\n        \n\n    def set(self, index: int, val: int) -> None:\n        \n\n    def snap(self) -> int:\n        \n\n    def get(self, index: int, snap_id: int) -> int:\n        \n\n\n# Your SnapshotArray object will be instantiated and called as such:\n# obj = SnapshotArray(length)\n# obj.set(index,val)\n# param_2 = obj.snap()\n# param_3 = obj.get(index,snap_id)"}, {"lang": "C", "langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} SnapshotArray;\n\n\nSnapshotArray* snapshotArrayCreate(int length) {\n    \n}\n\nvoid snapshotArraySet(SnapshotArray* obj, int index, int val) {\n    \n}\n\nint snapshotArraySnap(SnapshotArray* obj) {\n    \n}\n\nint snapshotArrayGet(SnapshotArray* obj, int index, int snap_id) {\n    \n}\n\nvoid snapshotArrayFree(SnapshotArray* obj) {\n    \n}\n\n/**\n * Your SnapshotArray struct will be instantiated and called as such:\n * SnapshotArray* obj = snapshotArrayCreate(length);\n * snapshotArraySet(obj, index, val);\n \n * int param_2 = snapshotArraySnap(obj);\n \n * int param_3 = snapshotArrayGet(obj, index, snap_id);\n \n * snapshotArrayFree(obj);\n*/"}, {"lang": "C#", "langSlug": "csharp", "code": "public class SnapshotArray {\n\n    public SnapshotArray(int length) {\n        \n    }\n    \n    public void Set(int index, int val) {\n        \n    }\n    \n    public int Snap() {\n        \n    }\n    \n    public int Get(int index, int snap_id) {\n        \n    }\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * SnapshotArray obj = new SnapshotArray(length);\n * obj.Set(index,val);\n * int param_2 = obj.Snap();\n * int param_3 = obj.Get(index,snap_id);\n */"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number} length\n */\nvar SnapshotArray = function(length) {\n    \n};\n\n/** \n * @param {number} index \n * @param {number} val\n * @return {void}\n */\nSnapshotArray.prototype.set = function(index, val) {\n    \n};\n\n/**\n * @return {number}\n */\nSnapshotArray.prototype.snap = function() {\n    \n};\n\n/** \n * @param {number} index \n * @param {number} snap_id\n * @return {number}\n */\nSnapshotArray.prototype.get = function(index, snap_id) {\n    \n};\n\n/** \n * Your SnapshotArray object will be instantiated and called as such:\n * var obj = new SnapshotArray(length)\n * obj.set(index,val)\n * var param_2 = obj.snap()\n * var param_3 = obj.get(index,snap_id)\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "class SnapshotArray {\n    constructor(length: number) {\n        \n    }\n\n    set(index: number, val: number): void {\n        \n    }\n\n    snap(): number {\n        \n    }\n\n    get(index: number, snap_id: number): number {\n        \n    }\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * var obj = new SnapshotArray(length)\n * obj.set(index,val)\n * var param_2 = obj.snap()\n * var param_3 = obj.get(index,snap_id)\n */"}, {"lang": "PHP", "langSlug": "php", "code": "class SnapshotArray {\n    /**\n     * @param Integer $length\n     */\n    function __construct($length) {\n        \n    }\n  \n    /**\n     * @param Integer $index\n     * @param Integer $val\n     * @return NULL\n     */\n    function set($index, $val) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function snap() {\n        \n    }\n  \n    /**\n     * @param Integer $index\n     * @param Integer $snap_id\n     * @return Integer\n     */\n    function get($index, $snap_id) {\n        \n    }\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * $obj = SnapshotArray($length);\n * $obj->set($index, $val);\n * $ret_2 = $obj->snap();\n * $ret_3 = $obj->get($index, $snap_id);\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "\nclass SnapshotArray {\n\n    init(_ length: Int) {\n        \n    }\n    \n    func set(_ index: Int, _ val: Int) {\n        \n    }\n    \n    func snap() -> Int {\n        \n    }\n    \n    func get(_ index: Int, _ snap_id: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * let obj = SnapshotArray(length)\n * obj.set(index, val)\n * let ret_2: Int = obj.snap()\n * let ret_3: Int = obj.get(index, snap_id)\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class SnapshotArray(length: Int) {\n\n    fun set(index: Int, `val`: Int) {\n        \n    }\n\n    fun snap(): Int {\n        \n    }\n\n    fun get(index: Int, snap_id: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * var obj = SnapshotArray(length)\n * obj.set(index,`val`)\n * var param_2 = obj.snap()\n * var param_3 = obj.get(index,snap_id)\n */"}, {"lang": "Dart", "langSlug": "dart", "code": "class SnapshotArray {\n\n  SnapshotArray(int length) {\n    \n  }\n  \n  void set(int index, int val) {\n    \n  }\n  \n  int snap() {\n    \n  }\n  \n  int get(int index, int snap_id) {\n    \n  }\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * SnapshotArray obj = SnapshotArray(length);\n * obj.set(index,val);\n * int param2 = obj.snap();\n * int param3 = obj.get(index,snap_id);\n */"}, {"lang": "Go", "langSlug": "golang", "code": "type SnapshotArray struct {\n    \n}\n\n\nfunc Constructor(length int) SnapshotArray {\n    \n}\n\n\nfunc (this *SnapshotArray) Set(index int, val int)  {\n    \n}\n\n\nfunc (this *SnapshotArray) Snap() int {\n    \n}\n\n\nfunc (this *SnapshotArray) Get(index int, snap_id int) int {\n    \n}\n\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * obj := Constructor(length);\n * obj.Set(index,val);\n * param_2 := obj.Snap();\n * param_3 := obj.Get(index,snap_id);\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "class SnapshotArray\n\n=begin\n    :type length: Integer\n=end\n    def initialize(length)\n        \n    end\n\n\n=begin\n    :type index: Integer\n    :type val: Integer\n    :rtype: Void\n=end\n    def set(index, val)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def snap()\n        \n    end\n\n\n=begin\n    :type index: Integer\n    :type snap_id: Integer\n    :rtype: Integer\n=end\n    def get(index, snap_id)\n        \n    end\n\n\nend\n\n# Your SnapshotArray object will be instantiated and called as such:\n# obj = SnapshotArray.new(length)\n# obj.set(index, val)\n# param_2 = obj.snap()\n# param_3 = obj.get(index, snap_id)"}, {"lang": "Scala", "langSlug": "scala", "code": "class SnapshotArray(_length: Int) {\n\n    def set(index: Int, `val`: Int): Unit = {\n        \n    }\n\n    def snap(): Int = {\n        \n    }\n\n    def get(index: Int, snap_id: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * val obj = new SnapshotArray(length)\n * obj.set(index,`val`)\n * val param_2 = obj.snap()\n * val param_3 = obj.get(index,snap_id)\n */"}, {"lang": "Rust", "langSlug": "rust", "code": "struct SnapshotArray {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl SnapshotArray {\n\n    fn new(length: i32) -> Self {\n        \n    }\n    \n    fn set(&self, index: i32, val: i32) {\n        \n    }\n    \n    fn snap(&self) -> i32 {\n        \n    }\n    \n    fn get(&self, index: i32, snap_id: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your SnapshotArray object will be instantiated and called as such:\n * let obj = SnapshotArray::new(length);\n * obj.set(index, val);\n * let ret_2: i32 = obj.snap();\n * let ret_3: i32 = obj.get(index, snap_id);\n */"}, {"lang": "Racket", "langSlug": "racket", "code": "(define snapshot-array%\n  (class object%\n    (super-new)\n    \n    ; length : exact-integer?\n    (init-field\n      length)\n    \n    ; set : exact-integer? exact-integer? -> void?\n    (define/public (set index val)\n      )\n    ; snap : -> exact-integer?\n    (define/public (snap)\n      )\n    ; get : exact-integer? exact-integer? -> exact-integer?\n    (define/public (get index snap_id)\n      )))\n\n;; Your snapshot-array% object will be instantiated and called as such:\n;; (define obj (new snapshot-array% [length length]))\n;; (send obj set index val)\n;; (define param_2 (send obj snap))\n;; (define param_3 (send obj get index snap_id))"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec snapshot_array_init_(Length :: integer()) -> any().\nsnapshot_array_init_(Length) ->\n  .\n\n-spec snapshot_array_set(Index :: integer(), Val :: integer()) -> any().\nsnapshot_array_set(Index, Val) ->\n  .\n\n-spec snapshot_array_snap() -> integer().\nsnapshot_array_snap() ->\n  .\n\n-spec snapshot_array_get(Index :: integer(), Snap_id :: integer()) -> integer().\nsnapshot_array_get(Index, Snap_id) ->\n  .\n\n\n%% Your functions will be called as such:\n%% snapshot_array_init_(Length),\n%% snapshot_array_set(Index, Val),\n%% Param_2 = snapshot_array_snap(),\n%% Param_3 = snapshot_array_get(Index, Snap_id),\n\n%% snapshot_array_init_ will be called before every test case, in which you can do some necessary initializations."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule SnapshotArray do\n  @spec init_(length :: integer) :: any\n  def init_(length) do\n    \n  end\n\n  @spec set(index :: integer, val :: integer) :: any\n  def set(index, val) do\n    \n  end\n\n  @spec snap() :: integer\n  def snap() do\n    \n  end\n\n  @spec get(index :: integer, snap_id :: integer) :: integer\n  def get(index, snap_id) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SnapshotArray.init_(length)\n# SnapshotArray.set(index, val)\n# param_2 = SnapshotArray.snap()\n# param_3 = SnapshotArray.get(index, snap_id)\n\n# SnapshotArray.init_ will be called before every test case, in which you can do some necessary initializations."}], "similarQuestionList": []}