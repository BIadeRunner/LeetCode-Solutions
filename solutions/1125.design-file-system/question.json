{"question_id": "1125", "problem_slug": "design-file-system", "problem_title": "Design File System", "content": "You are asked to design a file system that allows you to create new paths and associate them with different values.\nThe format of a path is one or more concatenated strings of the form: / followed by one or more lowercase English letters. For example, \"/leetcode\" and \"/leetcode/problems\" are valid paths while an empty string \"\" and \"/\" are not.\nImplement the FileSystem class:\n\nbool createPath(string path, int value) Creates a new path and associates a value to it if possible and returns true. Returns false if the path already exists or its parent path doesn't exist.\nint get(string path) Returns the value associated with path or returns -1 if the path doesn't exist.\n\n \nExample 1:\n\nInput: \n[\"FileSystem\",\"createPath\",\"get\"]\n[[],[\"/a\",1],[\"/a\"]]\nOutput: \n[null,true,1]\nExplanation: \nFileSystem fileSystem = new FileSystem();\n\nfileSystem.createPath(\"/a\", 1); // return true\nfileSystem.get(\"/a\"); // return 1\n\nExample 2:\n\nInput: \n[\"FileSystem\",\"createPath\",\"createPath\",\"get\",\"createPath\",\"get\"]\n[[],[\"/leet\",1],[\"/leet/code\",2],[\"/leet/code\"],[\"/c/d\",1],[\"/c\"]]\nOutput: \n[null,true,true,2,false,-1]\nExplanation: \nFileSystem fileSystem = new FileSystem();\n\nfileSystem.createPath(\"/leet\", 1); // return true\nfileSystem.createPath(\"/leet/code\", 2); // return true\nfileSystem.get(\"/leet/code\"); // return 2\nfileSystem.createPath(\"/c/d\", 1); // return false because the parent path \"/c\" doesn't exist.\nfileSystem.get(\"/c\"); // return -1 because this path doesn't exist.\n\n \nConstraints:\n\n2 <= path.length <= 100\n1 <= value <= 109\nEach path is valid and consists of lowercase English letters and '/'.\nAt most 104 calls in total will be made to createPath and get.\n\n", "hints": ["What if you think of a tree hierarchy for the files?.", "A path is a node in the tree.", "Use a hash table to store the valid paths along with their values."], "exampleTestcases": "[\"FileSystem\",\"createPath\",\"get\"]\n[[],[\"/a\",1],[\"/a\"]]\n[\"FileSystem\",\"createPath\",\"createPath\",\"get\",\"createPath\",\"get\"]\n[[],[\"/leet\",1],[\"/leet/code\",2],[\"/leet/code\"],[\"/c/d\",1],[\"/c\"]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class FileSystem {\npublic:\n    FileSystem() {\n        \n    }\n    \n    bool createPath(string path, int value) {\n        \n    }\n    \n    int get(string path) {\n        \n    }\n};\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem* obj = new FileSystem();\n * bool param_1 = obj->createPath(path,value);\n * int param_2 = obj->get(path);\n */"}, "Java": {"langSlug": "java", "code": "class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public boolean createPath(String path, int value) {\n        \n    }\n    \n    public int get(String path) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * boolean param_1 = obj.createPath(path,value);\n * int param_2 = obj.get(path);\n */"}, "Python": {"langSlug": "python", "code": "class FileSystem(object):\n\n    def __init__(self):\n        \n\n    def createPath(self, path, value):\n        \"\"\"\n        :type path: str\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def get(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.createPath(path,value)\n# param_2 = obj.get(path)"}, "Python3": {"langSlug": "python3", "code": "class FileSystem:\n\n    def __init__(self):\n        \n\n    def createPath(self, path: str, value: int) -> bool:\n        \n\n    def get(self, path: str) -> int:\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.createPath(path,value)\n# param_2 = obj.get(path)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} FileSystem;\n\n\nFileSystem* fileSystemCreate() {\n    \n}\n\nbool fileSystemCreatePath(FileSystem* obj, char* path, int value) {\n    \n}\n\nint fileSystemGet(FileSystem* obj, char* path) {\n    \n}\n\nvoid fileSystemFree(FileSystem* obj) {\n    \n}\n\n/**\n * Your FileSystem struct will be instantiated and called as such:\n * FileSystem* obj = fileSystemCreate();\n * bool param_1 = fileSystemCreatePath(obj, path, value);\n \n * int param_2 = fileSystemGet(obj, path);\n \n * fileSystemFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public bool CreatePath(string path, int value) {\n        \n    }\n    \n    public int Get(string path) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * bool param_1 = obj.CreatePath(path,value);\n * int param_2 = obj.Get(path);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "\nvar FileSystem = function() {\n    \n};\n\n/** \n * @param {string} path \n * @param {number} value\n * @return {boolean}\n */\nFileSystem.prototype.createPath = function(path, value) {\n    \n};\n\n/** \n * @param {string} path\n * @return {number}\n */\nFileSystem.prototype.get = function(path) {\n    \n};\n\n/** \n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class FileSystem {\n    constructor() {\n        \n    }\n\n    createPath(path: string, value: number): boolean {\n        \n    }\n\n    get(path: string): number {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */"}, "PHP": {"langSlug": "php", "code": "class FileSystem {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @param Integer $value\n     * @return Boolean\n     */\n    function createPath($path, $value) {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @return Integer\n     */\n    function get($path) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * $obj = FileSystem();\n * $ret_1 = $obj->createPath($path, $value);\n * $ret_2 = $obj->get($path);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass FileSystem {\n\n    init() {\n        \n    }\n    \n    func createPath(_ path: String, _ value: Int) -> Bool {\n        \n    }\n    \n    func get(_ path: String) -> Int {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem()\n * let ret_1: Bool = obj.createPath(path, value)\n * let ret_2: Int = obj.get(path)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class FileSystem() {\n\n    fun createPath(path: String, value: Int): Boolean {\n        \n    }\n\n    fun get(path: String): Int {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = FileSystem()\n * var param_1 = obj.createPath(path,value)\n * var param_2 = obj.get(path)\n */"}, "Dart": {"langSlug": "dart", "code": "class FileSystem {\n\n  FileSystem() {\n    \n  }\n  \n  bool createPath(String path, int value) {\n    \n  }\n  \n  int get(String path) {\n    \n  }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = FileSystem();\n * bool param1 = obj.createPath(path,value);\n * int param2 = obj.get(path);\n */"}, "Go": {"langSlug": "golang", "code": "type FileSystem struct {\n    \n}\n\n\nfunc Constructor() FileSystem {\n    \n}\n\n\nfunc (this *FileSystem) CreatePath(path string, value int) bool {\n    \n}\n\n\nfunc (this *FileSystem) Get(path string) int {\n    \n}\n\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.CreatePath(path,value);\n * param_2 := obj.Get(path);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class FileSystem\n    def initialize()\n        \n    end\n\n\n=begin\n    :type path: String\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def create_path(path, value)\n        \n    end\n\n\n=begin\n    :type path: String\n    :rtype: Integer\n=end\n    def get(path)\n        \n    end\n\n\nend\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem.new()\n# param_1 = obj.create_path(path, value)\n# param_2 = obj.get(path)"}, "Scala": {"langSlug": "scala", "code": "class FileSystem() {\n\n    def createPath(path: String, value: Int): Boolean = {\n        \n    }\n\n    def get(path: String): Int = {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * val obj = new FileSystem()\n * val param_1 = obj.createPath(path,value)\n * val param_2 = obj.get(path)\n */"}, "Rust": {"langSlug": "rust", "code": "struct FileSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl FileSystem {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn create_path(&self, path: String, value: i32) -> bool {\n        \n    }\n    \n    fn get(&self, path: String) -> i32 {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem::new();\n * let ret_1: bool = obj.create_path(path, value);\n * let ret_2: i32 = obj.get(path);\n */"}, "Racket": {"langSlug": "racket", "code": "(define file-system%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; create-path : string? exact-integer? -> boolean?\n    (define/public (create-path path value)\n      )\n    ; get : string? -> exact-integer?\n    (define/public (get path)\n      )))\n\n;; Your file-system% object will be instantiated and called as such:\n;; (define obj (new file-system%))\n;; (define param_1 (send obj create-path path value))\n;; (define param_2 (send obj get path))"}, "Erlang": {"langSlug": "erlang", "code": "-spec file_system_init_() -> any().\nfile_system_init_() ->\n  .\n\n-spec file_system_create_path(Path :: unicode:unicode_binary(), Value :: integer()) -> boolean().\nfile_system_create_path(Path, Value) ->\n  .\n\n-spec file_system_get(Path :: unicode:unicode_binary()) -> integer().\nfile_system_get(Path) ->\n  .\n\n\n%% Your functions will be called as such:\n%% file_system_init_(),\n%% Param_1 = file_system_create_path(Path, Value),\n%% Param_2 = file_system_get(Path),\n\n%% file_system_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule FileSystem do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec create_path(path :: String.t, value :: integer) :: boolean\n  def create_path(path, value) do\n    \n  end\n\n  @spec get(path :: String.t) :: integer\n  def get(path) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# FileSystem.init_()\n# param_1 = FileSystem.create_path(path, value)\n# param_2 = FileSystem.get(path)\n\n# FileSystem.init_ will be called before every test case, in which you can do some necessary initializations."}}}