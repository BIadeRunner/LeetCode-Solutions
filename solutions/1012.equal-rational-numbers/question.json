{"question_id": "1012", "problem_slug": "equal-rational-numbers", "problem_title": "Equal Rational Numbers", "content": "Given two strings s and t, each of which represents a non-negative rational number, return true if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\nA rational number can be represented using up to three parts: <IntegerPart>, <NonRepeatingPart>, and a <RepeatingPart>. The number will be represented in one of the following three ways:\n\n<IntegerPart>\n\nFor example, 12, 0, and 123.\n\n\n<IntegerPart><.><NonRepeatingPart>\n\nFor example, 0.5, 1., 2.12, and 123.0001.\n\n\n<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>\n\nFor example, 0.1(6), 1.(9), 123.00(1212).\n\n\n\nThe repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:\n\n1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66).\n\n \nExample 1:\n\nInput: s = \"0.(52)\", t = \"0.5(25)\"\nOutput: true\nExplanation: Because \"0.(52)\" represents 0.52525252..., and \"0.5(25)\" represents 0.52525252525..... , the strings represent the same number.\n\nExample 2:\n\nInput: s = \"0.1666(6)\", t = \"0.166(66)\"\nOutput: true\n\nExample 3:\n\nInput: s = \"0.9(9)\", t = \"1.\"\nOutput: true\nExplanation: \"0.9(9)\" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]\n\"1.\" represents the number 1, which is formed correctly: (IntegerPart) = \"1\" and (NonRepeatingPart) = \"\".\n\n \nConstraints:\n\nEach part consists only of digits.\nThe <IntegerPart> does not have leading zeros (except for the zero itself).\n1 <= <IntegerPart>.length <= 4\n0 <= <NonRepeatingPart>.length <= 4\n1 <= <RepeatingPart>.length <= 4\n\n", "hints": [], "exampleTestcases": "\"0.(52)\"\n\"0.5(25)\"\n\"0.1666(6)\"\n\"0.166(66)\"\n\"0.9(9)\"\n\"1.\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool isRationalEqual(string s, string t) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean isRationalEqual(String s, String t) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def isRationalEqual(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def isRationalEqual(self, s: str, t: str) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool isRationalEqual(char* s, char* t) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool IsRationalEqual(string s, string t) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isRationalEqual = function(s, t) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function isRationalEqual(s: string, t: string): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return Boolean\n     */\n    function isRationalEqual($s, $t) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func isRationalEqual(_ s: String, _ t: String) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun isRationalEqual(s: String, t: String): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool isRationalEqual(String s, String t) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func isRationalEqual(s string, t string) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} s\n# @param {String} t\n# @return {Boolean}\ndef is_rational_equal(s, t)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def isRationalEqual(s: String, t: String): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn is_rational_equal(s: String, t: String) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (is-rational-equal s t)\n  (-> string? string? boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec is_rational_equal(S :: unicode:unicode_binary(), T :: unicode:unicode_binary()) -> boolean().\nis_rational_equal(S, T) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec is_rational_equal(s :: String.t, t :: String.t) :: boolean\n  def is_rational_equal(s, t) do\n    \n  end\nend"}}}