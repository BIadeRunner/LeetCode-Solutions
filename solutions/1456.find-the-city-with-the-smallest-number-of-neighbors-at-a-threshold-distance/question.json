{"question_id": "1456", "problem_slug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance", "problem_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "content": "There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.\nNotice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.\n \nExample 1:\n\n\nInput: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\nOutput: 3\nExplanation: The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> [City 1, City 2] \nCity 1 -> [City 0, City 2, City 3] \nCity 2 -> [City 0, City 1, City 3] \nCity 3 -> [City 1, City 2] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\nExample 2:\n\n\nInput: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\nOutput: 0\nExplanation: The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> [City 1] \nCity 1 -> [City 0, City 4] \nCity 2 -> [City 3, City 4] \nCity 3 -> [City 2, City 4]\nCity 4 -> [City 1, City 2, City 3] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n \nConstraints:\n\n2 <= n <= 100\n1 <= edges.length <= n * (n - 1) / 2\nedges[i].length == 3\n0 <= fromi < toi < n\n1 <= weighti, distanceThreshold <= 10^4\nAll pairs (fromi, toi) are distinct.\n\n", "hints": ["Use Floyd-Warshall's algorithm to compute any-point to any-point distances. (Or can also do Dijkstra from every node due to the weights are non-negative).", "For each city calculate the number of reachable cities within the threshold, then search for the optimal city."], "exampleTestcases": "4\n[[0,1,3],[1,2,1],[1,3,4],[2,3,1]]\n4\n5\n[[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]]\n2", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def findTheCity(self, n, edges, distanceThreshold):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type distanceThreshold: int\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n        "}, "C": {"langSlug": "c", "code": "int findTheCity(int n, int** edges, int edgesSize, int* edgesColSize, int distanceThreshold) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int FindTheCity(int n, int[][] edges, int distanceThreshold) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} distanceThreshold\n * @return {number}\n */\nvar findTheCity = function(n, edges, distanceThreshold) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function findTheCity(n: number, edges: number[][], distanceThreshold: number): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer $distanceThreshold\n     * @return Integer\n     */\n    function findTheCity($n, $edges, $distanceThreshold) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func findTheCity(_ n: Int, _ edges: [[Int]], _ distanceThreshold: Int) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun findTheCity(n: Int, edges: Array<IntArray>, distanceThreshold: Int): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int findTheCity(int n, List<List<int>> edges, int distanceThreshold) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func findTheCity(n int, edges [][]int, distanceThreshold int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer} distance_threshold\n# @return {Integer}\ndef find_the_city(n, edges, distance_threshold)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def findTheCity(n: Int, edges: Array[Array[Int]], distanceThreshold: Int): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn find_the_city(n: i32, edges: Vec<Vec<i32>>, distance_threshold: i32) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (find-the-city n edges distanceThreshold)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec find_the_city(N :: integer(), Edges :: [[integer()]], DistanceThreshold :: integer()) -> integer().\nfind_the_city(N, Edges, DistanceThreshold) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec find_the_city(n :: integer, edges :: [[integer]], distance_threshold :: integer) :: integer\n  def find_the_city(n, edges, distance_threshold) do\n    \n  end\nend"}}}