{"question_id": "1118", "problem_slug": "divide-array-into-increasing-sequences", "problem_title": "Divide Array Into Increasing Sequences", "content": "Given an integer array nums sorted in non-decreasing order and an integer k, return true if this array can be divided into one or more disjoint increasing subsequences of length at least k, or false otherwise.\n \nExample 1:\n\nInput: nums = [1,2,2,3,3,4,4], k = 3\nOutput: true\nExplanation: The array can be divided into two subsequences [1,2,3,4] and [2,3,4] with lengths at least 3 each.\n\nExample 2:\n\nInput: nums = [5,6,6,7,8], k = 3\nOutput: false\nExplanation: There is no way to divide the array using the conditions required.\n\n \nConstraints:\n\n1 <= k <= nums.length <= 105\n1 <= nums[i] <= 105\nnums is sorted in non-decreasing order.\n\n", "hints": ["Think in the frequency of the numbers and how this affects the number of sequences needed.", "What is the minimum number of sequences we need to form? Considering frequency of the numbers.", "Think about the least number of sequences to maximize the lengths.", "The number of sequences needed is equal to the maximum frequency of an element.", "How to put the other elements into sequences ? Think in a greedy approach."], "exampleTestcases": "[1,2,2,3,3,4,4]\n3\n[5,6,6,7,8]\n3", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool canDivideIntoSubsequences(vector<int>& nums, int k) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean canDivideIntoSubsequences(int[] nums, int k) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def canDivideIntoSubsequences(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def canDivideIntoSubsequences(self, nums: List[int], k: int) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool canDivideIntoSubsequences(int* nums, int numsSize, int k) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool CanDivideIntoSubsequences(int[] nums, int k) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nvar canDivideIntoSubsequences = function(nums, k) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function canDivideIntoSubsequences(nums: number[], k: number): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Boolean\n     */\n    function canDivideIntoSubsequences($nums, $k) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func canDivideIntoSubsequences(_ nums: [Int], _ k: Int) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun canDivideIntoSubsequences(nums: IntArray, k: Int): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool canDivideIntoSubsequences(List<int> nums, int k) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func canDivideIntoSubsequences(nums []int, k int) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Boolean}\ndef can_divide_into_subsequences(nums, k)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def canDivideIntoSubsequences(nums: Array[Int], k: Int): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn can_divide_into_subsequences(nums: Vec<i32>, k: i32) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (can-divide-into-subsequences nums k)\n  (-> (listof exact-integer?) exact-integer? boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec can_divide_into_subsequences(Nums :: [integer()], K :: integer()) -> boolean().\ncan_divide_into_subsequences(Nums, K) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec can_divide_into_subsequences(nums :: [integer], k :: integer) :: boolean\n  def can_divide_into_subsequences(nums, k) do\n    \n  end\nend"}}}