{"question_id": "2587", "problem_slug": "design-memory-allocator", "problem_title": "Design Memory Allocator", "content": "You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.\nYou have a memory allocator with the following functionalities:\n\nAllocate a block of size consecutive free memory units and assign it the id mID.\nFree all memory units with the given id mID.\n\nNote that:\n\nMultiple blocks can be allocated to the same mID.\nYou should free all the memory units with mID, even if they were allocated in different blocks.\n\nImplement the Allocator class:\n\nAllocator(int n) Initializes an Allocator object with a memory array of size n.\nint allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.\nint free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.\n\n \nExample 1:\n\nInput\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\nOutput\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\n\nExplanation\nAllocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.\nloc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.\nloc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.\nloc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.\nloc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.\nloc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.\nloc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.\nloc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.\nloc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.\nloc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.\nloc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.\n\n \nConstraints:\n\n1 <= n, size, mID <= 1000\nAt most 1000 calls will be made to allocate and free.\n\n", "hints": ["Can you simulate the process?", "Use brute force to find the leftmost free block and free each occupied memory unit"], "exampleTestcases": "[\"Allocator\",\"allocate\",\"allocate\",\"allocate\",\"free\",\"allocate\",\"allocate\",\"allocate\",\"free\",\"allocate\",\"free\"]\n[[10],[1,1],[1,2],[1,3],[2],[3,4],[1,1],[1,1],[1],[10,2],[7]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Allocator {\npublic:\n    Allocator(int n) {\n        \n    }\n    \n    int allocate(int size, int mID) {\n        \n    }\n    \n    int free(int mID) {\n        \n    }\n};\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * Allocator* obj = new Allocator(n);\n * int param_1 = obj->allocate(size,mID);\n * int param_2 = obj->free(mID);\n */"}, "Java": {"langSlug": "java", "code": "class Allocator {\n\n    public Allocator(int n) {\n        \n    }\n    \n    public int allocate(int size, int mID) {\n        \n    }\n    \n    public int free(int mID) {\n        \n    }\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * Allocator obj = new Allocator(n);\n * int param_1 = obj.allocate(size,mID);\n * int param_2 = obj.free(mID);\n */"}, "Python": {"langSlug": "python", "code": "class Allocator(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        \n\n    def allocate(self, size, mID):\n        \"\"\"\n        :type size: int\n        :type mID: int\n        :rtype: int\n        \"\"\"\n        \n\n    def free(self, mID):\n        \"\"\"\n        :type mID: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator(n)\n# param_1 = obj.allocate(size,mID)\n# param_2 = obj.free(mID)"}, "Python3": {"langSlug": "python3", "code": "class Allocator:\n\n    def __init__(self, n: int):\n        \n\n    def allocate(self, size: int, mID: int) -> int:\n        \n\n    def free(self, mID: int) -> int:\n        \n\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator(n)\n# param_1 = obj.allocate(size,mID)\n# param_2 = obj.free(mID)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} Allocator;\n\n\nAllocator* allocatorCreate(int n) {\n    \n}\n\nint allocatorAllocate(Allocator* obj, int size, int mID) {\n    \n}\n\nint allocatorFree(Allocator* obj, int mID) {\n    \n}\n\nvoid allocatorFree(Allocator* obj) {\n    \n}\n\n/**\n * Your Allocator struct will be instantiated and called as such:\n * Allocator* obj = allocatorCreate(n);\n * int param_1 = allocatorAllocate(obj, size, mID);\n \n * int param_2 = allocatorFree(obj, mID);\n \n * allocatorFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class Allocator {\n\n    public Allocator(int n) {\n        \n    }\n    \n    public int Allocate(int size, int mID) {\n        \n    }\n    \n    public int Free(int mID) {\n        \n    }\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * Allocator obj = new Allocator(n);\n * int param_1 = obj.Allocate(size,mID);\n * int param_2 = obj.Free(mID);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n */\nvar Allocator = function(n) {\n    \n};\n\n/** \n * @param {number} size \n * @param {number} mID\n * @return {number}\n */\nAllocator.prototype.allocate = function(size, mID) {\n    \n};\n\n/** \n * @param {number} mID\n * @return {number}\n */\nAllocator.prototype.free = function(mID) {\n    \n};\n\n/** \n * Your Allocator object will be instantiated and called as such:\n * var obj = new Allocator(n)\n * var param_1 = obj.allocate(size,mID)\n * var param_2 = obj.free(mID)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class Allocator {\n    constructor(n: number) {\n        \n    }\n\n    allocate(size: number, mID: number): number {\n        \n    }\n\n    free(mID: number): number {\n        \n    }\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * var obj = new Allocator(n)\n * var param_1 = obj.allocate(size,mID)\n * var param_2 = obj.free(mID)\n */"}, "PHP": {"langSlug": "php", "code": "class Allocator {\n    /**\n     * @param Integer $n\n     */\n    function __construct($n) {\n        \n    }\n  \n    /**\n     * @param Integer $size\n     * @param Integer $mID\n     * @return Integer\n     */\n    function allocate($size, $mID) {\n        \n    }\n  \n    /**\n     * @param Integer $mID\n     * @return Integer\n     */\n    function free($mID) {\n        \n    }\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * $obj = Allocator($n);\n * $ret_1 = $obj->allocate($size, $mID);\n * $ret_2 = $obj->free($mID);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass Allocator {\n\n    init(_ n: Int) {\n        \n    }\n    \n    func allocate(_ size: Int, _ mID: Int) -> Int {\n        \n    }\n    \n    func free(_ mID: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * let obj = Allocator(n)\n * let ret_1: Int = obj.allocate(size, mID)\n * let ret_2: Int = obj.free(mID)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class Allocator(n: Int) {\n\n    fun allocate(size: Int, mID: Int): Int {\n        \n    }\n\n    fun free(mID: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * var obj = Allocator(n)\n * var param_1 = obj.allocate(size,mID)\n * var param_2 = obj.free(mID)\n */"}, "Dart": {"langSlug": "dart", "code": "class Allocator {\n\n  Allocator(int n) {\n    \n  }\n  \n  int allocate(int size, int mID) {\n    \n  }\n  \n  int free(int mID) {\n    \n  }\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * Allocator obj = Allocator(n);\n * int param1 = obj.allocate(size,mID);\n * int param2 = obj.free(mID);\n */"}, "Go": {"langSlug": "golang", "code": "type Allocator struct {\n    \n}\n\n\nfunc Constructor(n int) Allocator {\n    \n}\n\n\nfunc (this *Allocator) Allocate(size int, mID int) int {\n    \n}\n\n\nfunc (this *Allocator) Free(mID int) int {\n    \n}\n\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * obj := Constructor(n);\n * param_1 := obj.Allocate(size,mID);\n * param_2 := obj.Free(mID);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class Allocator\n\n=begin\n    :type n: Integer\n=end\n    def initialize(n)\n        \n    end\n\n\n=begin\n    :type size: Integer\n    :type m_id: Integer\n    :rtype: Integer\n=end\n    def allocate(size, m_id)\n        \n    end\n\n\n=begin\n    :type m_id: Integer\n    :rtype: Integer\n=end\n    def free(m_id)\n        \n    end\n\n\nend\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator.new(n)\n# param_1 = obj.allocate(size, m_id)\n# param_2 = obj.free(m_id)"}, "Scala": {"langSlug": "scala", "code": "class Allocator(_n: Int) {\n\n    def allocate(size: Int, mID: Int): Int = {\n        \n    }\n\n    def free(mID: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * val obj = new Allocator(n)\n * val param_1 = obj.allocate(size,mID)\n * val param_2 = obj.free(mID)\n */"}, "Rust": {"langSlug": "rust", "code": "struct Allocator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Allocator {\n\n    fn new(n: i32) -> Self {\n        \n    }\n    \n    fn allocate(&self, size: i32, m_id: i32) -> i32 {\n        \n    }\n    \n    fn free(&self, m_id: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * let obj = Allocator::new(n);\n * let ret_1: i32 = obj.allocate(size, mID);\n * let ret_2: i32 = obj.free(mID);\n */"}, "Racket": {"langSlug": "racket", "code": "(define allocator%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    (init-field\n      n)\n    \n    ; allocate : exact-integer? exact-integer? -> exact-integer?\n    (define/public (allocate size m-id)\n      )\n    ; free : exact-integer? -> exact-integer?\n    (define/public (free m-id)\n      )))\n\n;; Your allocator% object will be instantiated and called as such:\n;; (define obj (new allocator% [n n]))\n;; (define param_1 (send obj allocate size m-id))\n;; (define param_2 (send obj free m-id))"}, "Erlang": {"langSlug": "erlang", "code": "-spec allocator_init_(N :: integer()) -> any().\nallocator_init_(N) ->\n  .\n\n-spec allocator_allocate(Size :: integer(), MID :: integer()) -> integer().\nallocator_allocate(Size, MID) ->\n  .\n\n-spec allocator_free(MID :: integer()) -> integer().\nallocator_free(MID) ->\n  .\n\n\n%% Your functions will be called as such:\n%% allocator_init_(N),\n%% Param_1 = allocator_allocate(Size, MID),\n%% Param_2 = allocator_free(MID),\n\n%% allocator_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Allocator do\n  @spec init_(n :: integer) :: any\n  def init_(n) do\n    \n  end\n\n  @spec allocate(size :: integer, m_id :: integer) :: integer\n  def allocate(size, m_id) do\n    \n  end\n\n  @spec free(m_id :: integer) :: integer\n  def free(m_id) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Allocator.init_(n)\n# param_1 = Allocator.allocate(size, m_id)\n# param_2 = Allocator.free(m_id)\n\n# Allocator.init_ will be called before every test case, in which you can do some necessary initializations."}}}