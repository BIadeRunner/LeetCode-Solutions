{"question_id": "636", "problem_slug": "exclusive-time-of-functions", "problem_title": "Exclusive Time of Functions", "content": "On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1.\nFunction calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.\nYou are given a list logs, where logs[i] represents the ith log message formatted as a string \"{function_id}:{\"start\" | \"end\"}:{timestamp}\". For example, \"0:start:3\" means a function call with function ID 0 started at the beginning of timestamp 3, and \"1:end:2\" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively.\nA function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.\nReturn the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.\n \nExample 1:\n\n\nInput: n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\nOutput: [3,4]\nExplanation:\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n\nExample 2:\n\nInput: n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\nOutput: [8]\nExplanation:\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n\nExample 3:\n\nInput: n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\nOutput: [7,1]\nExplanation:\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n\n \nConstraints:\n\n1 <= n <= 100\n1 <= logs.length <= 500\n0 <= function_id < n\n0 <= timestamp <= 109\nNo two start events will happen at the same timestamp.\nNo two end events will happen at the same timestamp.\nEach function has an \"end\" log for each \"start\" log.\n\n", "hints": [], "exampleTestcases": "2\n[\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n1\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n2\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[] exclusiveTime(int n, List<String> logs) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* exclusiveTime(int n, char** logs, int logsSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[] ExclusiveTime(int n, IList<string> logs) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {string[]} logs\n * @return {number[]}\n */\nvar exclusiveTime = function(n, logs) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function exclusiveTime(n: number, logs: string[]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param String[] $logs\n     * @return Integer[]\n     */\n    function exclusiveTime($n, $logs) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun exclusiveTime(n: Int, logs: List<String>): IntArray {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> exclusiveTime(int n, List<String> logs) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func exclusiveTime(n int, logs []string) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {String[]} logs\n# @return {Integer[]}\ndef exclusive_time(n, logs)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def exclusiveTime(n: Int, logs: List[String]): Array[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn exclusive_time(n: i32, logs: Vec<String>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (exclusive-time n logs)\n  (-> exact-integer? (listof string?) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec exclusive_time(N :: integer(), Logs :: [unicode:unicode_binary()]) -> [integer()].\nexclusive_time(N, Logs) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec exclusive_time(n :: integer, logs :: [String.t]) :: [integer]\n  def exclusive_time(n, logs) do\n    \n  end\nend"}}}