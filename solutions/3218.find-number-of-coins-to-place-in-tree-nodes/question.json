{"questionId": "3218", "acRate": 37.144206413944104, "difficulty": "Hard", "freqBar": 37.077851064684566, "frontendQuestionId": "2973", "paidOnly": false, "status": "ac", "title": "Find Number of Coins to Place in Tree Nodes", "topicTags": [{"name": "Dynamic Programming", "id": "VG9waWNUYWdOb2RlOjEz", "slug": "dynamic-programming"}, {"name": "Tree", "id": "VG9waWNUYWdOb2RlOjIw", "slug": "tree"}, {"name": "Depth-First Search", "id": "VG9waWNUYWdOb2RlOjIx", "slug": "depth-first-search"}, {"name": "Sorting", "id": "VG9waWNUYWdOb2RlOjYxMDQ5", "slug": "sorting"}, {"name": "Heap (Priority Queue)", "id": "VG9waWNUYWdOb2RlOjYxMDUw", "slug": "heap-priority-queue"}], "titleSlug": "find-number-of-coins-to-place-in-tree-nodes", "content": "<p>You are given an <strong>undirected</strong> tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, and rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the tree.</p>\n\n<p>You are also given a <strong>0-indexed</strong> integer array <code>cost</code> of length <code>n</code>, where <code>cost[i]</code> is the <strong>cost</strong> assigned to the <code>i<sup>th</sup></code> node.</p>\n\n<p>You need to place some coins on every node of the tree. The number of coins to be placed at node <code>i</code> can be calculated as:</p>\n\n<ul>\n\t<li>If size of the subtree of node <code>i</code> is less than <code>3</code>, place <code>1</code> coin.</li>\n\t<li>Otherwise, place an amount of coins equal to the <strong>maximum</strong> product of cost values assigned to <code>3</code> distinct nodes in the subtree of node <code>i</code>. If this product is <strong>negative</strong>, place <code>0</code> coins.</li>\n</ul>\n\n<p>Return <em>an array </em><code>coin</code><em> of size </em><code>n</code><em> such that </em><code>coin[i]</code><em> is the number of coins placed at node </em><code>i</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012641.png\" style=\"width: 600px; height: 233px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2],[0,3],[0,4],[0,5]], cost = [1,2,3,4,5,6]\n<strong>Output:</strong> [120,1,1,1,1,1]\n<strong>Explanation:</strong> For node 0 place 6 * 5 * 4 = 120 coins. All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012614.png\" style=\"width: 800px; height: 374px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]], cost = [1,4,2,3,5,7,8,-4,2]\n<strong>Output:</strong> [280,140,32,1,1,1,1,1,1]\n<strong>Explanation:</strong> The coins placed on each node are:\n- Place 8 * 7 * 5 = 280 coins on node 0.\n- Place 7 * 5 * 4 = 140 coins on node 1.\n- Place 8 * 2 * 2 = 32 coins on node 2.\n- All other nodes are leaves with subtree of size 1, place 1 coin on each of them.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/11/09/screenshot-2023-11-10-012513.png\" style=\"width: 300px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> edges = [[0,1],[0,2]], cost = [1,2,-2]\n<strong>Output:</strong> [0,1,1]\n<strong>Explanation:</strong> Node 1 and 2 are leaves with subtree of size 1, place 1 coin on each of them. For node 0 the only possible product of cost is 2 * 1 * -2 = -4. Hence place 0 coins on node 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= |cost[i]| &lt;= 10<sup>4</sup></code></li>\n\t<li>The input is generated such that <code>edges</code> represents a valid tree.</li>\n</ul>\n", "hints": ["Use DFS on the whole tree, for each subtree, save the largest three positive costs and the smallest three non-positive costs. This can be done by using two Heaps with the size of at most three.", "You need to store at most six values at each subtree.", "If there are more than three values in total, we can sort them. Let\u2019s call the resultant array <code>A</code>, the maximum product of three is <code>max(A[0] * A[1] * A[n - 1], A[n - 1] * A[n - 2] * A[n - 3])</code>. Don\u2019t forget to set the result to <code>0</code> if the value is negative.", "If there are less than three values for a subtree, set its result to <code>1</code>."], "exampleTestcases": "[[0,1],[0,2],[0,3],[0,4],[0,5]]\n[1,2,3,4,5,6]\n[[0,1],[0,2],[1,3],[1,4],[1,5],[2,6],[2,7],[2,8]]\n[1,4,2,3,5,7,8,-4,2]\n[[0,1],[0,2]]\n[1,2,-2]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<long long> placedCoins(vector<vector<int>>& edges, vector<int>& cost) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public long[] placedCoins(int[][] edges, int[] cost) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def placedCoins(self, edges, cost):\n        \"\"\"\n        :type edges: List[List[int]]\n        :type cost: List[int]\n        :rtype: List[int]\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nlong long* placedCoins(int** edges, int edgesSize, int* edgesColSize, int* cost, int costSize, int* returnSize) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public long[] PlacedCoins(int[][] edges, int[] cost) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number[][]} edges\n * @param {number[]} cost\n * @return {number[]}\n */\nvar placedCoins = function(edges, cost) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function placedCoins(edges: number[][], cost: number[]): number[] {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @param Integer[] $cost\n     * @return Integer[]\n     */\n    function placedCoins($edges, $cost) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func placedCoins(_ edges: [[Int]], _ cost: [Int]) -> [Int] {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun placedCoins(edges: Array<IntArray>, cost: IntArray): LongArray {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  List<int> placedCoins(List<List<int>> edges, List<int> cost) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func placedCoins(edges [][]int, cost []int) []int64 {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer[][]} edges\n# @param {Integer[]} cost\n# @return {Integer[]}\ndef placed_coins(edges, cost)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def placedCoins(edges: Array[Array[Int]], cost: Array[Int]): Array[Long] = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn placed_coins(edges: Vec<Vec<i32>>, cost: Vec<i32>) -> Vec<i64> {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (placed-coins edges cost)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof exact-integer?))\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec placed_coins(Edges :: [[integer()]], Cost :: [integer()]) -> [integer()].\nplaced_coins(Edges, Cost) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec placed_coins(edges :: [[integer]], cost :: [integer]) :: [integer]\n  def placed_coins(edges, cost) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Hard", "titleSlug": "collect-coins-in-a-tree", "title": "Collect Coins in a Tree", "isPaidOnly": false}, {"difficulty": "Hard", "titleSlug": "find-the-maximum-sum-of-node-values", "title": "Find the Maximum Sum of Node Values", "isPaidOnly": false}]}