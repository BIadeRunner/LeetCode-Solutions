{"questionId": "1097", "acRate": 52.22256708332158, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "1032", "paidOnly": false, "status": "ac", "title": "Stream of Characters", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "String", "id": "VG9waWNUYWdOb2RlOjEw", "slug": "string"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}, {"name": "Trie", "id": "VG9waWNUYWdOb2RlOjI3", "slug": "trie"}, {"name": "Data Stream", "id": "VG9waWNUYWdOb2RlOjYxMDYz", "slug": "data-stream"}], "titleSlug": "stream-of-characters", "content": "<p>Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings <code>words</code>.</p>\n\n<p>For example, if <code>words = [&quot;abc&quot;, &quot;xyz&quot;]</code>&nbsp;and the stream added the four characters (one by one) <code>&#39;a&#39;</code>, <code>&#39;x&#39;</code>, <code>&#39;y&#39;</code>, and <code>&#39;z&#39;</code>, your algorithm should detect that the suffix <code>&quot;xyz&quot;</code> of the characters <code>&quot;axyz&quot;</code> matches <code>&quot;xyz&quot;</code> from <code>words</code>.</p>\n\n<p>Implement the <code>StreamChecker</code> class:</p>\n\n<ul>\n\t<li><code>StreamChecker(String[] words)</code> Initializes the object with the strings array <code>words</code>.</li>\n\t<li><code>boolean query(char letter)</code> Accepts a new character from the stream and returns <code>true</code> if any non-empty suffix from the stream forms a word that is in <code>words</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;StreamChecker&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;, &quot;query&quot;]\n[[[&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]], [&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;], [&quot;d&quot;], [&quot;e&quot;], [&quot;f&quot;], [&quot;g&quot;], [&quot;h&quot;], [&quot;i&quot;], [&quot;j&quot;], [&quot;k&quot;], [&quot;l&quot;]]\n<strong>Output</strong>\n[null, false, false, false, true, false, true, false, false, false, false, false, true]\n\n<strong>Explanation</strong>\nStreamChecker streamChecker = new StreamChecker([&quot;cd&quot;, &quot;f&quot;, &quot;kl&quot;]);\nstreamChecker.query(&quot;a&quot;); // return False\nstreamChecker.query(&quot;b&quot;); // return False\nstreamChecker.query(&quot;c&quot;); // return False\nstreamChecker.query(&quot;d&quot;); // return True, because &#39;cd&#39; is in the wordlist\nstreamChecker.query(&quot;e&quot;); // return False\nstreamChecker.query(&quot;f&quot;); // return True, because &#39;f&#39; is in the wordlist\nstreamChecker.query(&quot;g&quot;); // return False\nstreamChecker.query(&quot;h&quot;); // return False\nstreamChecker.query(&quot;i&quot;); // return False\nstreamChecker.query(&quot;j&quot;); // return False\nstreamChecker.query(&quot;k&quot;); // return False\nstreamChecker.query(&quot;l&quot;); // return True, because &#39;kl&#39; is in the wordlist\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 200</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li><code>letter</code> is a lowercase English letter.</li>\n\t<li>At most <code>4 * 10<sup>4</sup></code> calls will be made to query.</li>\n</ul>\n", "hints": ["Put the words into a trie, and manage a set of pointers within that trie."], "exampleTestcases": "[\"StreamChecker\",\"query\",\"query\",\"query\",\"query\",\"query\",\"query\",\"query\",\"query\",\"query\",\"query\",\"query\",\"query\"]\n[[[\"cd\",\"f\",\"kl\"]],[\"a\"],[\"b\"],[\"c\"],[\"d\"],[\"e\"],[\"f\"],[\"g\"],[\"h\"],[\"i\"],[\"j\"],[\"k\"],[\"l\"]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class StreamChecker {\npublic:\n    StreamChecker(vector<string>& words) {\n        \n    }\n    \n    bool query(char letter) {\n        \n    }\n};\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * StreamChecker* obj = new StreamChecker(words);\n * bool param_1 = obj->query(letter);\n */"}, {"lang": "Java", "langSlug": "java", "code": "class StreamChecker {\n\n    public StreamChecker(String[] words) {\n        \n    }\n    \n    public boolean query(char letter) {\n        \n    }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * StreamChecker obj = new StreamChecker(words);\n * boolean param_1 = obj.query(letter);\n */"}, {"lang": "Python", "langSlug": "python", "code": "class StreamChecker(object):\n\n    def __init__(self, words):\n        \"\"\"\n        :type words: List[str]\n        \"\"\"\n        \n\n    def query(self, letter):\n        \"\"\"\n        :type letter: str\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)"}, {"lang": "Python3", "langSlug": "python3", "code": "class StreamChecker:\n\n    def __init__(self, words: List[str]):\n        \n\n    def query(self, letter: str) -> bool:\n        \n\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker(words)\n# param_1 = obj.query(letter)"}, {"lang": "C", "langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} StreamChecker;\n\n\nStreamChecker* streamCheckerCreate(char** words, int wordsSize) {\n    \n}\n\nbool streamCheckerQuery(StreamChecker* obj, char letter) {\n    \n}\n\nvoid streamCheckerFree(StreamChecker* obj) {\n    \n}\n\n/**\n * Your StreamChecker struct will be instantiated and called as such:\n * StreamChecker* obj = streamCheckerCreate(words, wordsSize);\n * bool param_1 = streamCheckerQuery(obj, letter);\n \n * streamCheckerFree(obj);\n*/"}, {"lang": "C#", "langSlug": "csharp", "code": "public class StreamChecker {\n\n    public StreamChecker(string[] words) {\n        \n    }\n    \n    public bool Query(char letter) {\n        \n    }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * StreamChecker obj = new StreamChecker(words);\n * bool param_1 = obj.Query(letter);\n */"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {string[]} words\n */\nvar StreamChecker = function(words) {\n    \n};\n\n/** \n * @param {character} letter\n * @return {boolean}\n */\nStreamChecker.prototype.query = function(letter) {\n    \n};\n\n/** \n * Your StreamChecker object will be instantiated and called as such:\n * var obj = new StreamChecker(words)\n * var param_1 = obj.query(letter)\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "class StreamChecker {\n    constructor(words: string[]) {\n        \n    }\n\n    query(letter: string): boolean {\n        \n    }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * var obj = new StreamChecker(words)\n * var param_1 = obj.query(letter)\n */"}, {"lang": "PHP", "langSlug": "php", "code": "class StreamChecker {\n    /**\n     * @param String[] $words\n     */\n    function __construct($words) {\n        \n    }\n  \n    /**\n     * @param String $letter\n     * @return Boolean\n     */\n    function query($letter) {\n        \n    }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * $obj = StreamChecker($words);\n * $ret_1 = $obj->query($letter);\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "\nclass StreamChecker {\n\n    init(_ words: [String]) {\n        \n    }\n    \n    func query(_ letter: Character) -> Bool {\n        \n    }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * let obj = StreamChecker(words)\n * let ret_1: Bool = obj.query(letter)\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class StreamChecker(words: Array<String>) {\n\n    fun query(letter: Char): Boolean {\n        \n    }\n\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * var obj = StreamChecker(words)\n * var param_1 = obj.query(letter)\n */"}, {"lang": "Dart", "langSlug": "dart", "code": "class StreamChecker {\n\n  StreamChecker(List<String> words) {\n    \n  }\n  \n  bool query(String letter) {\n    \n  }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * StreamChecker obj = StreamChecker(words);\n * bool param1 = obj.query(letter);\n */"}, {"lang": "Go", "langSlug": "golang", "code": "type StreamChecker struct {\n    \n}\n\n\nfunc Constructor(words []string) StreamChecker {\n    \n}\n\n\nfunc (this *StreamChecker) Query(letter byte) bool {\n    \n}\n\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * obj := Constructor(words);\n * param_1 := obj.Query(letter);\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "class StreamChecker\n\n=begin\n    :type words: String[]\n=end\n    def initialize(words)\n        \n    end\n\n\n=begin\n    :type letter: Character\n    :rtype: Boolean\n=end\n    def query(letter)\n        \n    end\n\n\nend\n\n# Your StreamChecker object will be instantiated and called as such:\n# obj = StreamChecker.new(words)\n# param_1 = obj.query(letter)"}, {"lang": "Scala", "langSlug": "scala", "code": "class StreamChecker(_words: Array[String]) {\n\n    def query(letter: Char): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * val obj = new StreamChecker(words)\n * val param_1 = obj.query(letter)\n */"}, {"lang": "Rust", "langSlug": "rust", "code": "struct StreamChecker {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StreamChecker {\n\n    fn new(words: Vec<String>) -> Self {\n        \n    }\n    \n    fn query(&self, letter: char) -> bool {\n        \n    }\n}\n\n/**\n * Your StreamChecker object will be instantiated and called as such:\n * let obj = StreamChecker::new(words);\n * let ret_1: bool = obj.query(letter);\n */"}, {"lang": "Racket", "langSlug": "racket", "code": "(define stream-checker%\n  (class object%\n    (super-new)\n    \n    ; words : (listof string?)\n    (init-field\n      words)\n    \n    ; query : char? -> boolean?\n    (define/public (query letter)\n      )))\n\n;; Your stream-checker% object will be instantiated and called as such:\n;; (define obj (new stream-checker% [words words]))\n;; (define param_1 (send obj query letter))"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec stream_checker_init_(Words :: [unicode:unicode_binary()]) -> any().\nstream_checker_init_(Words) ->\n  .\n\n-spec stream_checker_query(Letter :: char()) -> boolean().\nstream_checker_query(Letter) ->\n  .\n\n\n%% Your functions will be called as such:\n%% stream_checker_init_(Words),\n%% Param_1 = stream_checker_query(Letter),\n\n%% stream_checker_init_ will be called before every test case, in which you can do some necessary initializations."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule StreamChecker do\n  @spec init_(words :: [String.t]) :: any\n  def init_(words) do\n    \n  end\n\n  @spec query(letter :: char) :: boolean\n  def query(letter) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StreamChecker.init_(words)\n# param_1 = StreamChecker.query(letter)\n\n# StreamChecker.init_ will be called before every test case, in which you can do some necessary initializations."}], "similarQuestionList": []}