{"question_id": "1736", "problem_slug": "build-binary-expression-tree-from-infix-expression", "problem_title": "Build Binary Expression Tree From Infix Expression", "content": "A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (numbers), and internal nodes (nodes with 2 children) correspond to the operators '+' (addition), '-' (subtraction), '*' (multiplication), and '/' (division).\nFor each internal node with operator o, the infix expression it represents is (A o B), where A is the expression the left subtree represents and B is the expression the right subtree represents.\nYou are given a string s, an infix expression containing operands, the operators described above, and parentheses '(' and ')'.\nReturn any valid binary expression tree, whose in-order traversal reproduces s after omitting the parenthesis from it.\nPlease note that order of operations applies in s. That is, expressions in parentheses are evaluated first, and multiplication and division happen before addition and subtraction.\nOperands must also appear in the same order in both s and the in-order traversal of the tree.\n \nExample 1:\n\n\nInput: s = \"3*4-2*5\"\nOutput: [-,*,*,3,4,2,5]\nExplanation: The tree above is the only valid tree whose inorder traversal produces s.\n\nExample 2:\n\n\nInput: s = \"2-3/(5*2)+1\"\nOutput: [+,-,1,2,/,null,null,null,null,3,*,null,null,5,2]\nExplanation: The inorder traversal of the tree above is 2-3/5*2+1 which is the same as s without the parenthesis. The tree also produces the correct result and its operands are in the same order as they appear in s.\nThe tree below is also a valid binary expression tree with the same inorder traversal as s, but it not a valid answer because it does not evaluate to the same value.\n\nThe third tree below is also not valid. Although it produces the same result and is equivalent to the above trees, its inorder traversal does not produce s and its operands are not in the same order as s.\n\n\nExample 3:\n\nInput: s = \"1+2+3+4+5\"\nOutput: [+,+,5,+,4,null,null,+,3,null,null,1,2]\nExplanation: The tree [+,+,5,+,+,null,null,1,2,3,4] is also one of many other valid trees.\n\n \nConstraints:\n\n1 <= s.length <= 100\ns consists of digits and the characters '(', ')', '+', '-', '*', and '/'.\nOperands in s are exactly 1 digit.\nIt is guaranteed that s is a valid expression.\n\n", "hints": ["Convert infix expression to postfix expression.", "Build an expression tree from the postfix expression."], "exampleTestcases": "\"3*4-2*5\"\n\"2-3/(5*2)+1\"\n\"1+2+3+4+5\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/**\n * Definition for a binary tree node.\n * struct Node {\n *     char val;\n *     Node *left;\n *     Node *right;\n *     Node() : val(' '), left(nullptr), right(nullptr) {}\n *     Node(char x) : val(x), left(nullptr), right(nullptr) {}\n *     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    Node* expTree(string s) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "/**\n * Definition for a binary tree node.\n * class Node {\n *     char val;\n *     Node left;\n *     Node right;\n *     Node() {this.val = ' ';}\n *     Node(char val) { this.val = val; }\n *     Node(char val, Node left, Node right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public Node expTree(String s) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "# Definition for a binary tree node.\n# class Node(object):\n#     def __init__(self, val=\" \", left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def expTree(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: Node\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "# Definition for a binary tree node.\n# class Node(object):\n#     def __init__(self, val=\" \", left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def expTree(self, s: str) -> 'Node':\n        "}, "C#": {"langSlug": "csharp", "code": "/**\n * Definition for a binary tree node.\n * public class Node {\n *     public char val;\n *     public Node left;\n *     public Node right;\n *     public Node(char val=' ', TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public Node ExpTree(string s) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * Definition for a binary tree node.\n * function Node(val, left, right) {\n *     this.val = (val===undefined ? \" \" : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {string} s\n * @return {Node}\n */\nvar expTree = function(s) {\n    \n};"}}}