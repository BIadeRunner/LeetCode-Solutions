{"question_id": "281", "problem_slug": "zigzag-iterator", "problem_title": "Zigzag Iterator", "content": "Given two vectors of integers v1 and v2, implement an iterator to return their elements alternately.\nImplement the ZigzagIterator class:\n\nZigzagIterator(List<int> v1, List<int> v2) initializes the object with the two vectors v1 and v2.\nboolean hasNext() returns true if the iterator still has elements, and false otherwise.\nint next() returns the current element of the iterator and moves the iterator to the next element.\n\n \nExample 1:\n\nInput: v1 = [1,2], v2 = [3,4,5,6]\nOutput: [1,3,2,4,5,6]\nExplanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,3,2,4,5,6].\n\nExample 2:\n\nInput: v1 = [1], v2 = []\nOutput: [1]\n\nExample 3:\n\nInput: v1 = [], v2 = [1]\nOutput: [1]\n\n \nConstraints:\n\n0 <= v1.length, v2.length <= 1000\n1 <= v1.length + v2.length <= 2000\n-231 <= v1[i], v2[i] <= 231 - 1\n\n \nFollow up: What if you are given k vectors? How well can your code be extended to such cases?\nClarification for the follow-up question:\nThe \"Zigzag\" order is not clearly defined and is ambiguous for k > 2 cases. If \"Zigzag\" does not look right to you, replace \"Zigzag\" with \"Cyclic\".\nFollow-up Example:\n\nInput: v1 = [1,2,3], v2 = [4,5,6,7], v3 = [8,9]\nOutput: [1,4,8,2,5,9,3,6,7]\n\n", "hints": [], "exampleTestcases": "[1,2]\n[3,4,5,6]\n[1]\n[]\n[]\n[1]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class ZigzagIterator {\npublic:\n    ZigzagIterator(vector<int>& v1, vector<int>& v2) {\n        \n    }\n\n    int next() {\n        \n    }\n\n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i(v1, v2);\n * while (i.hasNext()) cout << i.next();\n */"}, "Java": {"langSlug": "java", "code": "public class ZigzagIterator {\n\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        \n    }\n\n    public int next() {\n        \n    }\n\n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.hasNext()) v[f()] = i.next();\n */"}, "Python": {"langSlug": "python", "code": "class ZigzagIterator(object):\n\n    def __init__(self, v1, v2):\n        \"\"\"\n        Initialize your data structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n# Your ZigzagIterator object will be instantiated and called as such:\n# i, v = ZigzagIterator(v1, v2), []\n# while i.hasNext(): v.append(i.next())"}, "Python3": {"langSlug": "python3", "code": "class ZigzagIterator:\n    def __init__(self, v1: List[int], v2: List[int]):\n        \n\n    def next(self) -> int:\n        \n\n    def hasNext(self) -> bool:\n        \n\n# Your ZigzagIterator object will be instantiated and called as such:\n# i, v = ZigzagIterator(v1, v2), []\n# while i.hasNext(): v.append(i.next())"}, "C": {"langSlug": "c", "code": "struct ZigzagIterator {\n    \n};\n\nstruct ZigzagIterator *zigzagIteratorCreate(int* v1, int v1Size, int* v2, int v2Size) {\n    \n}\n\nbool zigzagIteratorHasNext(struct ZigzagIterator *iter) {\n    \n}\n\nint zigzagIteratorNext(struct ZigzagIterator *iter) {\n    \n}\n\n/** Deallocates memory previously allocated for the iterator */\nvoid zigzagIteratorFree(struct ZigzagIterator *iter) {\n    \n}\n\n/**\n * Your ZigzagIterator will be called like this:\n * struct ZigzagIterator *i = zigzagIteratorCreate(v1, v1Size, v2, v2Size);\n * while (zigzagIteratorHasNext(i)) printf(\"%d\\n\", zigzagIteratorNext(i));\n * zigzagIteratorFree(i);\n */"}, "C#": {"langSlug": "csharp", "code": "public class ZigzagIterator {\n\n    public ZigzagIterator(IList<int> v1, IList<int> v2) {\n        \n    }\n\n    public bool HasNext() {\n        \n    }\n\n    public int Next() {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator will be called like this:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.HasNext()) v[f()] = i.Next();\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @constructor\n * @param {Integer[]} v1\n * @param {Integer[]} v1\n */\nvar ZigzagIterator = function ZigzagIterator(v1, v2) {\n    \n};\n\n\n/**\n * @this ZigzagIterator\n * @returns {boolean}\n */\nZigzagIterator.prototype.hasNext = function hasNext() {\n    \n};\n\n/**\n * @this ZigzagIterator\n * @returns {integer}\n */\nZigzagIterator.prototype.next = function next() {\n    \n};\n\n/**\n * Your ZigzagIterator will be called like this:\n * var i = new ZigzagIterator(v1, v2), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/"}, "TypeScript": {"langSlug": "typescript", "code": "class ZigzagIterator {\n    constructor(v1: number[], v2: number[]) {\n\t\t\n    }\n\n    next(): number {\n\t\t\n    }\n\n    hasNext(): boolean {\n\t\t\n    }\n}\n\n/**\n * Your ZigzagIterator will be instantiated and called as such:\n * var i = new ZigzagIterator(v1, v2), a = [];\n * while (i.hasNext()) a.push(i.next());\n*/"}, "PHP": {"langSlug": "php", "code": "class ZigzagIterator {\n    /**\n     * Initialize your data structure here.\n     * @param Integer[] $v1\n     * @param Integer[] $v2\n     */\n    function __construct($v1, $v2) {\n        \n    }\n    \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n    \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * $obj = ZigzagIterator($v1, $v2);\n * while ($obj->hasNext()) {\n *   array_push($ans, $obj->next())\n * }\n */"}, "Swift": {"langSlug": "swift", "code": "class ZigzagIterator {\n    init(_ v1: [Int], _ v2: [Int]) {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n// Your ZigzagIterator object will be instantiated and called as such:\n// var i = ZigzagIterator(v1, v2)\n// var ret = [Int]()\n// while i.hasNext() {\n// \t\tret.append(i.next())\n// }"}, "Kotlin": {"langSlug": "kotlin", "code": "class ZigzagIterator {\n    constructor(v1: IntArray, v2: IntArray) {\n        \n    }\n    \n    fun next(): Int {\n        \n    }\n    \n    fun hasNext(): Boolean {\n        \n    }\n}\n\n// Your ZigzagIterator object will be instantiated and called as such:\n// var i = ZigzagIterator(v1, v2)\n// var ret = ArrayList<Int>()\n// while(i.hasNext()){\n//\t\tret.add(i.next())\n// }"}, "Go": {"langSlug": "golang", "code": "type ZigzagIterator struct {\n    \n}\n\nfunc Constructor(v1, v2 []int) *ZigzagIterator {\n    \n}\n\nfunc (this *ZigzagIterator) next() int {\n    \n}\n\nfunc (this *ZigzagIterator) hasNext() bool {\n\t\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * obj := Constructor(param_1, param_2);\n * for obj.hasNext() {\n *\t ans = append(ans, obj.next())\n * }\n */"}, "Ruby": {"langSlug": "ruby", "code": "class ZigzagIterator\n    # @param {Integer[]} v1\n    # @param {Integer[]} v2\n    def initialize(v1, v2)\n        \n    end\n\n    # @return {Boolean}\n    def has_next\n        \n    end\n\n    # @return {Integer}\n    def next\n        \n    end\nend\n\n# Your ZigzagIterator will be called like this:\n# i, v = ZigzagIterator.new(v1, v2), []\n# while i.has_next()\n#    v << i.next\n# end"}, "Scala": {"langSlug": "scala", "code": "class ZigzagIterator(_v1: Array[Int], _v2: Array[Int]) {\n    /** initialize your data structure here. */\n    \n    def next(): Int = {\n        \n    }\n    \n    def hasNext(): Boolean = {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * var obj = new ZigzagIterator(v1, v2)\n * while (obj.hasNext()) {\n *     ans += obj.next()\n * }\n */"}, "Rust": {"langSlug": "rust", "code": "struct ZigzagIterator {\n    \n}\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl ZigzagIterator {\n    /** initialize your data structure here. */\n    \n    fn new(v1: Vec<i32>, v2: Vec<i32>) -> Self {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * let obj = ZigzagIterator::new(v1, v2);\n * let ret_1: i32 = obj.next();\n * let ret_2: bool = obj.has_next();\n */"}}}