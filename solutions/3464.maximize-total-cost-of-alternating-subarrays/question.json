{"question_id": "3464", "problem_slug": "maximize-total-cost-of-alternating-subarrays", "problem_title": "Maximize Total Cost of Alternating Subarrays", "content": "You are given an integer array nums with length n.\nThe cost of a subarray nums[l..r], where 0 <= l <= r < n, is defined as:\ncost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)r − l\nYour task is to split nums into subarrays such that the total cost of the subarrays is maximized, ensuring each element belongs to exactly one subarray.\nFormally, if nums is split into k subarrays, where k > 1, at indices i1, i2, ..., ik − 1, where 0 <= i1 < i2 < ... < ik - 1 < n - 1, then the total cost will be:\ncost(0, i1) + cost(i1 + 1, i2) + ... + cost(ik − 1 + 1, n − 1)\nReturn an integer denoting the maximum total cost of the subarrays after splitting the array optimally.\nNote: If nums is not split into subarrays, i.e. k = 1, the total cost is simply cost(0, n - 1).\n \nExample 1:\n\nInput: nums = [1,-2,3,4]\nOutput: 10\nExplanation:\nOne way to maximize the total cost is by splitting [1, -2, 3, 4] into subarrays [1, -2, 3] and [4]. The total cost will be (1 + 2 + 3) + 4 = 10.\n\nExample 2:\n\nInput: nums = [1,-1,1,-1]\nOutput: 4\nExplanation:\nOne way to maximize the total cost is by splitting [1, -1, 1, -1] into subarrays [1, -1] and [1, -1]. The total cost will be (1 + 1) + (1 + 1) = 4.\n\nExample 3:\n\nInput: nums = [0]\nOutput: 0\nExplanation:\nWe cannot split the array further, so the answer is 0.\n\nExample 4:\n\nInput: nums = [1,-1]\nOutput: 2\nExplanation:\nSelecting the whole array gives a total cost of 1 + 1 = 2, which is the maximum.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n\n", "hints": ["The problem can be solved using dynamic programming.", "Since we can always start a new subarray, the problem is the same as selecting some elements in the array and flipping their signs to negative to maximize the sum. However, we cannot flip the signs of 2 consecutive elements, and the first element in the array cannot be negative.", "Let <code>dp[i][0/1]</code> be the largest sum we can get for prefix <code>nums[0..i]</code>, where <code>dp[i][0]</code> is the maximum if the <code>i<sup>th</sup></code> element wasn't flipped, and <code>dp[i][1]</code> is the maximum if the <code>i<sup>th</sup></code> element was flipped.", "Based on the restriction:<br />\r\n<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) + nums[i]</code><br />\r\n<code>dp[i][1] = dp[i - 1][0] - nums[i]</code>", "The initial state is:<br />\r\n<code>dp[1][0] = nums[0] + nums[1]</code><br />\r\n<code>dp[1][1] = nums[0] - nums[1]</code><br />\r\nand the answer is <code>max(dp[n - 1][0], dp[n - 1][1])</code>.", "Can you optimize the space complexity?"], "exampleTestcases": "[1,-2,3,4]\n[1,-1,1,-1]\n[0]\n[1,-1]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    long long maximumTotalCost(vector<int>& nums) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public long maximumTotalCost(int[] nums) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def maximumTotalCost(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def maximumTotalCost(self, nums: List[int]) -> int:\n        "}, "C": {"langSlug": "c", "code": "long long maximumTotalCost(int* nums, int numsSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public long MaximumTotalCost(int[] nums) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maximumTotalCost = function(nums) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function maximumTotalCost(nums: number[]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maximumTotalCost($nums) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func maximumTotalCost(_ nums: [Int]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun maximumTotalCost(nums: IntArray): Long {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int maximumTotalCost(List<int> nums) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func maximumTotalCost(nums []int) int64 {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef maximum_total_cost(nums)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def maximumTotalCost(nums: Array[Int]): Long = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn maximum_total_cost(nums: Vec<i32>) -> i64 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (maximum-total-cost nums)\n  (-> (listof exact-integer?) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec maximum_total_cost(Nums :: [integer()]) -> integer().\nmaximum_total_cost(Nums) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec maximum_total_cost(nums :: [integer]) :: integer\n  def maximum_total_cost(nums) do\n    \n  end\nend"}}}