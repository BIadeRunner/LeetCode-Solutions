{"question_id": "1650", "problem_slug": "find-root-of-n-ary-tree", "problem_title": "Find Root of N-Ary Tree", "content": "You are given all the nodes of an N-ary tree as an array of Node objects, where each node has a unique value.\nReturn the root of the N-ary tree.\nCustom testing:\nAn N-ary tree can be serialized as represented in its level order traversal where each group of children is separated by the null value (see examples).\n\nFor example, the above tree is serialized as [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].\nThe testing will be done in the following way:\n\nThe input data should be provided as a serialization of the tree.\nThe driver code will construct the tree from the serialized input data and put each Node object into an array in an arbitrary order.\nThe driver code will pass the array to findRoot, and your function should find and return the root Node object in the array.\nThe driver code will take the returned Node object and serialize it. If the serialized value and the input data are the same, the test passes.\n\n \nExample 1:\n\n\nInput: tree = [1,null,3,2,4,null,5,6]\nOutput: [1,null,3,2,4,null,5,6]\nExplanation: The tree from the input data is shown above.\nThe driver code creates the tree and gives findRoot the Node objects in an arbitrary order.\nFor example, the passed array could be [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)].\nThe findRoot function should return the root Node(1), and the driver code will serialize it and compare with the input data.\nThe input data and serialized Node(1) are the same, so the test passes.\n\nExample 2:\n\n\nInput: tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n\n \nConstraints:\n\nThe total number of nodes is between [1, 5 * 104].\nEach node has a unique value.\n\n \nFollow up:\n\nCould you solve this problem in constant space complexity with a linear time algorithm?\n\n", "hints": ["Node with indegree 0 is the root"], "exampleTestcases": "[1,null,3,2,4,null,5,6]\n[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* findRoot(vector<Node*> tree) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    \n    public Node() {\n        children = new ArrayList<Node>();\n    }\n    \n    public Node(int _val) {\n        val = _val;\n        children = new ArrayList<Node>();\n    }\n    \n    public Node(int _val,ArrayList<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\n    public Node findRoot(List<Node> tree) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\"\"\"\n\nclass Solution(object):\n    def findRoot(self, tree):\n        \"\"\"\n        :type tree: List['Node']\n        :rtype: 'Node'\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: Optional[int] = None, children: Optional[List['Node']] = None):\n        self.val = val\n        self.children = children if children is not None else []\n\"\"\"\n\nclass Solution:\n    def findRoot(self, tree: List['Node']) -> 'Node':\n        "}, "C#": {"langSlug": "csharp", "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> children;\n    \n    public Node() {\n        val = 0;\n        children = new List<Node>();\n    }\n\n    public Node(int _val) {\n        val = _val;\n        children = new List<Node>();\n    }\n    \n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n*/\n\npublic class Solution {\n    public Node FindRoot(List<Node> tree) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * // Definition for a _Node.\n * function _Node(val, children) {\n *    this.val = val === undefined ? 0 : val;\n *    this.children = children === undefined ? [] : children;\n * };\n */\n\n/**\n * @param {_Node[]} tree\n * @return {_Node}\n */\nvar findRoot = function(tree) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "/**\n * Definition for _Node.\n * class _Node {\n *     val: number\n *     children: _Node[]\n * \n *     constructor(val?: number, children?: _Node[]) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.children = (children===undefined ? [] : children)\n *     }\n * }\n */\n\n\nfunction findRoot(tree: _Node[]): _Node | null {\n    \n};"}, "PHP": {"langSlug": "php", "code": "/**\n * Definition for a Node.\n * class Node {\n *     public $val = null;\n *     public $children = null;\n *     function __construct($val = 0) {\n *         $this->val = $val;\n *         $this->children = array();\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param Node[] $tree\n     * @return Node\n     */\n    function findRoot($tree) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "/**\n * Definition for a Node.\n * public class Node {\n *     public var val: Int\n *     public var children: [Node]\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.children = []\n *     }\n * }\n */\n\nclass Solution {\n    func findRoot(_ tree: [Node]) -> Node? {\n\n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "/**\n * Definition for a Node.\n * class Node(var `val`: Int) {\n *     var children: List<Node?> = listOf()\n * }\n */\n\nclass Solution {\n    fun findRoot(tree: List<Node>): Node? {\n        \n    }\n}"}, "Go": {"langSlug": "golang", "code": "/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Children []*Node\n * }\n */\n\nfunc findRoot(tree []*Node) *Node {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# Definition for a Node.\n# class Node\n#     attr_accessor :val, :children\n#     def initialize(val=0, children=[])\n#         @val = val\n#         @children = children\n#     end\n# end\n\n# @param {Node[]} tree\n# @return {Node}\ndef find_root(tree)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "/**\n * Definition for a Node.\n * class Node(var _value: Int) {\n *   var value: Int = _value\n *   var children: List[Node] = List()\n * }\n */\n\nobject Solution {\n    def findRoot(tree: List[Node]): Node = {\n        \n    }\n}\n"}}}