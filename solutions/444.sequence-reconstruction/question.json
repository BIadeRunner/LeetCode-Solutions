{"question_id": "444", "problem_slug": "sequence-reconstruction", "problem_title": "Sequence Reconstruction", "content": "You are given an integer array nums of length n where nums is a permutation of the integers in the range [1, n]. You are also given a 2D integer array sequences where sequences[i] is a subsequence of nums.\nCheck if nums is the shortest possible and the only supersequence. The shortest supersequence is a sequence with the shortest length and has all sequences[i] as subsequences. There could be multiple valid supersequences for the given array sequences.\n\nFor example, for sequences = [[1,2],[1,3]], there are two shortest supersequences, [1,2,3] and [1,3,2].\nWhile for sequences = [[1,2],[1,3],[1,2,3]], the only shortest supersequence possible is [1,2,3]. [1,2,3,4] is a possible supersequence but not the shortest.\n\nReturn true if nums is the only shortest supersequence for sequences, or false otherwise.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n \nExample 1:\n\nInput: nums = [1,2,3], sequences = [[1,2],[1,3]]\nOutput: false\nExplanation: There are two possible supersequences: [1,2,3] and [1,3,2].\nThe sequence [1,2] is a subsequence of both: [1,2,3] and [1,3,2].\nThe sequence [1,3] is a subsequence of both: [1,2,3] and [1,3,2].\nSince nums is not the only shortest supersequence, we return false.\n\nExample 2:\n\nInput: nums = [1,2,3], sequences = [[1,2]]\nOutput: false\nExplanation: The shortest possible supersequence is [1,2].\nThe sequence [1,2] is a subsequence of it: [1,2].\nSince nums is not the shortest supersequence, we return false.\n\nExample 3:\n\nInput: nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]\nOutput: true\nExplanation: The shortest possible supersequence is [1,2,3].\nThe sequence [1,2] is a subsequence of it: [1,2,3].\nThe sequence [1,3] is a subsequence of it: [1,2,3].\nThe sequence [2,3] is a subsequence of it: [1,2,3].\nSince nums is the only shortest supersequence, we return true.\n\n \nConstraints:\n\nn == nums.length\n1 <= n <= 104\nnums is a permutation of all the integers in the range [1, n].\n1 <= sequences.length <= 104\n1 <= sequences[i].length <= 104\n1 <= sum(sequences[i].length) <= 105\n1 <= sequences[i][j] <= n\nAll the arrays of sequences are unique.\nsequences[i] is a subsequence of nums.\n\n", "hints": [], "exampleTestcases": "[1,2,3]\n[[1,2],[1,3]]\n[1,2,3]\n[[1,2]]\n[1,2,3]\n[[1,2],[1,3],[2,3]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool sequenceReconstruction(vector<int>& nums, vector<vector<int>>& sequences) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean sequenceReconstruction(int[] nums, List<List<Integer>> sequences) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def sequenceReconstruction(self, nums, sequences):\n        \"\"\"\n        :type nums: List[int]\n        :type sequences: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool sequenceReconstruction(int* nums, int numsSize, int** sequences, int sequencesSize, int* sequencesColSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool SequenceReconstruction(int[] nums, IList<IList<int>> sequences) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} nums\n * @param {number[][]} sequences\n * @return {boolean}\n */\nvar sequenceReconstruction = function(nums, sequences) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function sequenceReconstruction(nums: number[], sequences: number[][]): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[][] $sequences\n     * @return Boolean\n     */\n    function sequenceReconstruction($nums, $sequences) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func sequenceReconstruction(_ nums: [Int], _ sequences: [[Int]]) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun sequenceReconstruction(nums: IntArray, sequences: List<List<Int>>): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool sequenceReconstruction(List<int> nums, List<List<int>> sequences) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func sequenceReconstruction(nums []int, sequences [][]int) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} nums\n# @param {Integer[][]} sequences\n# @return {Boolean}\ndef sequence_reconstruction(nums, sequences)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def sequenceReconstruction(nums: Array[Int], sequences: List[List[Int]]): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn sequence_reconstruction(nums: Vec<i32>, sequences: Vec<Vec<i32>>) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (sequence-reconstruction nums sequences)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec sequence_reconstruction(Nums :: [integer()], Sequences :: [[integer()]]) -> boolean().\nsequence_reconstruction(Nums, Sequences) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec sequence_reconstruction(nums :: [integer], sequences :: [[integer]]) :: boolean\n  def sequence_reconstruction(nums, sequences) do\n    \n  end\nend"}}}