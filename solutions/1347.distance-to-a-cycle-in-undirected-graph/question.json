{"question_id": "1347", "problem_slug": "distance-to-a-cycle-in-undirected-graph", "problem_title": "Distance to a Cycle in Undirected Graph", "content": "You are given a positive integer n representing the number of nodes in a connected undirected graph containing exactly one cycle. The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [node1i, node2i] denotes that there is a bidirectional edge connecting node1i and node2i in the graph.\nThe distance between two nodes a and b is defined to be the minimum number of edges that are needed to go from a to b.\nReturn an integer array answer of size n, where answer[i] is the minimum distance between the ith node and any node in the cycle.\n \nExample 1:\n\n\nInput: n = 7, edges = [[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]\nOutput: [1,0,0,0,0,1,2]\nExplanation:\nThe nodes 1, 2, 3, and 4 form the cycle.\nThe distance from 0 to 1 is 1.\nThe distance from 1 to 1 is 0.\nThe distance from 2 to 2 is 0.\nThe distance from 3 to 3 is 0.\nThe distance from 4 to 4 is 0.\nThe distance from 5 to 2 is 1.\nThe distance from 6 to 2 is 2.\n\nExample 2:\n\n\nInput: n = 9, edges = [[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]\nOutput: [0,0,0,1,2,2,1,2,2]\nExplanation:\nThe nodes 0, 1, and 2 form the cycle.\nThe distance from 0 to 0 is 0.\nThe distance from 1 to 1 is 0.\nThe distance from 2 to 2 is 0.\nThe distance from 3 to 1 is 1.\nThe distance from 4 to 1 is 2.\nThe distance from 5 to 1 is 2.\nThe distance from 6 to 2 is 1.\nThe distance from 7 to 2 is 2.\nThe distance from 8 to 2 is 2.\n\n \nConstraints:\n\n3 <= n <= 105\nedges.length == n\nedges[i].length == 2\n0 <= node1i, node2i <= n - 1\nnode1i != node2i\nThe graph is connected.\nThe graph has exactly one cycle.\nThere is at most one edge between any pair of vertices.\n\n", "hints": ["This problem can be broken down into two parts: finding the cycle, and finding the distance between each node and the cycle.", "How can we find the cycle? We can use DFS and keep track of the nodes we’ve seen, and the order that we see them in. Once we see a node we’ve already visited, we know that the cycle contains the node that was seen twice and all the nodes that we visited in between.", "Now that we know which nodes are part of the cycle, how can we find the distances? We can run a multi-source BFS starting from the nodes in the cycle and expanding outward."], "exampleTestcases": "7\n[[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]\n9\n[[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> distanceToCycle(int n, vector<vector<int>>& edges) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[] distanceToCycle(int n, int[][] edges) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def distanceToCycle(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def distanceToCycle(self, n: int, edges: List[List[int]]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* distanceToCycle(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[] DistanceToCycle(int n, int[][] edges) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar distanceToCycle = function(n, edges) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function distanceToCycle(n: number, edges: number[][]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function distanceToCycle($n, $edges) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func distanceToCycle(_ n: Int, _ edges: [[Int]]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun distanceToCycle(n: Int, edges: Array<IntArray>): IntArray {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> distanceToCycle(int n, List<List<int>> edges) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func distanceToCycle(n int, edges [][]int) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef distance_to_cycle(n, edges)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def distanceToCycle(n: Int, edges: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn distance_to_cycle(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (distance-to-cycle n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec distance_to_cycle(N :: integer(), Edges :: [[integer()]]) -> [integer()].\ndistance_to_cycle(N, Edges) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec distance_to_cycle(n :: integer, edges :: [[integer]]) :: [integer]\n  def distance_to_cycle(n, edges) do\n    \n  end\nend"}}}