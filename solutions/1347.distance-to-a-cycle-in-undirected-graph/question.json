{"questionId": "1347", "acRate": 68.24401368301027, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "2204", "paidOnly": true, "status": "ac", "title": "Distance to a Cycle in Undirected Graph", "topicTags": [{"name": "Depth-First Search", "id": "VG9waWNUYWdOb2RlOjIx", "slug": "depth-first-search"}, {"name": "Breadth-First Search", "id": "VG9waWNUYWdOb2RlOjIy", "slug": "breadth-first-search"}, {"name": "Union Find", "id": "VG9waWNUYWdOb2RlOjIz", "slug": "union-find"}, {"name": "Graph", "id": "VG9waWNUYWdOb2RlOjI0", "slug": "graph"}], "titleSlug": "distance-to-a-cycle-in-undirected-graph", "content": "<p>You are given a positive integer <code>n</code> representing the number of nodes in a <strong>connected undirected graph</strong> containing <strong>exactly one</strong> cycle. The nodes are numbered from <code>0</code> to <code>n - 1</code> (<strong>inclusive</strong>).</p>\n\n<p>You are also given a 2D integer array <code>edges</code>, where <code>edges[i] = [node1<sub>i</sub>, node2<sub>i</sub>]</code> denotes that there is a <strong>bidirectional</strong> edge connecting <code>node1<sub>i</sub></code> and <code>node2<sub>i</sub></code> in the graph.</p>\n\n<p>The distance between two nodes <code>a</code> and <code>b</code> is defined to be the <strong>minimum</strong> number of edges that are needed to go from <code>a</code> to <code>b</code>.</p>\n\n<p>Return <em>an integer array <code>answer</code></em><em> of size </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the <strong>minimum</strong> distance between the </em><code>i<sup>th</sup></code><em> node and <strong>any</strong> node in the cycle.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/15/image-20220315154238-1.png\" style=\"width: 350px; height: 237px;\" />\n<pre>\n<strong>Input:</strong> n = 7, edges = [[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]\n<strong>Output:</strong> [1,0,0,0,0,1,2]\n<strong>Explanation:</strong>\nThe nodes 1, 2, 3, and 4 form the cycle.\nThe distance from 0 to 1 is 1.\nThe distance from 1 to 1 is 0.\nThe distance from 2 to 2 is 0.\nThe distance from 3 to 3 is 0.\nThe distance from 4 to 4 is 0.\nThe distance from 5 to 2 is 1.\nThe distance from 6 to 2 is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/15/image-20220315154634-1.png\" style=\"width: 400px; height: 297px;\" />\n<pre>\n<strong>Input:</strong> n = 9, edges = [[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]\n<strong>Output:</strong> [0,0,0,1,2,2,1,2,2]\n<strong>Explanation:</strong>\nThe nodes 0, 1, and 2 form the cycle.\nThe distance from 0 to 0 is 0.\nThe distance from 1 to 1 is 0.\nThe distance from 2 to 2 is 0.\nThe distance from 3 to 1 is 1.\nThe distance from 4 to 1 is 2.\nThe distance from 5 to 1 is 2.\nThe distance from 6 to 2 is 1.\nThe distance from 7 to 2 is 2.\nThe distance from 8 to 2 is 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= node1<sub>i</sub>, node2<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>node1<sub>i</sub> != node2<sub>i</sub></code></li>\n\t<li>The graph is connected.</li>\n\t<li>The graph has exactly one cycle.</li>\n\t<li>There is at most one edge between any pair of vertices.</li>\n</ul>\n", "hints": ["This problem can be broken down into two parts: finding the cycle, and finding the distance between each node and the cycle.", "How can we find the cycle? We can use DFS and keep track of the nodes we\u2019ve seen, and the order that we see them in. Once we see a node we\u2019ve already visited, we know that the cycle contains the node that was seen twice and all the nodes that we visited in between.", "Now that we know which nodes are part of the cycle, how can we find the distances? We can run a multi-source BFS starting from the nodes in the cycle and expanding outward."], "exampleTestcases": "7\n[[1,2],[2,4],[4,3],[3,1],[0,1],[5,2],[6,5]]\n9\n[[0,1],[1,2],[0,2],[2,6],[6,7],[6,8],[0,3],[3,4],[3,5]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> distanceToCycle(int n, vector<vector<int>>& edges) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public int[] distanceToCycle(int n, int[][] edges) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def distanceToCycle(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def distanceToCycle(self, n: int, edges: List[List[int]]) -> List[int]:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* distanceToCycle(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public int[] DistanceToCycle(int n, int[][] edges) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar distanceToCycle = function(n, edges) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function distanceToCycle(n: number, edges: number[][]): number[] {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function distanceToCycle($n, $edges) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func distanceToCycle(_ n: Int, _ edges: [[Int]]) -> [Int] {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun distanceToCycle(n: Int, edges: Array<IntArray>): IntArray {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  List<int> distanceToCycle(int n, List<List<int>> edges) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func distanceToCycle(n int, edges [][]int) []int {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef distance_to_cycle(n, edges)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def distanceToCycle(n: Int, edges: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn distance_to_cycle(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (distance-to-cycle n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof exact-integer?))\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec distance_to_cycle(N :: integer(), Edges :: [[integer()]]) -> [integer()].\ndistance_to_cycle(N, Edges) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec distance_to_cycle(n :: integer, edges :: [[integer]]) :: [integer]\n  def distance_to_cycle(n, edges) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "paths-in-maze-that-lead-to-same-room", "title": "Paths in Maze That Lead to Same Room", "isPaidOnly": true}]}