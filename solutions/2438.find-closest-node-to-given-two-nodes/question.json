{"question_id": "2438", "problem_slug": "find-closest-node-to-given-two-nodes", "problem_title": "Find Closest Node to Given Two Nodes", "content": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.\n \nExample 1:\n\n\nInput: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\nExample 2:\n\n\nInput: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n\n \nConstraints:\n\nn == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n\n\n", "hints": ["How can you find the shortest distance from one node to all nodes in the graph?", "Use BFS to find the shortest distance from both node1 and node2 to all nodes in the graph. Then iterate over all nodes, and find the node with the minimum max distance."], "exampleTestcases": "[2,2,3,-1]\n0\n1\n[1,2,-1]\n0\n2", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def closestMeetingNode(self, edges, node1, node2):\n        \"\"\"\n        :type edges: List[int]\n        :type node1: int\n        :type node2: int\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        "}, "C": {"langSlug": "c", "code": "int closestMeetingNode(int* edges, int edgesSize, int node1, int node2) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int ClosestMeetingNode(int[] edges, int node1, int node2) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} edges\n * @param {number} node1\n * @param {number} node2\n * @return {number}\n */\nvar closestMeetingNode = function(edges, node1, node2) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function closestMeetingNode(edges: number[], node1: number, node2: number): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $edges\n     * @param Integer $node1\n     * @param Integer $node2\n     * @return Integer\n     */\n    function closestMeetingNode($edges, $node1, $node2) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func closestMeetingNode(_ edges: [Int], _ node1: Int, _ node2: Int) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int closestMeetingNode(List<int> edges, int node1, int node2) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func closestMeetingNode(edges []int, node1 int, node2 int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} edges\n# @param {Integer} node1\n# @param {Integer} node2\n# @return {Integer}\ndef closest_meeting_node(edges, node1, node2)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def closestMeetingNode(edges: Array[Int], node1: Int, node2: Int): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn closest_meeting_node(edges: Vec<i32>, node1: i32, node2: i32) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (closest-meeting-node edges node1 node2)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec closest_meeting_node(Edges :: [integer()], Node1 :: integer(), Node2 :: integer()) -> integer().\nclosest_meeting_node(Edges, Node1, Node2) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec closest_meeting_node(edges :: [integer], node1 :: integer, node2 :: integer) :: integer\n  def closest_meeting_node(edges, node1, node2) do\n    \n  end\nend"}}}