{"question_id": "2740", "problem_slug": "curry", "problem_title": "Curry", "content": "Given a function fn, return a curried version of that function.\nA curried function is a function that accepts fewer or an equal number of parameters as the original function and returns either another curried function or the same value the original function would have returned.\nIn practical terms, if you called the original function like sum(1,2,3), you would call the curried version like csum(1)(2)(3), csum(1)(2,3), csum(1,2)(3), or csum(1,2,3). All these methods of calling the curried function should return the same value as the original.\n \nExample 1:\n\nInput: \nfn = function sum(a, b, c) { return a + b + c; }\ninputs = [[1],[2],[3]]\nOutput: 6\nExplanation:\nThe code being executed is:\nconst curriedSum = curry(fn);\ncurriedSum(1)(2)(3) === 6;\ncurriedSum(1)(2)(3) should return the same value as sum(1, 2, 3).\n\nExample 2:\n\nInput:\nfn = function sum(a, b, c) { return a + b + c; }\ninputs = [[1,2],[3]]\nOutput: 6\nExplanation:\ncurriedSum(1, 2)(3) should return the same value as sum(1, 2, 3).\nExample 3:\n\nInput:\nfn = function sum(a, b, c) { return a + b + c; }\ninputs = [[],[],[1,2,3]]\nOutput: 6\nExplanation:\nYou should be able to pass the parameters in any way, including all at once or none at all.\ncurriedSum()()(1, 2, 3) should return the same value as sum(1, 2, 3).\n\nExample 4:\n\nInput:\nfn = function life() { return 42; }\ninputs = [[]]\nOutput: 42\nExplanation:\ncurrying a function that accepts zero parameters should effectively do nothing.\ncurriedLife() === 42\n\n \nConstraints:\n\n1 <= inputs.length <= 1000\n0 <= inputs[i][j] <= 105\n0 <= fn.length <= 1000\ninputs.flat().length == fn.length\nfunction parameters explicitly defined\nIf fn.length > 0 then the last array in inputs is not empty\nIf fn.length === 0 then inputs.length === 1 \n\n", "hints": ["You can access the count of parameters expected to passed into a function with \"fn.length\".", "You can use recursion. If the length of params passed is equal to fn.length, you are done. Just pass those params to fn. Otherwise return a function that is includes the previous passed params plus the new params. The new function should contain a recursive call to curry()."], "exampleTestcases": "function sum(a, b, c) { return a + b + c; }\n[[1],[2],[3]]\nfunction sum(a, b, c) { return a + b + c; }\n[[1,2],[3]]\nfunction sum(a, b, c) { return a + b + c; }\n[[],[],[1,2,3]]\nfunction life() { return 42; }\n[[]]", "codeSnippets": {"JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {Function} fn\n * @return {Function}\n */\nvar curry = function(fn) {\n    \n    return function curried(...args) {\n        \n    }\n};\n\n/**\n * function sum(a, b) { return a + b; }\n * const csum = curry(sum);\n * csum(1)(2) // 3\n */\n"}, "TypeScript": {"langSlug": "typescript", "code": "function curry(fn: Function): Function {\n    \n    return function curried(...args) {\n        \n    }\n};\n\n/**\n * function sum(a, b) { return a + b; }\n * const csum = curry(sum);\n * csum(1)(2) // 3\n */\n"}}}