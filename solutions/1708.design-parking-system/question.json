{"question_id": "1708", "problem_slug": "design-parking-system", "problem_title": "Design Parking System", "content": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\nImplement the ParkingSystem class:\n\nParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.\nbool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.\n\n \nExample 1:\n\nInput\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\nOutput\n[null, true, true, false, false]\n\nExplanation\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\n\n \nConstraints:\n\n0 <= big, medium, small <= 1000\ncarType is 1, 2, or 3\nAt most 1000 calls will be made to addCar\n\n", "hints": ["Record number of parking slots still available for each car type."], "exampleTestcases": "[\"ParkingSystem\",\"addCar\",\"addCar\",\"addCar\",\"addCar\"]\n[[1,1,0],[1],[2],[3],[1]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class ParkingSystem {\npublic:\n    ParkingSystem(int big, int medium, int small) {\n        \n    }\n    \n    bool addCar(int carType) {\n        \n    }\n};\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem* obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj->addCar(carType);\n */"}, "Java": {"langSlug": "java", "code": "class ParkingSystem {\n\n    public ParkingSystem(int big, int medium, int small) {\n        \n    }\n    \n    public boolean addCar(int carType) {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem obj = new ParkingSystem(big, medium, small);\n * boolean param_1 = obj.addCar(carType);\n */"}, "Python": {"langSlug": "python", "code": "class ParkingSystem(object):\n\n    def __init__(self, big, medium, small):\n        \"\"\"\n        :type big: int\n        :type medium: int\n        :type small: int\n        \"\"\"\n        \n\n    def addCar(self, carType):\n        \"\"\"\n        :type carType: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)"}, "Python3": {"langSlug": "python3", "code": "class ParkingSystem:\n\n    def __init__(self, big: int, medium: int, small: int):\n        \n\n    def addCar(self, carType: int) -> bool:\n        \n\n\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem(big, medium, small)\n# param_1 = obj.addCar(carType)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} ParkingSystem;\n\n\nParkingSystem* parkingSystemCreate(int big, int medium, int small) {\n    \n}\n\nbool parkingSystemAddCar(ParkingSystem* obj, int carType) {\n    \n}\n\nvoid parkingSystemFree(ParkingSystem* obj) {\n    \n}\n\n/**\n * Your ParkingSystem struct will be instantiated and called as such:\n * ParkingSystem* obj = parkingSystemCreate(big, medium, small);\n * bool param_1 = parkingSystemAddCar(obj, carType);\n \n * parkingSystemFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class ParkingSystem {\n\n    public ParkingSystem(int big, int medium, int small) {\n        \n    }\n    \n    public bool AddCar(int carType) {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj.AddCar(carType);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} big\n * @param {number} medium\n * @param {number} small\n */\nvar ParkingSystem = function(big, medium, small) {\n    \n};\n\n/** \n * @param {number} carType\n * @return {boolean}\n */\nParkingSystem.prototype.addCar = function(carType) {\n    \n};\n\n/** \n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new ParkingSystem(big, medium, small)\n * var param_1 = obj.addCar(carType)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class ParkingSystem {\n    constructor(big: number, medium: number, small: number) {\n        \n    }\n\n    addCar(carType: number): boolean {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = new ParkingSystem(big, medium, small)\n * var param_1 = obj.addCar(carType)\n */"}, "PHP": {"langSlug": "php", "code": "class ParkingSystem {\n    /**\n     * @param Integer $big\n     * @param Integer $medium\n     * @param Integer $small\n     */\n    function __construct($big, $medium, $small) {\n        \n    }\n  \n    /**\n     * @param Integer $carType\n     * @return Boolean\n     */\n    function addCar($carType) {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * $obj = ParkingSystem($big, $medium, $small);\n * $ret_1 = $obj->addCar($carType);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass ParkingSystem {\n\n    init(_ big: Int, _ medium: Int, _ small: Int) {\n        \n    }\n    \n    func addCar(_ carType: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * let obj = ParkingSystem(big, medium, small)\n * let ret_1: Bool = obj.addCar(carType)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class ParkingSystem(big: Int, medium: Int, small: Int) {\n\n    fun addCar(carType: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * var obj = ParkingSystem(big, medium, small)\n * var param_1 = obj.addCar(carType)\n */"}, "Dart": {"langSlug": "dart", "code": "class ParkingSystem {\n\n  ParkingSystem(int big, int medium, int small) {\n    \n  }\n  \n  bool addCar(int carType) {\n    \n  }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem obj = ParkingSystem(big, medium, small);\n * bool param1 = obj.addCar(carType);\n */"}, "Go": {"langSlug": "golang", "code": "type ParkingSystem struct {\n    \n}\n\n\nfunc Constructor(big int, medium int, small int) ParkingSystem {\n    \n}\n\n\nfunc (this *ParkingSystem) AddCar(carType int) bool {\n    \n}\n\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * obj := Constructor(big, medium, small);\n * param_1 := obj.AddCar(carType);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class ParkingSystem\n\n=begin\n    :type big: Integer\n    :type medium: Integer\n    :type small: Integer\n=end\n    def initialize(big, medium, small)\n        \n    end\n\n\n=begin\n    :type car_type: Integer\n    :rtype: Boolean\n=end\n    def add_car(car_type)\n        \n    end\n\n\nend\n\n# Your ParkingSystem object will be instantiated and called as such:\n# obj = ParkingSystem.new(big, medium, small)\n# param_1 = obj.add_car(car_type)"}, "Scala": {"langSlug": "scala", "code": "class ParkingSystem(_big: Int, _medium: Int, _small: Int) {\n\n    def addCar(carType: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * val obj = new ParkingSystem(big, medium, small)\n * val param_1 = obj.addCar(carType)\n */"}, "Rust": {"langSlug": "rust", "code": "struct ParkingSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl ParkingSystem {\n\n    fn new(big: i32, medium: i32, small: i32) -> Self {\n        \n    }\n    \n    fn add_car(&self, car_type: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * let obj = ParkingSystem::new(big, medium, small);\n * let ret_1: bool = obj.add_car(carType);\n */"}, "Racket": {"langSlug": "racket", "code": "(define parking-system%\n  (class object%\n    (super-new)\n    \n    ; big : exact-integer?\n    ; medium : exact-integer?\n    ; small : exact-integer?\n    (init-field\n      big\n      medium\n      small)\n    \n    ; add-car : exact-integer? -> boolean?\n    (define/public (add-car car-type)\n      )))\n\n;; Your parking-system% object will be instantiated and called as such:\n;; (define obj (new parking-system% [big big] [medium medium] [small small]))\n;; (define param_1 (send obj add-car car-type))"}, "Erlang": {"langSlug": "erlang", "code": "-spec parking_system_init_(Big :: integer(), Medium :: integer(), Small :: integer()) -> any().\nparking_system_init_(Big, Medium, Small) ->\n  .\n\n-spec parking_system_add_car(CarType :: integer()) -> boolean().\nparking_system_add_car(CarType) ->\n  .\n\n\n%% Your functions will be called as such:\n%% parking_system_init_(Big, Medium, Small),\n%% Param_1 = parking_system_add_car(CarType),\n\n%% parking_system_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule ParkingSystem do\n  @spec init_(big :: integer, medium :: integer, small :: integer) :: any\n  def init_(big, medium, small) do\n    \n  end\n\n  @spec add_car(car_type :: integer) :: boolean\n  def add_car(car_type) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# ParkingSystem.init_(big, medium, small)\n# param_1 = ParkingSystem.add_car(car_type)\n\n# ParkingSystem.init_ will be called before every test case, in which you can do some necessary initializations."}}}