{"questionId": "2806", "acRate": 62.36162361623616, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "2756", "paidOnly": true, "status": "ac", "title": "Query Batching", "titleSlug": "query-batching", "topicTags": [], "content": "<p>Batching multiple small queries into a single large query can be a useful optimization. Write a class&nbsp;<code>QueryBatcher</code>&nbsp;that implements this functionality.</p>\n\n<p>The constructor should accept two parameters:</p>\n\n<ul>\n\t<li>An asynchronous function&nbsp;<code>queryMultiple</code>&nbsp;which accepts an array of&nbsp;string keys <code>input</code>. It will resolve with an array of values that is the same length as the input array. Each index corresponds to the value associated with&nbsp;<code>input[i]</code>.&nbsp;You can assume the promise will never reject.</li>\n\t<li>A throttle time in milliseconds&nbsp;<code>t</code>.</li>\n</ul>\n\n<p>The class has a single method.</p>\n\n<ul>\n\t<li><code>async getValue(key)</code>. Accepts a single string key and resolves with a single string value. The keys passed to this function should eventually get passed to the&nbsp;<code>queryMultiple</code>&nbsp;function.&nbsp;<code>queryMultiple</code>&nbsp;should never be called consecutively within&nbsp;<code>t</code>&nbsp;milliseconds. The first time&nbsp;<code>getValue</code>&nbsp;is called,&nbsp;<code>queryMultiple</code>&nbsp;should immediately be called with that single key. If after&nbsp;<code>t</code>&nbsp;milliseconds,&nbsp;<code>getValue</code>&nbsp;had been called again, all the passed keys should be passed to&nbsp;<code>queryMultiple</code>&nbsp;and ultimately returned. You can assume every key passed to this method is unique.</li>\n</ul>\n\n<p>The following diagram illustrates how the throttling algorithm works. Each rectangle represents 100ms. The throttle time is 400ms.</p>\n\n<p><img alt=\"Throttle info\" src=\"https://assets.leetcode.com/uploads/2023/04/22/throttle.png\" style=\"width: 622px; height: 200px;\" /></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nqueryMultiple = async function(keys) { \n&nbsp; return keys.map(key =&gt; key + &#39;!&#39;);\n}\nt = 100 \ncalls = [\n&nbsp;{&quot;key&quot;: &quot;a&quot;, &quot;time&quot;: 10}, \n&nbsp;{&quot;key&quot;: &quot;b&quot;, &quot;time&quot;: 20}, \n&nbsp;{&quot;key&quot;: &quot;c&quot;, &quot;time&quot;: 30}\n]\n<strong>Output:</strong> [\n&nbsp;{&quot;resolved&quot;: &quot;a!&quot;, &quot;time&quot;: 10},\n&nbsp;{&quot;resolved&quot;: &quot;b!&quot;, &quot;time&quot;: 110},\n&nbsp;{&quot;resolved&quot;: &quot;c!&quot;, &quot;time&quot;: 110}\n]\n<strong>Explanation:</strong>\nconst batcher = new QueryBatcher(queryMultiple, 100);\nsetTimeout(() =&gt; batcher.getValue(&#39;a&#39;), 10); // &quot;a!&quot; at t=10ms\nsetTimeout(() =&gt; batcher.getValue(&#39;b&#39;), 20); // &quot;b!&quot; at t=110ms\nsetTimeout(() =&gt; batcher.getValue(&#39;c&#39;), 30); // &quot;c!&quot; at t=110ms\n\nqueryMultiple simply adds an &quot;!&quot; to the key\nAt t=10ms, getValue(&#39;a&#39;) is called, queryMultiple([&#39;a&#39;]) is immediately called and the result is immediately returned.\nAt t=20ms, getValue(&#39;b&#39;) is called but the query is queued\nAt t=30ms, getValue(&#39;c&#39;) is called but the query is queued.\nAt t=110ms, queryMultiple([&#39;a&#39;, &#39;b&#39;]) is called and the results are immediately returned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nqueryMultiple = async function(keys) {\n&nbsp; await new Promise(res =&gt; setTimeout(res, 100));\n&nbsp; return keys.map(key =&gt; key + &#39;!&#39;);\n}\nt = 100\ncalls = [\n&nbsp;{&quot;key&quot;: &quot;a&quot;, &quot;time&quot;: 10},\n&nbsp;{&quot;key&quot;: &quot;b&quot;, &quot;time&quot;: 20},\n&nbsp;{&quot;key&quot;: &quot;c&quot;, &quot;time&quot;: 30}\n]\n<strong>Output:</strong> [\n&nbsp; {&quot;resolved&quot;: &quot;a!&quot;, &quot;time&quot;: 110},\n&nbsp; {&quot;resolved&quot;: &quot;b!&quot;, &quot;time&quot;: 210},\n&nbsp; {&quot;resolved&quot;: &quot;c!&quot;, &quot;time&quot;: 210}\n]\n<strong>Explanation:</strong>\nThis example is the same as example 1 except there is a 100ms delay in queryMultiple. The results are the same except the promises resolve 100ms later.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nqueryMultiple = async function(keys) { \n&nbsp; await new Promise(res =&gt; setTimeout(res, keys.length * 100)); \n&nbsp; return keys.map(key =&gt; key + &#39;!&#39;);\n}\nt = 100\ncalls = [\n&nbsp; {&quot;key&quot;: &quot;a&quot;, &quot;time&quot;: 10}, \n  {&quot;key&quot;: &quot;b&quot;, &quot;time&quot;: 20}, \n&nbsp; {&quot;key&quot;: &quot;c&quot;, &quot;time&quot;: 30}, \n  {&quot;key&quot;: &quot;d&quot;, &quot;time&quot;: 40}, \n&nbsp; {&quot;key&quot;: &quot;e&quot;, &quot;time&quot;: 250}\n&nbsp; {&quot;key&quot;: &quot;f&quot;, &quot;time&quot;: 300}\n]\n<strong>Output:</strong> [\n&nbsp; {&quot;resolved&quot;:&quot;a!&quot;,&quot;time&quot;:110},\n&nbsp; {&quot;resolved&quot;:&quot;e!&quot;,&quot;time&quot;:350},\n&nbsp; {&quot;resolved&quot;:&quot;b!&quot;,&quot;time&quot;:410},\n&nbsp; {&quot;resolved&quot;:&quot;c!&quot;,&quot;time&quot;:410},\n&nbsp; {&quot;resolved&quot;:&quot;d!&quot;,&quot;time&quot;:410},\n  {&quot;resolved&quot;:&quot;f!&quot;,&quot;time&quot;:450}\n]\n<strong>Explanation:\n</strong>queryMultiple([&#39;a&#39;]) is called at t=10ms, it is resolved at t=110ms\nqueryMultiple([&#39;b&#39;, &#39;c&#39;, &#39;d&#39;]) is called at t=110ms, it is resolved at 410ms\nqueryMultiple([&#39;e&#39;]) is called at t=250ms, it is resolved at 350ms\nqueryMultiple([&#39;f&#39;]) is called at t=350ms, it is resolved at 450ms\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= t &lt;= 1000</code></li>\n\t<li><code>0 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= key.length&nbsp;&lt;= 100</code></li>\n\t<li>All keys are unique</li>\n</ul>\n", "hints": [], "exampleTestcases": "async function(keys) { return keys.map(key => key + '!'); }\n100\n[{\"key\": \"a\", \"time\": 10}, {\"key\": \"b\", \"time\": 20}, {\"key\": \"c\", \"time\": 30}]\nasync function(keys) { await new Promise(res => setTimeout(res, 100)); return keys.map(key => key + '!'); }\n100\n[{\"key\": \"a\", \"time\": 10}, {\"key\": \"b\", \"time\": 20}, {\"key\": \"c\", \"time\": 30}]\nasync function(keys) { await new Promise(res => setTimeout(res, keys.length * 100)); return keys.map(key => key + '!'); }\n100\n[{\"key\": \"a\", \"time\": 10}, {\"key\": \"b\", \"time\": 20}, {\"key\": \"c\", \"time\": 30}, {\"key\": \"d\", \"time\": 40}, {\"key\": \"e\", \"time\": 250}, {\"key\": \"f\", \"time\": 300}]", "codeSnippets": [{"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {Function} queryMultiple\n * @param {number} t\n * @return {void}\n */\nvar QueryBatcher = function(queryMultiple, t) {\n    \n};\n\n/**\n * @param {string} key\n * @return {Promise<string>}\n */\nQueryBatcher.prototype.getValue = async function(key) {\n    \n};\n\n/**\n * async function queryMultiple(keys) { \n *   return keys.map(key => key + '!');\n * }\n *\n * const batcher = new QueryBatcher(queryMultiple, 100);\n * batcher.getValue('a').then(console.log); // resolves \"a!\" at t=0ms \n * batcher.getValue('b').then(console.log); // resolves \"b!\" at t=100ms \n * batcher.getValue('c').then(console.log); // resolves \"c!\" at t=100ms \n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "type QueryMultiple = (keys: string[]) => Promise<string[]>\n\nclass QueryBatcher {\n    \n    constructor(queryMultiple: QueryMultiple, t: number) {\n        \n    }\n    \n    async getValue(key: string): Promise<string> {\n        \n    }\n};\n\n/**\n * async function queryMultiple(keys) { \n *   return keys.map(key => key + '!');\n * }\n *\n * const batcher = new QueryBatcher(queryMultiple, 100);\n * batcher.getValue('a').then(console.log); // resolves \"a!\" at t=0ms \n * batcher.getValue('b').then(console.log); // resolves \"b!\" at t=100ms \n * batcher.getValue('c').then(console.log); // resolves \"c!\" at t=100ms \n */"}], "similarQuestionList": []}