{"question_id": "1080", "problem_slug": "camelcase-matching", "problem_title": "Camelcase Matching", "content": "Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches pattern, and false otherwise.\nA query word queries[i] matches pattern if you can insert lowercase English letters pattern so that it equals the query. You may insert each character at any position and you may not insert any characters.\n \nExample 1:\n\nInput: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB\"\nOutput: [true,false,true,true,false]\nExplanation: \"FooBar\" can be generated like this \"F\" + \"oo\" + \"B\" + \"ar\".\n\"FootBall\" can be generated like this \"F\" + \"oot\" + \"B\" + \"all\".\n\"FrameBuffer\" can be generated like this \"F\" + \"rame\" + \"B\" + \"uffer\".\n\nExample 2:\n\nInput: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBa\"\nOutput: [true,false,true,false,false]\nExplanation: \"FooBar\" can be generated like this \"Fo\" + \"o\" + \"Ba\" + \"r\".\n\"FootBall\" can be generated like this \"Fo\" + \"ot\" + \"Ba\" + \"ll\".\n\nExample 3:\n\nInput: queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBaT\"\nOutput: [false,true,false,false,false]\nExplanation: \"FooBarTest\" can be generated like this \"Fo\" + \"o\" + \"Ba\" + \"r\" + \"T\" + \"est\".\n\n \nConstraints:\n\n1 <= pattern.length, queries.length <= 100\n1 <= queries[i].length <= 100\nqueries[i] and pattern consist of English letters.\n\n", "hints": ["Given a single pattern and word, how can we solve it?", "One way to do it is using a DP (pos1, pos2) where pos1 is a pointer to the word and pos2 to the pattern and returns true if we can match the pattern with the given word.", "We have two scenarios: The first one is when `word[pos1] == pattern[pos2]`, then the transition will be just DP(pos1 + 1, pos2 + 1). The second scenario is when `word[pos1]` is lowercase then we can add this character to the pattern so that the transition is just DP(pos1 + 1, pos2)\r\nThe case base is `if (pos1 == n && pos2 == m) return true;` Where n and m are the sizes of the strings word and pattern respectively."], "exampleTestcases": "[\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"]\n\"FB\"\n[\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"]\n\"FoBa\"\n[\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"]\n\"FoBaT\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<bool> camelMatch(vector<string>& queries, string pattern) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public List<Boolean> camelMatch(String[] queries, String pattern) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def camelMatch(self, queries, pattern):\n        \"\"\"\n        :type queries: List[str]\n        :type pattern: str\n        :rtype: List[bool]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nbool* camelMatch(char** queries, int queriesSize, char* pattern, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public IList<bool> CamelMatch(string[] queries, string pattern) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string[]} queries\n * @param {string} pattern\n * @return {boolean[]}\n */\nvar camelMatch = function(queries, pattern) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function camelMatch(queries: string[], pattern: string): boolean[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String[] $queries\n     * @param String $pattern\n     * @return Boolean[]\n     */\n    function camelMatch($queries, $pattern) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func camelMatch(_ queries: [String], _ pattern: String) -> [Bool] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun camelMatch(queries: Array<String>, pattern: String): List<Boolean> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<bool> camelMatch(List<String> queries, String pattern) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func camelMatch(queries []string, pattern string) []bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String[]} queries\n# @param {String} pattern\n# @return {Boolean[]}\ndef camel_match(queries, pattern)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def camelMatch(queries: Array[String], pattern: String): List[Boolean] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn camel_match(queries: Vec<String>, pattern: String) -> Vec<bool> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (camel-match queries pattern)\n  (-> (listof string?) string? (listof boolean?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec camel_match(Queries :: [unicode:unicode_binary()], Pattern :: unicode:unicode_binary()) -> [boolean()].\ncamel_match(Queries, Pattern) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec camel_match(queries :: [String.t], pattern :: String.t) :: [boolean]\n  def camel_match(queries, pattern) do\n    \n  end\nend"}}}