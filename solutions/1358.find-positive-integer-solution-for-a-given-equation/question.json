{"question_id": "1358", "problem_slug": "find-positive-integer-solution-for-a-given-equation", "problem_title": "Find Positive Integer Solution for a Given Equation", "content": "Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order.\nWhile the exact formula is hidden, the function is monotonically increasing, i.e.:\n\nf(x, y) < f(x + 1, y)\nf(x, y) < f(x, y + 1)\n\nThe function interface is defined like this:\n\ninterface CustomFunction {\npublic:\n  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.\n  int f(int x, int y);\n};\n\nWe will judge your solution as follows:\n\nThe judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z.\nThe judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z.\nThe judge will call your findSolution and compare your results with the answer key.\nIf your results match the answer key, your solution will be Accepted.\n\n \nExample 1:\n\nInput: function_id = 1, z = 5\nOutput: [[1,4],[2,3],[3,2],[4,1]]\nExplanation: The hidden formula for function_id = 1 is f(x, y) = x + y.\nThe following positive integer values of x and y make f(x, y) equal to 5:\nx=1, y=4 -> f(1, 4) = 1 + 4 = 5.\nx=2, y=3 -> f(2, 3) = 2 + 3 = 5.\nx=3, y=2 -> f(3, 2) = 3 + 2 = 5.\nx=4, y=1 -> f(4, 1) = 4 + 1 = 5.\n\nExample 2:\n\nInput: function_id = 2, z = 5\nOutput: [[1,5],[5,1]]\nExplanation: The hidden formula for function_id = 2 is f(x, y) = x * y.\nThe following positive integer values of x and y make f(x, y) equal to 5:\nx=1, y=5 -> f(1, 5) = 1 * 5 = 5.\nx=5, y=1 -> f(5, 1) = 5 * 1 = 5.\n\n \nConstraints:\n\n1 <= function_id <= 9\n1 <= z <= 100\nIt is guaranteed that the solutions of f(x, y) == z will be in the range 1 <= x, y <= 1000.\nIt is also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 <= x, y <= 1000.\n\n", "hints": ["Loop over 1 ≤ x,y ≤ 1000 and check if f(x,y) == z."], "exampleTestcases": "1\n5\n2\n5", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n * public:\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     int f(int x, int y);\n * };\n */\n\nclass Solution {\npublic:\n    vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     public int f(int x, int y);\n * };\n */\n\nclass Solution {\n    public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n\"\"\"\n\nclass Solution(object):\n    def findSolution(self, customfunction, z):\n        \"\"\"\n        :type num: int\n        :type z: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n  \n\"\"\"\n\nclass Solution:\n    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:\n        "}, "C": {"langSlug": "c", "code": "/*\n * // This is the definition for customFunction API.\n * // You should not implement it, or speculate about its implementation\n *\n * // Returns f(x, y) for any given positive integers x and y.\n * // Note that f(x, y) is increasing with respect to both x and y.\n * // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n */\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findSolution(int (*customFunction)(int, int), int z, int* returnSize, int** returnColumnSizes) {\n\t\n}"}, "C#": {"langSlug": "csharp", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * public class CustomFunction {\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     public int f(int x, int y);\n * };\n */\n\npublic class Solution {\n    public IList<IList<int>> FindSolution(CustomFunction customfunction, int z) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * // This is the CustomFunction's API interface.\n * // You should not implement it, or speculate about its implementation\n * function CustomFunction() {\n *     @param {integer, integer} x, y\n *     @return {integer}\n *     this.f = function(x, y) {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {CustomFunction} customfunction\n * @param {integer} z\n * @return {integer[][]}\n */\nvar findSolution = function(customfunction, z) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "/**\n * // This is the CustomFunction's API interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n *      f(x: number, y: number): number {}\n * }\n */\n\nfunction findSolution(customfunction: CustomFunction, z: number): number[][] {\n\t\n};"}, "PHP": {"langSlug": "php", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     public function f($x, $y){}\n * };\n */\n\nclass Solution {\n    /**\n     * @param  CustomFunction  $customfunction\n     * @param  Integer  $z\n     * @return Integer[][]\n     */\n    function findSolution($customfunction, $n) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     func f(_ x: Int, _ y: Int) -> Int {}\n * }\n */\n\nclass Solution {\n    func findSolution(_ customfunction: CustomFunction, _ z: Int) -> [[Int]] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     fun f(x:Int, y:Int):Int {}\n * };\n */\n\nclass Solution {\n\tfun findSolution(customfunction:CustomFunction, z:Int):List<List<Int>> {\n        \n    }\n}"}, "Go": {"langSlug": "golang", "code": "/** \n * This is the declaration of customFunction API.\n * @param  x    int\n * @param  x    int\n * @return \t    Returns f(x, y) for any given positive integers x and y.\n *\t\t\t    Note that f(x, y) is increasing with respect to both x and y.\n *              i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n */\n\nfunc findSolution(customFunction func(int, int) int, z int) [][]int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# \tThis is the custom function interface.\n#\tYou should not implement it, or speculate about its implementation\n#\tclass CustomFunction:\n#\t\tdef f(self, x, y):\n# \t\t\tReturns f(x, y) for any given positive integers x and y.\n# \t\t\tNote that f(x, y) is increasing with respect to both x and y.\n# \t\t\ti.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n# \t\tend\n# \tend\n# \n\n# @param {CustomFunction} customfunction\n# @param {Integer} z\n# @return {List[List[Integer]]}\ndef findSolution(customfunction, z)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * class CustomFunction {\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     def f(x: Int, y: Int): Int = {}\n * };\n */\n\nobject Solution {\n    def findSolution(customfunction: CustomFunction, z: Int): List[List[Int]] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * struct CustomFunction;\n * impl CustomFunction {\n *    pub fn f(x:i32,y:i32)->i32{}\n * }\n */\n\nimpl Solution {\n    pub fn find_solution(customfunction: &CustomFunction, z: i32) -> Vec<Vec<i32>> {\n\t\n    }\n}"}}}