{"question_id": "753", "problem_slug": "open-the-lock", "problem_title": "Open the Lock", "content": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n \nExample 1:\n\nInput: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\nOutput: 6\nExplanation: \nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n\nExample 2:\n\nInput: deadends = [\"8888\"], target = \"0009\"\nOutput: 1\nExplanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n\nExample 3:\n\nInput: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\nOutput: -1\nExplanation: We cannot reach the target without getting stuck.\n\n \nConstraints:\n\n1 <= deadends.length <= 500\ndeadends[i].length == 4\ntarget.length == 4\ntarget will not be in the list deadends.\ntarget and deadends[i] consist of digits only.\n\n", "hints": ["We can think of this problem as a shortest path problem on a graph: there are `10000` nodes (strings `'0000'` to `'9999'`), and there is an edge between two nodes if they differ in one digit, that digit differs by 1 (wrapping around, so `'0'` and `'9'` differ by 1), and if *both* nodes are not in `deadends`."], "exampleTestcases": "[\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"]\n\"0202\"\n[\"8888\"]\n\"0009\"\n[\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"]\n\"8888\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int openLock(vector<string>& deadends, string target) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int openLock(String[] deadends, String target) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def openLock(self, deadends, target):\n        \"\"\"\n        :type deadends: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        "}, "C": {"langSlug": "c", "code": "int openLock(char** deadends, int deadendsSize, char* target) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int OpenLock(string[] deadends, string target) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\nvar openLock = function(deadends, target) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function openLock(deadends: string[], target: string): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String[] $deadends\n     * @param String $target\n     * @return Integer\n     */\n    function openLock($deadends, $target) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func openLock(_ deadends: [String], _ target: String) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun openLock(deadends: Array<String>, target: String): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int openLock(List<String> deadends, String target) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func openLock(deadends []string, target string) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String[]} deadends\n# @param {String} target\n# @return {Integer}\ndef open_lock(deadends, target)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def openLock(deadends: Array[String], target: String): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn open_lock(deadends: Vec<String>, target: String) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (open-lock deadends target)\n  (-> (listof string?) string? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec open_lock(Deadends :: [unicode:unicode_binary()], Target :: unicode:unicode_binary()) -> integer().\nopen_lock(Deadends, Target) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec open_lock(deadends :: [String.t], target :: String.t) :: integer\n  def open_lock(deadends, target) do\n    \n  end\nend"}}}