{"questionId": "2815", "acRate": 51.959361393323654, "difficulty": "Medium", "freqBar": 54.65283902610856, "frontendQuestionId": "2655", "paidOnly": true, "status": "ac", "title": "Find Maximal Uncovered Ranges", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Sorting", "id": "VG9waWNUYWdOb2RlOjYxMDQ5", "slug": "sorting"}], "titleSlug": "find-maximal-uncovered-ranges", "content": "<p>You are given&nbsp;an integer <code>n</code>&nbsp;which is the length of a <strong>0-indexed</strong> array <code>nums</code>, and a <strong>0-indexed</strong> 2D-array <code>ranges</code>, which is a list of sub-ranges of <code>nums</code>&nbsp;(sub-ranges may <strong>overlap</strong>).</p>\n\n<p>Each row <code>ranges[i]</code> has exactly 2 cells:</p>\n\n<ul>\n\t<li><code>ranges[i][0]</code>, which shows the start of the i<sup>th</sup> range (inclusive)</li>\n\t<li><code>ranges[i][1]</code>, which shows the end of the i<sup>th</sup> range (inclusive)</li>\n</ul>\n\n<p>These ranges cover some cells of <code>nums</code>&nbsp;and leave&nbsp;some cells uncovered. Your task is to find all of the <b>uncovered </b>ranges with <strong>maximal</strong> length.</p>\n\n<p>Return <em>a 2D-array </em><code>answer</code><em> of the uncovered ranges, <strong>sorted</strong> by the starting point in <strong>ascending order</strong>.</em></p>\n\n<p>By all of the&nbsp;<strong>uncovered</strong> ranges with <strong>maximal</strong> length, we mean satisfying two conditions:</p>\n\n<ul>\n\t<li>Each uncovered cell should belong to <strong>exactly</strong> one sub-range</li>\n\t<li>There should <strong>not exist</strong>&nbsp;two ranges (l<sub>1</sub>, r<sub>1</sub>) and (l<sub>2</sub>, r<sub>2</sub>) such that r<sub>1 </sub>+ 1 = l<sub>2</sub></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10, ranges = [[3,5],[7,8]]\n<strong>Output:</strong> [[0,2],[6,6],[9,9]]\n<strong>Explanation:</strong> The ranges (3, 5) and (7, 8) are covered, so if we simplify the array nums to a binary array where 0 shows an uncovered cell and 1 shows a covered cell, the array becomes [0,0,0,1,1,1,0,1,1,0] in which we can observe that the ranges (0, 2), (6, 6) and (9, 9) aren&#39;t covered.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, ranges = [[0,2]]\n<strong>Output:</strong> []\n<strong>Explanation: </strong>In this example, the whole of the array nums is covered and there are no uncovered cells so the output is an empty array.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7, ranges = [[2,4],[0,3]]\n<strong>Output:</strong> [[5,6]]\n<strong>Explanation:</strong> The ranges (0, 3) and (2, 4) are covered, so if we simplify the array nums to a binary array where 0 shows an uncovered cell and 1 shows a covered cell, the array becomes [1,1,1,1,1,0,0] in which we can observe that the range (5, 6) is uncovered.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;=&nbsp;10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= ranges.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>ranges[i].length = 2</code></li>\n\t<li><code>0 &lt;= ranges[i][j] &lt;= n - 1</code></li>\n\t<li><code>ranges[i][0] &lt;=&nbsp;ranges[i][1]</code></li>\n</ul>\n", "hints": ["The complexity of the solution is independent of the length of the array nums.", "Sort ranges by their start points.", "An uncovered range should start right after the end of one of the input ranges (or starts at zero) and also ends right before the start of one of the input ranges (or ends at n)."], "exampleTestcases": "10\n[[3,5],[7,8]]\n3\n[[0,2]]\n7\n[[2,4],[0,3]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<vector<int>> findMaximalUncoveredRanges(int n, vector<vector<int>>& ranges) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public int[][] findMaximalUncoveredRanges(int n, int[][] ranges) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def findMaximalUncoveredRanges(self, n, ranges):\n        \"\"\"\n        :type n: int\n        :type ranges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def findMaximalUncoveredRanges(self, n: int, ranges: List[List[int]]) -> List[List[int]]:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findMaximalUncoveredRanges(int n, int** ranges, int rangesSize, int* rangesColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public int[][] FindMaximalUncoveredRanges(int n, int[][] ranges) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} ranges\n * @return {number[][]}\n */\nvar findMaximalUncoveredRanges = function(n, ranges) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function findMaximalUncoveredRanges(n: number, ranges: number[][]): number[][] {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $ranges\n     * @return Integer[][]\n     */\n    function findMaximalUncoveredRanges($n, $ranges) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func findMaximalUncoveredRanges(_ n: Int, _ ranges: [[Int]]) -> [[Int]] {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun findMaximalUncoveredRanges(n: Int, ranges: Array<IntArray>): Array<IntArray> {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  List<List<int>> findMaximalUncoveredRanges(int n, List<List<int>> ranges) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func findMaximalUncoveredRanges(n int, ranges [][]int) [][]int {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} ranges\n# @return {Integer[][]}\ndef find_maximal_uncovered_ranges(n, ranges)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def findMaximalUncoveredRanges(n: Int, ranges: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn find_maximal_uncovered_ranges(n: i32, ranges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (find-maximal-uncovered-ranges n ranges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec find_maximal_uncovered_ranges(N :: integer(), Ranges :: [[integer()]]) -> [[integer()]].\nfind_maximal_uncovered_ranges(N, Ranges) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec find_maximal_uncovered_ranges(n :: integer, ranges :: [[integer]]) :: [[integer]]\n  def find_maximal_uncovered_ranges(n, ranges) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Easy", "titleSlug": "missing-ranges", "title": "Missing Ranges", "isPaidOnly": true}, {"difficulty": "Easy", "titleSlug": "summary-ranges", "title": "Summary Ranges", "isPaidOnly": false}, {"difficulty": "Easy", "titleSlug": "check-if-all-the-integers-in-a-range-are-covered", "title": "Check if All the Integers in a Range Are Covered", "isPaidOnly": false}]}