{"question_id": "2815", "problem_slug": "find-maximal-uncovered-ranges", "problem_title": "Find Maximal Uncovered Ranges", "content": "You are given an integer n which is the length of a 0-indexed array nums, and a 0-indexed 2D-array ranges, which is a list of sub-ranges of nums (sub-ranges may overlap).\nEach row ranges[i] has exactly 2 cells:\n\nranges[i][0], which shows the start of the ith range (inclusive)\nranges[i][1], which shows the end of the ith range (inclusive)\n\nThese ranges cover some cells of nums and leave some cells uncovered. Your task is to find all of the uncovered ranges with maximal length.\nReturn a 2D-array answer of the uncovered ranges, sorted by the starting point in ascending order.\nBy all of the uncovered ranges with maximal length, we mean satisfying two conditions:\n\nEach uncovered cell should belong to exactly one sub-range\nThere should not exist two ranges (l1, r1) and (l2, r2) such that r1 + 1 = l2\n\n \nExample 1:\n\nInput: n = 10, ranges = [[3,5],[7,8]]\nOutput: [[0,2],[6,6],[9,9]]\nExplanation: The ranges (3, 5) and (7, 8) are covered, so if we simplify the array nums to a binary array where 0 shows an uncovered cell and 1 shows a covered cell, the array becomes [0,0,0,1,1,1,0,1,1,0] in which we can observe that the ranges (0, 2), (6, 6) and (9, 9) aren't covered.\n\nExample 2:\n\nInput: n = 3, ranges = [[0,2]]\nOutput: []\nExplanation: In this example, the whole of the array nums is covered and there are no uncovered cells so the output is an empty array.\n\nExample 3:\n\nInput: n = 7, ranges = [[2,4],[0,3]]\nOutput: [[5,6]]\nExplanation: The ranges (0, 3) and (2, 4) are covered, so if we simplify the array nums to a binary array where 0 shows an uncovered cell and 1 shows a covered cell, the array becomes [1,1,1,1,1,0,0] in which we can observe that the range (5, 6) is uncovered.\n\n \nConstraints:\n\n1 <= n <= 109\n0 <= ranges.length <= 106\nranges[i].length = 2\n0 <= ranges[i][j] <= n - 1\nranges[i][0] <= ranges[i][1]\n\n", "hints": ["The complexity of the solution is independent of the length of the array nums.", "Sort ranges by their start points.", "An uncovered range should start right after the end of one of the input ranges (or starts at zero) and also ends right before the start of one of the input ranges (or ends at n)."], "exampleTestcases": "10\n[[3,5],[7,8]]\n3\n[[0,2]]\n7\n[[2,4],[0,3]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<vector<int>> findMaximalUncoveredRanges(int n, vector<vector<int>>& ranges) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[][] findMaximalUncoveredRanges(int n, int[][] ranges) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def findMaximalUncoveredRanges(self, n, ranges):\n        \"\"\"\n        :type n: int\n        :type ranges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def findMaximalUncoveredRanges(self, n: int, ranges: List[List[int]]) -> List[List[int]]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findMaximalUncoveredRanges(int n, int** ranges, int rangesSize, int* rangesColSize, int* returnSize, int** returnColumnSizes){\n\n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[][] FindMaximalUncoveredRanges(int n, int[][] ranges) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} ranges\n * @return {number[][]}\n */\nvar findMaximalUncoveredRanges = function(n, ranges) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function findMaximalUncoveredRanges(n: number, ranges: number[][]): number[][] {\n\n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $ranges\n     * @return Integer[][]\n     */\n    function findMaximalUncoveredRanges($n, $ranges) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func findMaximalUncoveredRanges(_ n: Int, _ ranges: [[Int]]) -> [[Int]] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun findMaximalUncoveredRanges(n: Int, ranges: Array<IntArray>): Array<IntArray> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<List<int>> findMaximalUncoveredRanges(int n, List<List<int>> ranges) {\n\n  }\n}"}, "Go": {"langSlug": "golang", "code": "func findMaximalUncoveredRanges(n int, ranges [][]int) [][]int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} ranges\n# @return {Integer[][]}\ndef find_maximal_uncovered_ranges(n, ranges)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def findMaximalUncoveredRanges(n: Int, ranges: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn find_maximal_uncovered_ranges(n: i32, ranges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (find-maximal-uncovered-ranges n ranges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec find_maximal_uncovered_ranges(N :: integer(), Ranges :: [[integer()]]) -> [[integer()]].\nfind_maximal_uncovered_ranges(N, Ranges) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec find_maximal_uncovered_ranges(n :: integer, ranges :: [[integer]]) :: [[integer]]\n  def find_maximal_uncovered_ranges(n, ranges) do\n    \n  end\nend"}}}