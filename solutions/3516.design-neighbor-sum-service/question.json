{"question_id": "3516", "problem_slug": "design-neighbor-sum-service", "problem_title": "Design Neighbor Sum Service", "content": "You are given a n x n 2D array grid containing distinct elements in the range [0, n2 - 1].\nImplement the NeighborSum class:\n\nNeighborSum(int [][]grid) initializes the object.\nint adjacentSum(int value) returns the sum of elements which are adjacent neighbors of value, that is either to the top, left, right, or bottom of value in grid.\nint diagonalSum(int value) returns the sum of elements which are diagonal neighbors of value, that is either to the top-left, top-right, bottom-left, or bottom-right of value in grid.\n\n\n \nExample 1:\n\nInput:\n[\"NeighborSum\", \"adjacentSum\", \"adjacentSum\", \"diagonalSum\", \"diagonalSum\"]\n[[[[0, 1, 2], [3, 4, 5], [6, 7, 8]]], [1], [4], [4], [8]]\nOutput: [null, 6, 16, 16, 4]\nExplanation:\n\n\nThe adjacent neighbors of 1 are 0, 2, and 4.\nThe adjacent neighbors of 4 are 1, 3, 5, and 7.\nThe diagonal neighbors of 4 are 0, 2, 6, and 8.\nThe diagonal neighbor of 8 is 4.\n\n\nExample 2:\n\nInput:\n[\"NeighborSum\", \"adjacentSum\", \"diagonalSum\"]\n[[[[1, 2, 0, 3], [4, 7, 15, 6], [8, 9, 10, 11], [12, 13, 14, 5]]], [15], [9]]\nOutput: [null, 23, 45]\nExplanation:\n\n\nThe adjacent neighbors of 15 are 0, 10, 7, and 6.\nThe diagonal neighbors of 9 are 4, 12, 14, and 15.\n\n\n \nConstraints:\n\n3 <= n == grid.length == grid[0].length <= 10\n0 <= grid[i][j] <= n2 - 1\nAll grid[i][j] are distinct.\nvalue in adjacentSum and diagonalSum will be in the range [0, n2 - 1].\nAt most 2 * n2 calls will be made to adjacentSum and diagonalSum.\n\n", "hints": ["Find the cell <code>(i, j)</code> in which the element is present.", "You can store the coordinates for each value."], "exampleTestcases": "[\"NeighborSum\",\"adjacentSum\",\"adjacentSum\",\"diagonalSum\",\"diagonalSum\"]\n[[[[0,1,2],[3,4,5],[6,7,8]]],[1],[4],[4],[8]]\n[\"NeighborSum\",\"adjacentSum\",\"diagonalSum\"]\n[[[[1,2,0,3],[4,7,15,6],[8,9,10,11],[12,13,14,5]]],[15],[9]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class NeighborSum {\npublic:\n    NeighborSum(vector<vector<int>>& grid) {\n        \n    }\n    \n    int adjacentSum(int value) {\n        \n    }\n    \n    int diagonalSum(int value) {\n        \n    }\n};\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * NeighborSum* obj = new NeighborSum(grid);\n * int param_1 = obj->adjacentSum(value);\n * int param_2 = obj->diagonalSum(value);\n */"}, "Java": {"langSlug": "java", "code": "class NeighborSum {\n\n    public NeighborSum(int[][] grid) {\n        \n    }\n    \n    public int adjacentSum(int value) {\n        \n    }\n    \n    public int diagonalSum(int value) {\n        \n    }\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * NeighborSum obj = new NeighborSum(grid);\n * int param_1 = obj.adjacentSum(value);\n * int param_2 = obj.diagonalSum(value);\n */"}, "Python": {"langSlug": "python", "code": "class NeighborSum(object):\n\n    def __init__(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        \"\"\"\n        \n\n    def adjacentSum(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: int\n        \"\"\"\n        \n\n    def diagonalSum(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your NeighborSum object will be instantiated and called as such:\n# obj = NeighborSum(grid)\n# param_1 = obj.adjacentSum(value)\n# param_2 = obj.diagonalSum(value)"}, "Python3": {"langSlug": "python3", "code": "class NeighborSum:\n\n    def __init__(self, grid: List[List[int]]):\n        \n\n    def adjacentSum(self, value: int) -> int:\n        \n\n    def diagonalSum(self, value: int) -> int:\n        \n\n\n# Your NeighborSum object will be instantiated and called as such:\n# obj = NeighborSum(grid)\n# param_1 = obj.adjacentSum(value)\n# param_2 = obj.diagonalSum(value)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} NeighborSum;\n\n\nNeighborSum* neighborSumCreate(int** grid, int gridSize, int* gridColSize) {\n    \n}\n\nint neighborSumAdjacentSum(NeighborSum* obj, int value) {\n    \n}\n\nint neighborSumDiagonalSum(NeighborSum* obj, int value) {\n    \n}\n\nvoid neighborSumFree(NeighborSum* obj) {\n    \n}\n\n/**\n * Your NeighborSum struct will be instantiated and called as such:\n * NeighborSum* obj = neighborSumCreate(grid, gridSize, gridColSize);\n * int param_1 = neighborSumAdjacentSum(obj, value);\n \n * int param_2 = neighborSumDiagonalSum(obj, value);\n \n * neighborSumFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class NeighborSum {\n\n    public NeighborSum(int[][] grid) {\n        \n    }\n    \n    public int AdjacentSum(int value) {\n        \n    }\n    \n    public int DiagonalSum(int value) {\n        \n    }\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * NeighborSum obj = new NeighborSum(grid);\n * int param_1 = obj.AdjacentSum(value);\n * int param_2 = obj.DiagonalSum(value);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} grid\n */\nvar NeighborSum = function(grid) {\n    \n};\n\n/** \n * @param {number} value\n * @return {number}\n */\nNeighborSum.prototype.adjacentSum = function(value) {\n    \n};\n\n/** \n * @param {number} value\n * @return {number}\n */\nNeighborSum.prototype.diagonalSum = function(value) {\n    \n};\n\n/** \n * Your NeighborSum object will be instantiated and called as such:\n * var obj = new NeighborSum(grid)\n * var param_1 = obj.adjacentSum(value)\n * var param_2 = obj.diagonalSum(value)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class NeighborSum {\n    constructor(grid: number[][]) {\n        \n    }\n\n    adjacentSum(value: number): number {\n        \n    }\n\n    diagonalSum(value: number): number {\n        \n    }\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * var obj = new NeighborSum(grid)\n * var param_1 = obj.adjacentSum(value)\n * var param_2 = obj.diagonalSum(value)\n */"}, "PHP": {"langSlug": "php", "code": "class NeighborSum {\n    /**\n     * @param Integer[][] $grid\n     */\n    function __construct($grid) {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return Integer\n     */\n    function adjacentSum($value) {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return Integer\n     */\n    function diagonalSum($value) {\n        \n    }\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * $obj = NeighborSum($grid);\n * $ret_1 = $obj->adjacentSum($value);\n * $ret_2 = $obj->diagonalSum($value);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass NeighborSum {\n\n    init(_ grid: [[Int]]) {\n        \n    }\n    \n    func adjacentSum(_ value: Int) -> Int {\n        \n    }\n    \n    func diagonalSum(_ value: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * let obj = NeighborSum(grid)\n * let ret_1: Int = obj.adjacentSum(value)\n * let ret_2: Int = obj.diagonalSum(value)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class NeighborSum(grid: Array<IntArray>) {\n\n    fun adjacentSum(value: Int): Int {\n        \n    }\n\n    fun diagonalSum(value: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * var obj = NeighborSum(grid)\n * var param_1 = obj.adjacentSum(value)\n * var param_2 = obj.diagonalSum(value)\n */"}, "Dart": {"langSlug": "dart", "code": "class NeighborSum {\n\n  NeighborSum(List<List<int>> grid) {\n    \n  }\n  \n  int adjacentSum(int value) {\n    \n  }\n  \n  int diagonalSum(int value) {\n    \n  }\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * NeighborSum obj = NeighborSum(grid);\n * int param1 = obj.adjacentSum(value);\n * int param2 = obj.diagonalSum(value);\n */"}, "Go": {"langSlug": "golang", "code": "type NeighborSum struct {\n    \n}\n\n\nfunc Constructor(grid [][]int) NeighborSum {\n    \n}\n\n\nfunc (this *NeighborSum) AdjacentSum(value int) int {\n    \n}\n\n\nfunc (this *NeighborSum) DiagonalSum(value int) int {\n    \n}\n\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * obj := Constructor(grid);\n * param_1 := obj.AdjacentSum(value);\n * param_2 := obj.DiagonalSum(value);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class NeighborSum\n\n=begin\n    :type grid: Integer[][]\n=end\n    def initialize(grid)\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Integer\n=end\n    def adjacent_sum(value)\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Integer\n=end\n    def diagonal_sum(value)\n        \n    end\n\n\nend\n\n# Your NeighborSum object will be instantiated and called as such:\n# obj = NeighborSum.new(grid)\n# param_1 = obj.adjacent_sum(value)\n# param_2 = obj.diagonal_sum(value)"}, "Scala": {"langSlug": "scala", "code": "class NeighborSum(_grid: Array[Array[Int]]) {\n\n    def adjacentSum(value: Int): Int = {\n        \n    }\n\n    def diagonalSum(value: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * val obj = new NeighborSum(grid)\n * val param_1 = obj.adjacentSum(value)\n * val param_2 = obj.diagonalSum(value)\n */"}, "Rust": {"langSlug": "rust", "code": "struct NeighborSum {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NeighborSum {\n\n    fn new(grid: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn adjacent_sum(&self, value: i32) -> i32 {\n        \n    }\n    \n    fn diagonal_sum(&self, value: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your NeighborSum object will be instantiated and called as such:\n * let obj = NeighborSum::new(grid);\n * let ret_1: i32 = obj.adjacent_sum(value);\n * let ret_2: i32 = obj.diagonal_sum(value);\n */"}, "Racket": {"langSlug": "racket", "code": "(define neighbor-sum%\n  (class object%\n    (super-new)\n    \n    ; grid : (listof (listof exact-integer?))\n    (init-field\n      grid)\n    \n    ; adjacent-sum : exact-integer? -> exact-integer?\n    (define/public (adjacent-sum value)\n      )\n    ; diagonal-sum : exact-integer? -> exact-integer?\n    (define/public (diagonal-sum value)\n      )))\n\n;; Your neighbor-sum% object will be instantiated and called as such:\n;; (define obj (new neighbor-sum% [grid grid]))\n;; (define param_1 (send obj adjacent-sum value))\n;; (define param_2 (send obj diagonal-sum value))"}, "Erlang": {"langSlug": "erlang", "code": "-spec neighbor_sum_init_(Grid :: [[integer()]]) -> any().\nneighbor_sum_init_(Grid) ->\n  .\n\n-spec neighbor_sum_adjacent_sum(Value :: integer()) -> integer().\nneighbor_sum_adjacent_sum(Value) ->\n  .\n\n-spec neighbor_sum_diagonal_sum(Value :: integer()) -> integer().\nneighbor_sum_diagonal_sum(Value) ->\n  .\n\n\n%% Your functions will be called as such:\n%% neighbor_sum_init_(Grid),\n%% Param_1 = neighbor_sum_adjacent_sum(Value),\n%% Param_2 = neighbor_sum_diagonal_sum(Value),\n\n%% neighbor_sum_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule NeighborSum do\n  @spec init_(grid :: [[integer]]) :: any\n  def init_(grid) do\n    \n  end\n\n  @spec adjacent_sum(value :: integer) :: integer\n  def adjacent_sum(value) do\n    \n  end\n\n  @spec diagonal_sum(value :: integer) :: integer\n  def diagonal_sum(value) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# NeighborSum.init_(grid)\n# param_1 = NeighborSum.adjacent_sum(value)\n# param_2 = NeighborSum.diagonal_sum(value)\n\n# NeighborSum.init_ will be called before every test case, in which you can do some necessary initializations."}}}