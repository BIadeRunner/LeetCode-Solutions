{"question_id": "2375", "problem_slug": "minimum-obstacle-removal-to-reach-corner", "problem_title": "Minimum Obstacle Removal to Reach Corner", "content": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).\n \nExample 1:\n\n\nInput: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n\nExample 2:\n\n\nInput: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0\n\n", "hints": ["Model the grid as a graph where cells are nodes and edges are between adjacent cells. Edges to cells with obstacles have a cost of 1 and all other edges have a cost of 0.", "Could you use 0-1 Breadth-First Search or Dijkstra’s algorithm?"], "exampleTestcases": "[[0,1,1],[1,1,0],[1,1,0]]\n[[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int minimumObstacles(vector<vector<int>>& grid) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int minimumObstacles(int[][] grid) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def minimumObstacles(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        "}, "C": {"langSlug": "c", "code": "int minimumObstacles(int** grid, int gridSize, int* gridColSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int MinimumObstacles(int[][] grid) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minimumObstacles = function(grid) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function minimumObstacles(grid: number[][]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function minimumObstacles($grid) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func minimumObstacles(_ grid: [[Int]]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun minimumObstacles(grid: Array<IntArray>): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int minimumObstacles(List<List<int>> grid) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func minimumObstacles(grid [][]int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef minimum_obstacles(grid)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def minimumObstacles(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn minimum_obstacles(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (minimum-obstacles grid)\n  (-> (listof (listof exact-integer?)) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec minimum_obstacles(Grid :: [[integer()]]) -> integer().\nminimum_obstacles(Grid) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec minimum_obstacles(grid :: [[integer]]) :: integer\n  def minimum_obstacles(grid) do\n    \n  end\nend"}}}