{"question_id": "170", "problem_slug": "two-sum-iii-data-structure-design", "problem_title": "Two Sum III - Data structure design", "content": "Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a particular value.\nImplement the TwoSum class:\n\nTwoSum() Initializes the TwoSum object, with an empty array initially.\nvoid add(int number) Adds number to the data structure.\nboolean find(int value) Returns true if there exists any pair of numbers whose sum is equal to value, otherwise, it returns false.\n\n \nExample 1:\n\nInput\n[\"TwoSum\", \"add\", \"add\", \"add\", \"find\", \"find\"]\n[[], [1], [3], [5], [4], [7]]\nOutput\n[null, null, null, null, true, false]\n\nExplanation\nTwoSum twoSum = new TwoSum();\ntwoSum.add(1);   // [] --> [1]\ntwoSum.add(3);   // [1] --> [1,3]\ntwoSum.add(5);   // [1,3] --> [1,3,5]\ntwoSum.find(4);  // 1 + 3 = 4, return true\ntwoSum.find(7);  // No two integers sum up to 7, return false\n\n \nConstraints:\n\n-105 <= number <= 105\n-231 <= value <= 231 - 1\nAt most 104 calls will be made to add and find.\n\n", "hints": [], "exampleTestcases": "[\"TwoSum\",\"add\",\"add\",\"add\",\"find\",\"find\"]\n[[],[1],[3],[5],[4],[7]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class TwoSum {\npublic:\n    TwoSum() {\n        \n    }\n    \n    void add(int number) {\n        \n    }\n    \n    bool find(int value) {\n        \n    }\n};\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum* obj = new TwoSum();\n * obj->add(number);\n * bool param_2 = obj->find(value);\n */"}, "Java": {"langSlug": "java", "code": "class TwoSum {\n\n    public TwoSum() {\n        \n    }\n    \n    public void add(int number) {\n        \n    }\n    \n    public boolean find(int value) {\n        \n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum obj = new TwoSum();\n * obj.add(number);\n * boolean param_2 = obj.find(value);\n */"}, "Python": {"langSlug": "python", "code": "class TwoSum(object):\n\n    def __init__(self):\n        \n\n    def add(self, number):\n        \"\"\"\n        :type number: int\n        :rtype: None\n        \"\"\"\n        \n\n    def find(self, value):\n        \"\"\"\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your TwoSum object will be instantiated and called as such:\n# obj = TwoSum()\n# obj.add(number)\n# param_2 = obj.find(value)"}, "Python3": {"langSlug": "python3", "code": "class TwoSum:\n\n    def __init__(self):\n        \n\n    def add(self, number: int) -> None:\n        \n\n    def find(self, value: int) -> bool:\n        \n\n\n# Your TwoSum object will be instantiated and called as such:\n# obj = TwoSum()\n# obj.add(number)\n# param_2 = obj.find(value)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} TwoSum;\n\n\nTwoSum* twoSumCreate() {\n    \n}\n\nvoid twoSumAdd(TwoSum* obj, int number) {\n    \n}\n\nbool twoSumFind(TwoSum* obj, int value) {\n    \n}\n\nvoid twoSumFree(TwoSum* obj) {\n    \n}\n\n/**\n * Your TwoSum struct will be instantiated and called as such:\n * TwoSum* obj = twoSumCreate();\n * twoSumAdd(obj, number);\n \n * bool param_2 = twoSumFind(obj, value);\n \n * twoSumFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class TwoSum {\n\n    public TwoSum() {\n        \n    }\n    \n    public void Add(int number) {\n        \n    }\n    \n    public bool Find(int value) {\n        \n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum obj = new TwoSum();\n * obj.Add(number);\n * bool param_2 = obj.Find(value);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "\nvar TwoSum = function() {\n    \n};\n\n/** \n * @param {number} number\n * @return {void}\n */\nTwoSum.prototype.add = function(number) {\n    \n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nTwoSum.prototype.find = function(value) {\n    \n};\n\n/** \n * Your TwoSum object will be instantiated and called as such:\n * var obj = new TwoSum()\n * obj.add(number)\n * var param_2 = obj.find(value)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class TwoSum {\n    constructor() {\n        \n    }\n\n    add(number: number): void {\n        \n    }\n\n    find(value: number): boolean {\n        \n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * var obj = new TwoSum()\n * obj.add(number)\n * var param_2 = obj.find(value)\n */"}, "PHP": {"langSlug": "php", "code": "class TwoSum {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $number\n     * @return NULL\n     */\n    function add($number) {\n        \n    }\n  \n    /**\n     * @param Integer $value\n     * @return Boolean\n     */\n    function find($value) {\n        \n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * $obj = TwoSum();\n * $obj->add($number);\n * $ret_2 = $obj->find($value);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass TwoSum {\n\n    init() {\n        \n    }\n    \n    func add(_ number: Int) {\n        \n    }\n    \n    func find(_ value: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * let obj = TwoSum()\n * obj.add(number)\n * let ret_2: Bool = obj.find(value)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class TwoSum() {\n\n    fun add(number: Int) {\n        \n    }\n\n    fun find(value: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * var obj = TwoSum()\n * obj.add(number)\n * var param_2 = obj.find(value)\n */"}, "Dart": {"langSlug": "dart", "code": "class TwoSum {\n\n  TwoSum() {\n    \n  }\n  \n  void add(int number) {\n    \n  }\n  \n  bool find(int value) {\n    \n  }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * TwoSum obj = TwoSum();\n * obj.add(number);\n * bool param2 = obj.find(value);\n */"}, "Go": {"langSlug": "golang", "code": "type TwoSum struct {\n    \n}\n\n\nfunc Constructor() TwoSum {\n    \n}\n\n\nfunc (this *TwoSum) Add(number int)  {\n    \n}\n\n\nfunc (this *TwoSum) Find(value int) bool {\n    \n}\n\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(number);\n * param_2 := obj.Find(value);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class TwoSum\n    def initialize()\n        \n    end\n\n\n=begin\n    :type number: Integer\n    :rtype: Void\n=end\n    def add(number)\n        \n    end\n\n\n=begin\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def find(value)\n        \n    end\n\n\nend\n\n# Your TwoSum object will be instantiated and called as such:\n# obj = TwoSum.new()\n# obj.add(number)\n# param_2 = obj.find(value)"}, "Scala": {"langSlug": "scala", "code": "class TwoSum() {\n\n    def add(number: Int): Unit = {\n        \n    }\n\n    def find(value: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * val obj = new TwoSum()\n * obj.add(number)\n * val param_2 = obj.find(value)\n */"}, "Rust": {"langSlug": "rust", "code": "struct TwoSum {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl TwoSum {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn add(&self, number: i32) {\n        \n    }\n    \n    fn find(&self, value: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your TwoSum object will be instantiated and called as such:\n * let obj = TwoSum::new();\n * obj.add(number);\n * let ret_2: bool = obj.find(value);\n */"}, "Racket": {"langSlug": "racket", "code": "(define two-sum%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; add : exact-integer? -> void?\n    (define/public (add number)\n      )\n    ; find : exact-integer? -> boolean?\n    (define/public (find value)\n      )))\n\n;; Your two-sum% object will be instantiated and called as such:\n;; (define obj (new two-sum%))\n;; (send obj add number)\n;; (define param_2 (send obj find value))"}, "Erlang": {"langSlug": "erlang", "code": "-spec two_sum_init_() -> any().\ntwo_sum_init_() ->\n  .\n\n-spec two_sum_add(Number :: integer()) -> any().\ntwo_sum_add(Number) ->\n  .\n\n-spec two_sum_find(Value :: integer()) -> boolean().\ntwo_sum_find(Value) ->\n  .\n\n\n%% Your functions will be called as such:\n%% two_sum_init_(),\n%% two_sum_add(Number),\n%% Param_2 = two_sum_find(Value),\n\n%% two_sum_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule TwoSum do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec add(number :: integer) :: any\n  def add(number) do\n    \n  end\n\n  @spec find(value :: integer) :: boolean\n  def find(value) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# TwoSum.init_()\n# TwoSum.add(number)\n# param_2 = TwoSum.find(value)\n\n# TwoSum.init_ will be called before every test case, in which you can do some necessary initializations."}}}