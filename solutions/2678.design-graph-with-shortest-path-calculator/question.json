{"question_id": "2678", "problem_slug": "design-graph-with-shortest-path-calculator", "problem_title": "Design Graph With Shortest Path Calculator", "content": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.\n\n \nExample 1:\n\n\nInput\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n\n \nConstraints:\n\n1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath.\n\n", "hints": ["After adding each edge, update your graph with the new edge, and you can calculate the shortest path in your graph each time the shortestPath method is called.", "Use dijkstra’s algorithm to calculate the shortest paths."], "exampleTestcases": "[\"Graph\",\"shortestPath\",\"shortestPath\",\"addEdge\",\"shortestPath\"]\n[[4,[[0,2,5],[0,1,2],[1,2,1],[3,0,3]]],[3,2],[0,3],[[1,3,4]],[0,3]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Graph {\npublic:\n    Graph(int n, vector<vector<int>>& edges) {\n        \n    }\n    \n    void addEdge(vector<int> edge) {\n        \n    }\n    \n    int shortestPath(int node1, int node2) {\n        \n    }\n};\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph* obj = new Graph(n, edges);\n * obj->addEdge(edge);\n * int param_2 = obj->shortestPath(node1,node2);\n */"}, "Java": {"langSlug": "java", "code": "class Graph {\n\n    public Graph(int n, int[][] edges) {\n        \n    }\n    \n    public void addEdge(int[] edge) {\n        \n    }\n    \n    public int shortestPath(int node1, int node2) {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */"}, "Python": {"langSlug": "python", "code": "class Graph(object):\n\n    def __init__(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        \"\"\"\n        \n\n    def addEdge(self, edge):\n        \"\"\"\n        :type edge: List[int]\n        :rtype: None\n        \"\"\"\n        \n\n    def shortestPath(self, node1, node2):\n        \"\"\"\n        :type node1: int\n        :type node2: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph(n, edges)\n# obj.addEdge(edge)\n# param_2 = obj.shortestPath(node1,node2)"}, "Python3": {"langSlug": "python3", "code": "class Graph:\n\n    def __init__(self, n: int, edges: List[List[int]]):\n        \n\n    def addEdge(self, edge: List[int]) -> None:\n        \n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        \n\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph(n, edges)\n# obj.addEdge(edge)\n# param_2 = obj.shortestPath(node1,node2)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} Graph;\n\n\nGraph* graphCreate(int n, int** edges, int edgesSize, int* edgesColSize) {\n    \n}\n\nvoid graphAddEdge(Graph* obj, int* edge, int edgeSize) {\n    \n}\n\nint graphShortestPath(Graph* obj, int node1, int node2) {\n    \n}\n\nvoid graphFree(Graph* obj) {\n    \n}\n\n/**\n * Your Graph struct will be instantiated and called as such:\n * Graph* obj = graphCreate(n, edges, edgesSize, edgesColSize);\n * graphAddEdge(obj, edge, edgeSize);\n \n * int param_2 = graphShortestPath(obj, node1, node2);\n \n * graphFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class Graph {\n\n    public Graph(int n, int[][] edges) {\n        \n    }\n    \n    public void AddEdge(int[] edge) {\n        \n    }\n    \n    public int ShortestPath(int node1, int node2) {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.AddEdge(edge);\n * int param_2 = obj.ShortestPath(node1,node2);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n */\nvar Graph = function(n, edges) {\n    \n};\n\n/** \n * @param {number[]} edge\n * @return {void}\n */\nGraph.prototype.addEdge = function(edge) {\n    \n};\n\n/** \n * @param {number} node1 \n * @param {number} node2\n * @return {number}\n */\nGraph.prototype.shortestPath = function(node1, node2) {\n    \n};\n\n/** \n * Your Graph object will be instantiated and called as such:\n * var obj = new Graph(n, edges)\n * obj.addEdge(edge)\n * var param_2 = obj.shortestPath(node1,node2)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class Graph {\n    constructor(n: number, edges: number[][]) {\n        \n    }\n\n    addEdge(edge: number[]): void {\n        \n    }\n\n    shortestPath(node1: number, node2: number): number {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * var obj = new Graph(n, edges)\n * obj.addEdge(edge)\n * var param_2 = obj.shortestPath(node1,node2)\n */"}, "PHP": {"langSlug": "php", "code": "class Graph {\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     */\n    function __construct($n, $edges) {\n        \n    }\n  \n    /**\n     * @param Integer[] $edge\n     * @return NULL\n     */\n    function addEdge($edge) {\n        \n    }\n  \n    /**\n     * @param Integer $node1\n     * @param Integer $node2\n     * @return Integer\n     */\n    function shortestPath($node1, $node2) {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * $obj = Graph($n, $edges);\n * $obj->addEdge($edge);\n * $ret_2 = $obj->shortestPath($node1, $node2);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass Graph {\n\n    init(_ n: Int, _ edges: [[Int]]) {\n        \n    }\n    \n    func addEdge(_ edge: [Int]) {\n        \n    }\n    \n    func shortestPath(_ node1: Int, _ node2: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * let obj = Graph(n, edges)\n * obj.addEdge(edge)\n * let ret_2: Int = obj.shortestPath(node1, node2)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class Graph(n: Int, edges: Array<IntArray>) {\n\n    fun addEdge(edge: IntArray) {\n        \n    }\n\n    fun shortestPath(node1: Int, node2: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * var obj = Graph(n, edges)\n * obj.addEdge(edge)\n * var param_2 = obj.shortestPath(node1,node2)\n */"}, "Dart": {"langSlug": "dart", "code": "class Graph {\n\n  Graph(int n, List<List<int>> edges) {\n    \n  }\n  \n  void addEdge(List<int> edge) {\n    \n  }\n  \n  int shortestPath(int node1, int node2) {\n    \n  }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = Graph(n, edges);\n * obj.addEdge(edge);\n * int param2 = obj.shortestPath(node1,node2);\n */"}, "Go": {"langSlug": "golang", "code": "type Graph struct {\n    \n}\n\n\nfunc Constructor(n int, edges [][]int) Graph {\n    \n}\n\n\nfunc (this *Graph) AddEdge(edge []int)  {\n    \n}\n\n\nfunc (this *Graph) ShortestPath(node1 int, node2 int) int {\n    \n}\n\n\n/**\n * Your Graph object will be instantiated and called as such:\n * obj := Constructor(n, edges);\n * obj.AddEdge(edge);\n * param_2 := obj.ShortestPath(node1,node2);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class Graph\n\n=begin\n    :type n: Integer\n    :type edges: Integer[][]\n=end\n    def initialize(n, edges)\n        \n    end\n\n\n=begin\n    :type edge: Integer[]\n    :rtype: Void\n=end\n    def add_edge(edge)\n        \n    end\n\n\n=begin\n    :type node1: Integer\n    :type node2: Integer\n    :rtype: Integer\n=end\n    def shortest_path(node1, node2)\n        \n    end\n\n\nend\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph.new(n, edges)\n# obj.add_edge(edge)\n# param_2 = obj.shortest_path(node1, node2)"}, "Scala": {"langSlug": "scala", "code": "class Graph(_n: Int, _edges: Array[Array[Int]]) {\n\n    def addEdge(edge: Array[Int]): Unit = {\n        \n    }\n\n    def shortestPath(node1: Int, node2: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * val obj = new Graph(n, edges)\n * obj.addEdge(edge)\n * val param_2 = obj.shortestPath(node1,node2)\n */"}, "Rust": {"langSlug": "rust", "code": "struct Graph {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Graph {\n\n    fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn add_edge(&self, edge: Vec<i32>) {\n        \n    }\n    \n    fn shortest_path(&self, node1: i32, node2: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * let obj = Graph::new(n, edges);\n * obj.add_edge(edge);\n * let ret_2: i32 = obj.shortest_path(node1, node2);\n */"}, "Racket": {"langSlug": "racket", "code": "(define graph%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; edges : (listof (listof exact-integer?))\n    (init-field\n      n\n      edges)\n    \n    ; add-edge : (listof exact-integer?) -> void?\n    (define/public (add-edge edge)\n      )\n    ; shortest-path : exact-integer? exact-integer? -> exact-integer?\n    (define/public (shortest-path node1 node2)\n      )))\n\n;; Your graph% object will be instantiated and called as such:\n;; (define obj (new graph% [n n] [edges edges]))\n;; (send obj add-edge edge)\n;; (define param_2 (send obj shortest-path node1 node2))"}, "Erlang": {"langSlug": "erlang", "code": "-spec graph_init_(N :: integer(), Edges :: [[integer()]]) -> any().\ngraph_init_(N, Edges) ->\n  .\n\n-spec graph_add_edge(Edge :: [integer()]) -> any().\ngraph_add_edge(Edge) ->\n  .\n\n-spec graph_shortest_path(Node1 :: integer(), Node2 :: integer()) -> integer().\ngraph_shortest_path(Node1, Node2) ->\n  .\n\n\n%% Your functions will be called as such:\n%% graph_init_(N, Edges),\n%% graph_add_edge(Edge),\n%% Param_2 = graph_shortest_path(Node1, Node2),\n\n%% graph_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Graph do\n  @spec init_(n :: integer, edges :: [[integer]]) :: any\n  def init_(n, edges) do\n    \n  end\n\n  @spec add_edge(edge :: [integer]) :: any\n  def add_edge(edge) do\n    \n  end\n\n  @spec shortest_path(node1 :: integer, node2 :: integer) :: integer\n  def shortest_path(node1, node2) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Graph.init_(n, edges)\n# Graph.add_edge(edge)\n# param_2 = Graph.shortest_path(node1, node2)\n\n# Graph.init_ will be called before every test case, in which you can do some necessary initializations."}}}