{"question_id": "588", "problem_slug": "design-in-memory-file-system", "problem_title": "Design In-Memory File System", "content": "Design a data structure that simulates an in-memory file system.\nImplement the FileSystem class:\n\nFileSystem() Initializes the object of the system.\nList<String> ls(String path)\n\nIf path is a file path, returns a list that only contains this file's name.\nIf path is a directory path, returns the list of file and directory names in this directory.\n\n\tThe answer should in lexicographic order.\nvoid mkdir(String path) Makes a new directory according to the given path. The given directory path does not exist. If the middle directories in the path do not exist, you should create them as well.\nvoid addContentToFile(String filePath, String content)\n\nIf filePath does not exist, creates that file containing given content.\nIf filePath already exists, appends the given content to original content.\n\n\nString readContentFromFile(String filePath) Returns the content in the file at filePath.\n\n \nExample 1:\n\n\nInput\n[\"FileSystem\", \"ls\", \"mkdir\", \"addContentToFile\", \"ls\", \"readContentFromFile\"]\n[[], [\"/\"], [\"/a/b/c\"], [\"/a/b/c/d\", \"hello\"], [\"/\"], [\"/a/b/c/d\"]]\nOutput\n[null, [], null, null, [\"a\"], \"hello\"]\n\nExplanation\nFileSystem fileSystem = new FileSystem();\nfileSystem.ls(\"/\");                         // return []\nfileSystem.mkdir(\"/a/b/c\");\nfileSystem.addContentToFile(\"/a/b/c/d\", \"hello\");\nfileSystem.ls(\"/\");                         // return [\"a\"]\nfileSystem.readContentFromFile(\"/a/b/c/d\"); // return \"hello\"\n\n \nConstraints:\n\n1 <= path.length, filePath.length <= 100\npath and filePath are absolute paths which begin with '/' and do not end with '/' except that the path is just \"/\".\nYou can assume that all directory names and file names only contain lowercase letters, and the same names will not exist in the same directory.\nYou can assume that all operations will be passed valid parameters, and users will not attempt to retrieve file content or list a directory or file that does not exist.\n1 <= content.length <= 50\nAt most 300 calls will be made to ls, mkdir, addContentToFile, and readContentFromFile.\n\n", "hints": [], "exampleTestcases": "[\"FileSystem\",\"ls\",\"mkdir\",\"addContentToFile\",\"ls\",\"readContentFromFile\"]\n[[],[\"/\"],[\"/a/b/c\"],[\"/a/b/c/d\",\"hello\"],[\"/\"],[\"/a/b/c/d\"]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class FileSystem {\npublic:\n    FileSystem() {\n        \n    }\n    \n    vector<string> ls(string path) {\n        \n    }\n    \n    void mkdir(string path) {\n        \n    }\n    \n    void addContentToFile(string filePath, string content) {\n        \n    }\n    \n    string readContentFromFile(string filePath) {\n        \n    }\n};\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem* obj = new FileSystem();\n * vector<string> param_1 = obj->ls(path);\n * obj->mkdir(path);\n * obj->addContentToFile(filePath,content);\n * string param_4 = obj->readContentFromFile(filePath);\n */"}, "Java": {"langSlug": "java", "code": "class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public List<String> ls(String path) {\n        \n    }\n    \n    public void mkdir(String path) {\n        \n    }\n    \n    public void addContentToFile(String filePath, String content) {\n        \n    }\n    \n    public String readContentFromFile(String filePath) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * List<String> param_1 = obj.ls(path);\n * obj.mkdir(path);\n * obj.addContentToFile(filePath,content);\n * String param_4 = obj.readContentFromFile(filePath);\n */"}, "Python": {"langSlug": "python", "code": "class FileSystem(object):\n\n    def __init__(self):\n        \n\n    def ls(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: List[str]\n        \"\"\"\n        \n\n    def mkdir(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: None\n        \"\"\"\n        \n\n    def addContentToFile(self, filePath, content):\n        \"\"\"\n        :type filePath: str\n        :type content: str\n        :rtype: None\n        \"\"\"\n        \n\n    def readContentFromFile(self, filePath):\n        \"\"\"\n        :type filePath: str\n        :rtype: str\n        \"\"\"\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.ls(path)\n# obj.mkdir(path)\n# obj.addContentToFile(filePath,content)\n# param_4 = obj.readContentFromFile(filePath)"}, "Python3": {"langSlug": "python3", "code": "class FileSystem:\n\n    def __init__(self):\n        \n\n    def ls(self, path: str) -> List[str]:\n        \n\n    def mkdir(self, path: str) -> None:\n        \n\n    def addContentToFile(self, filePath: str, content: str) -> None:\n        \n\n    def readContentFromFile(self, filePath: str) -> str:\n        \n\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem()\n# param_1 = obj.ls(path)\n# obj.mkdir(path)\n# obj.addContentToFile(filePath,content)\n# param_4 = obj.readContentFromFile(filePath)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} FileSystem;\n\n\nFileSystem* fileSystemCreate() {\n    \n}\n\nchar** fileSystemLs(FileSystem* obj, char* path, int* retSize) {\n    \n}\n\nvoid fileSystemMkdir(FileSystem* obj, char* path) {\n    \n}\n\nvoid fileSystemAddContentToFile(FileSystem* obj, char* filePath, char* content) {\n    \n}\n\nchar* fileSystemReadContentFromFile(FileSystem* obj, char* filePath) {\n    \n}\n\nvoid fileSystemFree(FileSystem* obj) {\n    \n}\n\n/**\n * Your FileSystem struct will be instantiated and called as such:\n * FileSystem* obj = fileSystemCreate();\n * char** param_1 = fileSystemLs(obj, path, retSize);\n \n * fileSystemMkdir(obj, path);\n \n * fileSystemAddContentToFile(obj, filePath, content);\n \n * char* param_4 = fileSystemReadContentFromFile(obj, filePath);\n \n * fileSystemFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class FileSystem {\n\n    public FileSystem() {\n        \n    }\n    \n    public IList<string> Ls(string path) {\n        \n    }\n    \n    public void Mkdir(string path) {\n        \n    }\n    \n    public void AddContentToFile(string filePath, string content) {\n        \n    }\n    \n    public string ReadContentFromFile(string filePath) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * IList<string> param_1 = obj.Ls(path);\n * obj.Mkdir(path);\n * obj.AddContentToFile(filePath,content);\n * string param_4 = obj.ReadContentFromFile(filePath);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "\nvar FileSystem = function() {\n    \n};\n\n/** \n * @param {string} path\n * @return {string[]}\n */\nFileSystem.prototype.ls = function(path) {\n    \n};\n\n/** \n * @param {string} path\n * @return {void}\n */\nFileSystem.prototype.mkdir = function(path) {\n    \n};\n\n/** \n * @param {string} filePath \n * @param {string} content\n * @return {void}\n */\nFileSystem.prototype.addContentToFile = function(filePath, content) {\n    \n};\n\n/** \n * @param {string} filePath\n * @return {string}\n */\nFileSystem.prototype.readContentFromFile = function(filePath) {\n    \n};\n\n/** \n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class FileSystem {\n    constructor() {\n        \n    }\n\n    ls(path: string): string[] {\n        \n    }\n\n    mkdir(path: string): void {\n        \n    }\n\n    addContentToFile(filePath: string, content: string): void {\n        \n    }\n\n    readContentFromFile(filePath: string): string {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = new FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */"}, "PHP": {"langSlug": "php", "code": "class FileSystem {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @return String[]\n     */\n    function ls($path) {\n        \n    }\n  \n    /**\n     * @param String $path\n     * @return NULL\n     */\n    function mkdir($path) {\n        \n    }\n  \n    /**\n     * @param String $filePath\n     * @param String $content\n     * @return NULL\n     */\n    function addContentToFile($filePath, $content) {\n        \n    }\n  \n    /**\n     * @param String $filePath\n     * @return String\n     */\n    function readContentFromFile($filePath) {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * $obj = FileSystem();\n * $ret_1 = $obj->ls($path);\n * $obj->mkdir($path);\n * $obj->addContentToFile($filePath, $content);\n * $ret_4 = $obj->readContentFromFile($filePath);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass FileSystem {\n\n    init() {\n        \n    }\n    \n    func ls(_ path: String) -> [String] {\n        \n    }\n    \n    func mkdir(_ path: String) {\n        \n    }\n    \n    func addContentToFile(_ filePath: String, _ content: String) {\n        \n    }\n    \n    func readContentFromFile(_ filePath: String) -> String {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem()\n * let ret_1: [String] = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath, content)\n * let ret_4: String = obj.readContentFromFile(filePath)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class FileSystem() {\n\n    fun ls(path: String): List<String> {\n        \n    }\n\n    fun mkdir(path: String) {\n        \n    }\n\n    fun addContentToFile(filePath: String, content: String) {\n        \n    }\n\n    fun readContentFromFile(filePath: String): String {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * var obj = FileSystem()\n * var param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * var param_4 = obj.readContentFromFile(filePath)\n */"}, "Dart": {"langSlug": "dart", "code": "class FileSystem {\n\n  FileSystem() {\n    \n  }\n  \n  List<String> ls(String path) {\n    \n  }\n  \n  void mkdir(String path) {\n    \n  }\n  \n  void addContentToFile(String filePath, String content) {\n    \n  }\n  \n  String readContentFromFile(String filePath) {\n    \n  }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = FileSystem();\n * List<String> param1 = obj.ls(path);\n * obj.mkdir(path);\n * obj.addContentToFile(filePath,content);\n * String param4 = obj.readContentFromFile(filePath);\n */"}, "Go": {"langSlug": "golang", "code": "type FileSystem struct {\n    \n}\n\n\nfunc Constructor() FileSystem {\n    \n}\n\n\nfunc (this *FileSystem) Ls(path string) []string {\n    \n}\n\n\nfunc (this *FileSystem) Mkdir(path string)  {\n    \n}\n\n\nfunc (this *FileSystem) AddContentToFile(filePath string, content string)  {\n    \n}\n\n\nfunc (this *FileSystem) ReadContentFromFile(filePath string) string {\n    \n}\n\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Ls(path);\n * obj.Mkdir(path);\n * obj.AddContentToFile(filePath,content);\n * param_4 := obj.ReadContentFromFile(filePath);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class FileSystem\n    def initialize()\n        \n    end\n\n\n=begin\n    :type path: String\n    :rtype: String[]\n=end\n    def ls(path)\n        \n    end\n\n\n=begin\n    :type path: String\n    :rtype: Void\n=end\n    def mkdir(path)\n        \n    end\n\n\n=begin\n    :type file_path: String\n    :type content: String\n    :rtype: Void\n=end\n    def add_content_to_file(file_path, content)\n        \n    end\n\n\n=begin\n    :type file_path: String\n    :rtype: String\n=end\n    def read_content_from_file(file_path)\n        \n    end\n\n\nend\n\n# Your FileSystem object will be instantiated and called as such:\n# obj = FileSystem.new()\n# param_1 = obj.ls(path)\n# obj.mkdir(path)\n# obj.add_content_to_file(file_path, content)\n# param_4 = obj.read_content_from_file(file_path)"}, "Scala": {"langSlug": "scala", "code": "class FileSystem() {\n\n    def ls(path: String): List[String] = {\n        \n    }\n\n    def mkdir(path: String): Unit = {\n        \n    }\n\n    def addContentToFile(filePath: String, content: String): Unit = {\n        \n    }\n\n    def readContentFromFile(filePath: String): String = {\n        \n    }\n\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * val obj = new FileSystem()\n * val param_1 = obj.ls(path)\n * obj.mkdir(path)\n * obj.addContentToFile(filePath,content)\n * val param_4 = obj.readContentFromFile(filePath)\n */"}, "Rust": {"langSlug": "rust", "code": "struct FileSystem {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl FileSystem {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn ls(&self, path: String) -> Vec<String> {\n        \n    }\n    \n    fn mkdir(&self, path: String) {\n        \n    }\n    \n    fn add_content_to_file(&self, file_path: String, content: String) {\n        \n    }\n    \n    fn read_content_from_file(&self, file_path: String) -> String {\n        \n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * let obj = FileSystem::new();\n * let ret_1: Vec<String> = obj.ls(path);\n * obj.mkdir(path);\n * obj.add_content_to_file(filePath, content);\n * let ret_4: String = obj.read_content_from_file(filePath);\n */"}, "Racket": {"langSlug": "racket", "code": "(define file-system%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; ls : string? -> (listof string?)\n    (define/public (ls path)\n      )\n    ; mkdir : string? -> void?\n    (define/public (mkdir path)\n      )\n    ; add-content-to-file : string? string? -> void?\n    (define/public (add-content-to-file file-path content)\n      )\n    ; read-content-from-file : string? -> string?\n    (define/public (read-content-from-file file-path)\n      )))\n\n;; Your file-system% object will be instantiated and called as such:\n;; (define obj (new file-system%))\n;; (define param_1 (send obj ls path))\n;; (send obj mkdir path)\n;; (send obj add-content-to-file file-path content)\n;; (define param_4 (send obj read-content-from-file file-path))"}, "Erlang": {"langSlug": "erlang", "code": "-spec file_system_init_() -> any().\nfile_system_init_() ->\n  .\n\n-spec file_system_ls(Path :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nfile_system_ls(Path) ->\n  .\n\n-spec file_system_mkdir(Path :: unicode:unicode_binary()) -> any().\nfile_system_mkdir(Path) ->\n  .\n\n-spec file_system_add_content_to_file(FilePath :: unicode:unicode_binary(), Content :: unicode:unicode_binary()) -> any().\nfile_system_add_content_to_file(FilePath, Content) ->\n  .\n\n-spec file_system_read_content_from_file(FilePath :: unicode:unicode_binary()) -> unicode:unicode_binary().\nfile_system_read_content_from_file(FilePath) ->\n  .\n\n\n%% Your functions will be called as such:\n%% file_system_init_(),\n%% Param_1 = file_system_ls(Path),\n%% file_system_mkdir(Path),\n%% file_system_add_content_to_file(FilePath, Content),\n%% Param_4 = file_system_read_content_from_file(FilePath),\n\n%% file_system_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule FileSystem do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec ls(path :: String.t) :: [String.t]\n  def ls(path) do\n    \n  end\n\n  @spec mkdir(path :: String.t) :: any\n  def mkdir(path) do\n    \n  end\n\n  @spec add_content_to_file(file_path :: String.t, content :: String.t) :: any\n  def add_content_to_file(file_path, content) do\n    \n  end\n\n  @spec read_content_from_file(file_path :: String.t) :: String.t\n  def read_content_from_file(file_path) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# FileSystem.init_()\n# param_1 = FileSystem.ls(path)\n# FileSystem.mkdir(path)\n# FileSystem.add_content_to_file(file_path, content)\n# param_4 = FileSystem.read_content_from_file(file_path)\n\n# FileSystem.init_ will be called before every test case, in which you can do some necessary initializations."}}}