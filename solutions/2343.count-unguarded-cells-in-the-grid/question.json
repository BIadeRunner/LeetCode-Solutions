{"question_id": "2343", "problem_slug": "count-unguarded-cells-in-the-grid", "problem_title": "Count Unguarded Cells in the Grid", "content": "You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.\nA guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.\nReturn the number of unoccupied cells that are not guarded.\n \nExample 1:\n\n\nInput: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\nOutput: 7\nExplanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\nExample 2:\n\n\nInput: m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\nOutput: 4\nExplanation: The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n \nConstraints:\n\n1 <= m, n <= 105\n2 <= m * n <= 105\n1 <= guards.length, walls.length <= 5 * 104\n2 <= guards.length + walls.length <= m * n\nguards[i].length == walls[j].length == 2\n0 <= rowi, rowj < m\n0 <= coli, colj < n\nAll the positions in guards and walls are unique.\n\n", "hints": ["Create a 2D array to represent the grid. Can you mark the tiles that can be seen by a guard?", "Iterate over the guards, and for each of the 4 directions, advance the current tile and mark the tile. When should you stop advancing?"], "exampleTestcases": "4\n6\n[[0,0],[1,1],[2,3]]\n[[0,1],[2,2],[1,4]]\n3\n3\n[[1,1]]\n[[0,1],[1,0],[2,1],[1,2]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def countUnguarded(self, m, n, guards, walls):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type guards: List[List[int]]\n        :type walls: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n        "}, "C": {"langSlug": "c", "code": "int countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int CountUnguarded(int m, int n, int[][] guards, int[][] walls) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} guards\n * @param {number[][]} walls\n * @return {number}\n */\nvar countUnguarded = function(m, n, guards, walls) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function countUnguarded(m: number, n: number, guards: number[][], walls: number[][]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer[][] $guards\n     * @param Integer[][] $walls\n     * @return Integer\n     */\n    function countUnguarded($m, $n, $guards, $walls) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func countUnguarded(_ m: Int, _ n: Int, _ guards: [[Int]], _ walls: [[Int]]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun countUnguarded(m: Int, n: Int, guards: Array<IntArray>, walls: Array<IntArray>): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int countUnguarded(int m, int n, List<List<int>> guards, List<List<int>> walls) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} m\n# @param {Integer} n\n# @param {Integer[][]} guards\n# @param {Integer[][]} walls\n# @return {Integer}\ndef count_unguarded(m, n, guards, walls)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def countUnguarded(m: Int, n: Int, guards: Array[Array[Int]], walls: Array[Array[Int]]): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (count-unguarded m n guards walls)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec count_unguarded(M :: integer(), N :: integer(), Guards :: [[integer()]], Walls :: [[integer()]]) -> integer().\ncount_unguarded(M, N, Guards, Walls) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec count_unguarded(m :: integer, n :: integer, guards :: [[integer]], walls :: [[integer]]) :: integer\n  def count_unguarded(m, n, guards, walls) do\n    \n  end\nend"}}}