{"question_id": "1312", "problem_slug": "count-artifacts-that-can-be-extracted", "problem_title": "Count Artifacts That Can Be Extracted", "content": "There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where:\n\n(r1i, c1i) is the coordinate of the top-left cell of the ith artifact and\n(r2i, c2i) is the coordinate of the bottom-right cell of the ith artifact.\n\nYou will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.\nGiven a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract.\nThe test cases are generated such that:\n\nNo two artifacts overlap.\nEach artifact only covers at most 4 cells.\nThe entries of dig are unique.\n\n \nExample 1:\n\n\nInput: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\nOutput: 1\nExplanation: \nThe different colors represent different artifacts. Excavated cells are labeled with a 'D' in the grid.\nThere is 1 artifact that can be extracted, namely the red artifact.\nThe blue artifact has one part in cell (1,1) which remains uncovered, so we cannot extract it.\nThus, we return 1.\n\nExample 2:\n\n\nInput: n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\nOutput: 2\nExplanation: Both the red and blue artifacts have all parts uncovered (labeled with a 'D') and can be extracted, so we return 2. \n\n \nConstraints:\n\n1 <= n <= 1000\n1 <= artifacts.length, dig.length <= min(n2, 105)\nartifacts[i].length == 4\ndig[i].length == 2\n0 <= r1i, c1i, r2i, c2i, ri, ci <= n - 1\nr1i <= r2i\nc1i <= c2i\nNo two artifacts will overlap.\nThe number of cells covered by an artifact is at most 4.\nThe entries of dig are unique.\n\n", "hints": ["Check if each coordinate of each artifact has been excavated. How can we do this quickly without iterating over the dig array every time?", "Consider marking all excavated cells in a 2D boolean array."], "exampleTestcases": "2\n[[0,0,0,0],[0,1,1,1]]\n[[0,0],[0,1]]\n2\n[[0,0,0,0],[0,1,1,1]]\n[[0,0],[0,1],[1,1]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int digArtifacts(int n, vector<vector<int>>& artifacts, vector<vector<int>>& dig) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def digArtifacts(self, n, artifacts, dig):\n        \"\"\"\n        :type n: int\n        :type artifacts: List[List[int]]\n        :type dig: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:\n        "}, "C": {"langSlug": "c", "code": "int digArtifacts(int n, int** artifacts, int artifactsSize, int* artifactsColSize, int** dig, int digSize, int* digColSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int DigArtifacts(int n, int[][] artifacts, int[][] dig) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number[][]} artifacts\n * @param {number[][]} dig\n * @return {number}\n */\nvar digArtifacts = function(n, artifacts, dig) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function digArtifacts(n: number, artifacts: number[][], dig: number[][]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $artifacts\n     * @param Integer[][] $dig\n     * @return Integer\n     */\n    function digArtifacts($n, $artifacts, $dig) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func digArtifacts(_ n: Int, _ artifacts: [[Int]], _ dig: [[Int]]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun digArtifacts(n: Int, artifacts: Array<IntArray>, dig: Array<IntArray>): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int digArtifacts(int n, List<List<int>> artifacts, List<List<int>> dig) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func digArtifacts(n int, artifacts [][]int, dig [][]int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} n\n# @param {Integer[][]} artifacts\n# @param {Integer[][]} dig\n# @return {Integer}\ndef dig_artifacts(n, artifacts, dig)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def digArtifacts(n: Int, artifacts: Array[Array[Int]], dig: Array[Array[Int]]): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn dig_artifacts(n: i32, artifacts: Vec<Vec<i32>>, dig: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (dig-artifacts n artifacts dig)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec dig_artifacts(N :: integer(), Artifacts :: [[integer()]], Dig :: [[integer()]]) -> integer().\ndig_artifacts(N, Artifacts, Dig) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec dig_artifacts(n :: integer, artifacts :: [[integer]], dig :: [[integer]]) :: integer\n  def dig_artifacts(n, artifacts, dig) do\n    \n  end\nend"}}}