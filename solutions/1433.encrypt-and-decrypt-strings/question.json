{"question_id": "1433", "problem_slug": "encrypt-and-decrypt-strings", "problem_title": "Encrypt and Decrypt Strings", "content": "You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.\nA string is encrypted with the following process:\n\nFor each character c in the string, we find the index i satisfying keys[i] == c in keys.\nReplace c with values[i] in the string.\n\nNote that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string \"\" is returned.\nA string is decrypted with the following process:\n\nFor each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.\nReplace s with keys[i] in the string.\n\nImplement the Encrypter class:\n\nEncrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.\nString encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.\nint decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\n\n \nExample 1:\n\nInput\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\nOutput\n[null, \"eizfeiam\", 2]\n\nExplanation\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // return \"eizfeiam\". \n                           // 'a' maps to \"ei\", 'b' maps to \"zf\", 'c' maps to \"ei\", and 'd' maps to \"am\".\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" can map to 'a' or 'c', \"zf\" maps to 'b', and \"am\" maps to 'd'. \n                              // Thus, the possible strings after decryption are \"abad\", \"cbad\", \"abcd\", and \"cbcd\". \n                              // 2 of those strings, \"abad\" and \"abcd\", appear in dictionary, so the answer is 2.\n\n \nConstraints:\n\n1 <= keys.length == values.length <= 26\nvalues[i].length == 2\n1 <= dictionary.length <= 100\n1 <= dictionary[i].length <= 100\nAll keys[i] and dictionary[i] are unique.\n1 <= word1.length <= 2000\n1 <= word2.length <= 200\nAll word1[i] appear in keys.\nword2.length is even.\nkeys, values[i], dictionary[i], word1, and word2 only contain lowercase English letters.\nAt most 200 calls will be made to encrypt and decrypt in total.\n\n", "hints": ["For encryption, use hashmap to map each char of word1 to its value.", "For decryption, use trie to prune when necessary."], "exampleTestcases": "[\"Encrypter\",\"encrypt\",\"decrypt\"]\n[[[\"a\",\"b\",\"c\",\"d\"],[\"ei\",\"zf\",\"ei\",\"am\"],[\"abcd\",\"acbd\",\"adbc\",\"badc\",\"dacb\",\"cadb\",\"cbda\",\"abad\"]],[\"abcd\"],[\"eizfeiam\"]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Encrypter {\npublic:\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\n        \n    }\n    \n    string encrypt(string word1) {\n        \n    }\n    \n    int decrypt(string word2) {\n        \n    }\n};\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\n * string param_1 = obj->encrypt(word1);\n * int param_2 = obj->decrypt(word2);\n */"}, "Java": {"langSlug": "java", "code": "class Encrypter {\n\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\n        \n    }\n    \n    public String encrypt(String word1) {\n        \n    }\n    \n    public int decrypt(String word2) {\n        \n    }\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * Encrypter obj = new Encrypter(keys, values, dictionary);\n * String param_1 = obj.encrypt(word1);\n * int param_2 = obj.decrypt(word2);\n */"}, "Python": {"langSlug": "python", "code": "class Encrypter(object):\n\n    def __init__(self, keys, values, dictionary):\n        \"\"\"\n        :type keys: List[str]\n        :type values: List[str]\n        :type dictionary: List[str]\n        \"\"\"\n        \n\n    def encrypt(self, word1):\n        \"\"\"\n        :type word1: str\n        :rtype: str\n        \"\"\"\n        \n\n    def decrypt(self, word2):\n        \"\"\"\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your Encrypter object will be instantiated and called as such:\n# obj = Encrypter(keys, values, dictionary)\n# param_1 = obj.encrypt(word1)\n# param_2 = obj.decrypt(word2)"}, "Python3": {"langSlug": "python3", "code": "class Encrypter:\n\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\n        \n\n    def encrypt(self, word1: str) -> str:\n        \n\n    def decrypt(self, word2: str) -> int:\n        \n\n\n# Your Encrypter object will be instantiated and called as such:\n# obj = Encrypter(keys, values, dictionary)\n# param_1 = obj.encrypt(word1)\n# param_2 = obj.decrypt(word2)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} Encrypter;\n\n\nEncrypter* encrypterCreate(char* keys, int keysSize, char** values, int valuesSize, char** dictionary, int dictionarySize) {\n    \n}\n\nchar* encrypterEncrypt(Encrypter* obj, char* word1) {\n    \n}\n\nint encrypterDecrypt(Encrypter* obj, char* word2) {\n    \n}\n\nvoid encrypterFree(Encrypter* obj) {\n    \n}\n\n/**\n * Your Encrypter struct will be instantiated and called as such:\n * Encrypter* obj = encrypterCreate(keys, keysSize, values, valuesSize, dictionary, dictionarySize);\n * char* param_1 = encrypterEncrypt(obj, word1);\n \n * int param_2 = encrypterDecrypt(obj, word2);\n \n * encrypterFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class Encrypter {\n\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\n        \n    }\n    \n    public string Encrypt(string word1) {\n        \n    }\n    \n    public int Decrypt(string word2) {\n        \n    }\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * Encrypter obj = new Encrypter(keys, values, dictionary);\n * string param_1 = obj.Encrypt(word1);\n * int param_2 = obj.Decrypt(word2);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {character[]} keys\n * @param {string[]} values\n * @param {string[]} dictionary\n */\nvar Encrypter = function(keys, values, dictionary) {\n    \n};\n\n/** \n * @param {string} word1\n * @return {string}\n */\nEncrypter.prototype.encrypt = function(word1) {\n    \n};\n\n/** \n * @param {string} word2\n * @return {number}\n */\nEncrypter.prototype.decrypt = function(word2) {\n    \n};\n\n/** \n * Your Encrypter object will be instantiated and called as such:\n * var obj = new Encrypter(keys, values, dictionary)\n * var param_1 = obj.encrypt(word1)\n * var param_2 = obj.decrypt(word2)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class Encrypter {\n    constructor(keys: string[], values: string[], dictionary: string[]) {\n        \n    }\n\n    encrypt(word1: string): string {\n        \n    }\n\n    decrypt(word2: string): number {\n        \n    }\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * var obj = new Encrypter(keys, values, dictionary)\n * var param_1 = obj.encrypt(word1)\n * var param_2 = obj.decrypt(word2)\n */"}, "PHP": {"langSlug": "php", "code": "class Encrypter {\n    /**\n     * @param String[] $keys\n     * @param String[] $values\n     * @param String[] $dictionary\n     */\n    function __construct($keys, $values, $dictionary) {\n        \n    }\n  \n    /**\n     * @param String $word1\n     * @return String\n     */\n    function encrypt($word1) {\n        \n    }\n  \n    /**\n     * @param String $word2\n     * @return Integer\n     */\n    function decrypt($word2) {\n        \n    }\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * $obj = Encrypter($keys, $values, $dictionary);\n * $ret_1 = $obj->encrypt($word1);\n * $ret_2 = $obj->decrypt($word2);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass Encrypter {\n\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\n        \n    }\n    \n    func encrypt(_ word1: String) -> String {\n        \n    }\n    \n    func decrypt(_ word2: String) -> Int {\n        \n    }\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * let obj = Encrypter(keys, values, dictionary)\n * let ret_1: String = obj.encrypt(word1)\n * let ret_2: Int = obj.decrypt(word2)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\n\n    fun encrypt(word1: String): String {\n        \n    }\n\n    fun decrypt(word2: String): Int {\n        \n    }\n\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * var obj = Encrypter(keys, values, dictionary)\n * var param_1 = obj.encrypt(word1)\n * var param_2 = obj.decrypt(word2)\n */"}, "Dart": {"langSlug": "dart", "code": "class Encrypter {\n\n  Encrypter(List<String> keys, List<String> values, List<String> dictionary) {\n    \n  }\n  \n  String encrypt(String word1) {\n    \n  }\n  \n  int decrypt(String word2) {\n    \n  }\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * Encrypter obj = Encrypter(keys, values, dictionary);\n * String param1 = obj.encrypt(word1);\n * int param2 = obj.decrypt(word2);\n */"}, "Go": {"langSlug": "golang", "code": "type Encrypter struct {\n    \n}\n\n\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\n    \n}\n\n\nfunc (this *Encrypter) Encrypt(word1 string) string {\n    \n}\n\n\nfunc (this *Encrypter) Decrypt(word2 string) int {\n    \n}\n\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * obj := Constructor(keys, values, dictionary);\n * param_1 := obj.Encrypt(word1);\n * param_2 := obj.Decrypt(word2);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class Encrypter\n\n=begin\n    :type keys: Character[]\n    :type values: String[]\n    :type dictionary: String[]\n=end\n    def initialize(keys, values, dictionary)\n        \n    end\n\n\n=begin\n    :type word1: String\n    :rtype: String\n=end\n    def encrypt(word1)\n        \n    end\n\n\n=begin\n    :type word2: String\n    :rtype: Integer\n=end\n    def decrypt(word2)\n        \n    end\n\n\nend\n\n# Your Encrypter object will be instantiated and called as such:\n# obj = Encrypter.new(keys, values, dictionary)\n# param_1 = obj.encrypt(word1)\n# param_2 = obj.decrypt(word2)"}, "Scala": {"langSlug": "scala", "code": "class Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\n\n    def encrypt(word1: String): String = {\n        \n    }\n\n    def decrypt(word2: String): Int = {\n        \n    }\n\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * val obj = new Encrypter(keys, values, dictionary)\n * val param_1 = obj.encrypt(word1)\n * val param_2 = obj.decrypt(word2)\n */"}, "Rust": {"langSlug": "rust", "code": "struct Encrypter {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Encrypter {\n\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\n        \n    }\n    \n    fn encrypt(&self, word1: String) -> String {\n        \n    }\n    \n    fn decrypt(&self, word2: String) -> i32 {\n        \n    }\n}\n\n/**\n * Your Encrypter object will be instantiated and called as such:\n * let obj = Encrypter::new(keys, values, dictionary);\n * let ret_1: String = obj.encrypt(word1);\n * let ret_2: i32 = obj.decrypt(word2);\n */"}, "Racket": {"langSlug": "racket", "code": "(define encrypter%\n  (class object%\n    (super-new)\n    \n    ; keys : (listof char?)\n    ; values : (listof string?)\n    ; dictionary : (listof string?)\n    (init-field\n      keys\n      values\n      dictionary)\n    \n    ; encrypt : string? -> string?\n    (define/public (encrypt word1)\n      )\n    ; decrypt : string? -> exact-integer?\n    (define/public (decrypt word2)\n      )))\n\n;; Your encrypter% object will be instantiated and called as such:\n;; (define obj (new encrypter% [keys keys] [values values] [dictionary dictionary]))\n;; (define param_1 (send obj encrypt word1))\n;; (define param_2 (send obj decrypt word2))"}, "Erlang": {"langSlug": "erlang", "code": "-spec encrypter_init_(Keys :: [char()], Values :: [unicode:unicode_binary()], Dictionary :: [unicode:unicode_binary()]) -> any().\nencrypter_init_(Keys, Values, Dictionary) ->\n  .\n\n-spec encrypter_encrypt(Word1 :: unicode:unicode_binary()) -> unicode:unicode_binary().\nencrypter_encrypt(Word1) ->\n  .\n\n-spec encrypter_decrypt(Word2 :: unicode:unicode_binary()) -> integer().\nencrypter_decrypt(Word2) ->\n  .\n\n\n%% Your functions will be called as such:\n%% encrypter_init_(Keys, Values, Dictionary),\n%% Param_1 = encrypter_encrypt(Word1),\n%% Param_2 = encrypter_decrypt(Word2),\n\n%% encrypter_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Encrypter do\n  @spec init_(keys :: [char], values :: [String.t], dictionary :: [String.t]) :: any\n  def init_(keys, values, dictionary) do\n    \n  end\n\n  @spec encrypt(word1 :: String.t) :: String.t\n  def encrypt(word1) do\n    \n  end\n\n  @spec decrypt(word2 :: String.t) :: integer\n  def decrypt(word2) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Encrypter.init_(keys, values, dictionary)\n# param_1 = Encrypter.encrypt(word1)\n# param_2 = Encrypter.decrypt(word2)\n\n# Encrypter.init_ will be called before every test case, in which you can do some necessary initializations."}}}