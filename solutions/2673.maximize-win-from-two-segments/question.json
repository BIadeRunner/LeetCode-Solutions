{"question_id": "2673", "problem_slug": "maximize-win-from-two-segments", "problem_title": "Maximize Win From Two Segments", "content": "There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k.\nYou are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\nFor example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.\n\nReturn the maximum number of prizes you can win if you choose the two segments optimally.\n \nExample 1:\n\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\nExplanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].\n\nExample 2:\n\nInput: prizePositions = [1,2,3,4], k = 0\nOutput: 2\nExplanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. \n\n \nConstraints:\n\n1 <= prizePositions.length <= 105\n1 <= prizePositions[i] <= 109\n0 <= k <= 109 \nprizePositions is sorted in non-decreasing order.\n\n \n\n", "hints": ["Try solving the problem for one interval.", "Using the solution with one interval, how can you combine that with a second interval?"], "exampleTestcases": "[1,1,2,2,3,3,5]\n2\n[1,2,3,4]\n0", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int maximizeWin(vector<int>& prizePositions, int k) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int maximizeWin(int[] prizePositions, int k) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def maximizeWin(self, prizePositions, k):\n        \"\"\"\n        :type prizePositions: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def maximizeWin(self, prizePositions: List[int], k: int) -> int:\n        "}, "C": {"langSlug": "c", "code": "int maximizeWin(int* prizePositions, int prizePositionsSize, int k) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int MaximizeWin(int[] prizePositions, int k) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} prizePositions\n * @param {number} k\n * @return {number}\n */\nvar maximizeWin = function(prizePositions, k) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function maximizeWin(prizePositions: number[], k: number): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $prizePositions\n     * @param Integer $k\n     * @return Integer\n     */\n    function maximizeWin($prizePositions, $k) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func maximizeWin(_ prizePositions: [Int], _ k: Int) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun maximizeWin(prizePositions: IntArray, k: Int): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int maximizeWin(List<int> prizePositions, int k) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func maximizeWin(prizePositions []int, k int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} prize_positions\n# @param {Integer} k\n# @return {Integer}\ndef maximize_win(prize_positions, k)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def maximizeWin(prizePositions: Array[Int], k: Int): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn maximize_win(prize_positions: Vec<i32>, k: i32) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (maximize-win prizePositions k)\n  (-> (listof exact-integer?) exact-integer? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec maximize_win(PrizePositions :: [integer()], K :: integer()) -> integer().\nmaximize_win(PrizePositions, K) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec maximize_win(prize_positions :: [integer], k :: integer) :: integer\n  def maximize_win(prize_positions, k) do\n    \n  end\nend"}}}