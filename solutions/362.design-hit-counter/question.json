{"questionId": "362", "acRate": 68.86919043095074, "difficulty": "Medium", "freqBar": 80.52464427523482, "frontendQuestionId": "362", "paidOnly": true, "status": "ac", "title": "Design Hit Counter", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Binary Search", "id": "VG9waWNUYWdOb2RlOjEx", "slug": "binary-search"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}, {"name": "Queue", "id": "VG9waWNUYWdOb2RlOjM0", "slug": "queue"}, {"name": "Data Stream", "id": "VG9waWNUYWdOb2RlOjYxMDYz", "slug": "data-stream"}], "titleSlug": "design-hit-counter", "content": "<p>Design a hit counter which counts the number of hits received in the past <code>5</code> minutes (i.e., the past <code>300</code> seconds).</p>\n\n<p>Your system should accept a <code>timestamp</code> parameter (<strong>in seconds</strong> granularity), and you may assume that calls are being made to the system in chronological order (i.e., <code>timestamp</code> is monotonically increasing). Several hits may arrive roughly at the same time.</p>\n\n<p>Implement the <code>HitCounter</code> class:</p>\n\n<ul>\n\t<li><code>HitCounter()</code> Initializes the object of the hit counter system.</li>\n\t<li><code>void hit(int timestamp)</code> Records a hit that happened at <code>timestamp</code> (<strong>in seconds</strong>). Several hits may happen at the same <code>timestamp</code>.</li>\n\t<li><code>int getHits(int timestamp)</code> Returns the number of hits in the past 5 minutes from <code>timestamp</code> (i.e., the past <code>300</code> seconds).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;HitCounter&quot;, &quot;hit&quot;, &quot;hit&quot;, &quot;hit&quot;, &quot;getHits&quot;, &quot;hit&quot;, &quot;getHits&quot;, &quot;getHits&quot;]\n[[], [1], [2], [3], [4], [300], [300], [301]]\n<strong>Output</strong>\n[null, null, null, null, 3, null, 4, 3]\n\n<strong>Explanation</strong>\nHitCounter hitCounter = new HitCounter();\nhitCounter.hit(1);       // hit at timestamp 1.\nhitCounter.hit(2);       // hit at timestamp 2.\nhitCounter.hit(3);       // hit at timestamp 3.\nhitCounter.getHits(4);   // get hits at timestamp 4, return 3.\nhitCounter.hit(300);     // hit at timestamp 300.\nhitCounter.getHits(300); // get hits at timestamp 300, return 4.\nhitCounter.getHits(301); // get hits at timestamp 301, return 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timestamp &lt;= 2 * 10<sup>9</sup></code></li>\n\t<li>All the calls are being made to the system in chronological order (i.e., <code>timestamp</code> is monotonically increasing).</li>\n\t<li>At most <code>300</code> calls will be made to <code>hit</code> and <code>getHits</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the number of hits per second could be huge? Does your design scale?</p>\n", "hints": [], "exampleTestcases": "[\"HitCounter\",\"hit\",\"hit\",\"hit\",\"getHits\",\"hit\",\"getHits\",\"getHits\"]\n[[],[1],[2],[3],[4],[300],[300],[301]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class HitCounter {\npublic:\n    HitCounter() {\n        \n    }\n    \n    void hit(int timestamp) {\n        \n    }\n    \n    int getHits(int timestamp) {\n        \n    }\n};\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * HitCounter* obj = new HitCounter();\n * obj->hit(timestamp);\n * int param_2 = obj->getHits(timestamp);\n */"}, {"lang": "Java", "langSlug": "java", "code": "class HitCounter {\n\n    public HitCounter() {\n        \n    }\n    \n    public void hit(int timestamp) {\n        \n    }\n    \n    public int getHits(int timestamp) {\n        \n    }\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * HitCounter obj = new HitCounter();\n * obj.hit(timestamp);\n * int param_2 = obj.getHits(timestamp);\n */"}, {"lang": "Python", "langSlug": "python", "code": "class HitCounter(object):\n\n    def __init__(self):\n        \n\n    def hit(self, timestamp):\n        \"\"\"\n        :type timestamp: int\n        :rtype: None\n        \"\"\"\n        \n\n    def getHits(self, timestamp):\n        \"\"\"\n        :type timestamp: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your HitCounter object will be instantiated and called as such:\n# obj = HitCounter()\n# obj.hit(timestamp)\n# param_2 = obj.getHits(timestamp)"}, {"lang": "Python3", "langSlug": "python3", "code": "class HitCounter:\n\n    def __init__(self):\n        \n\n    def hit(self, timestamp: int) -> None:\n        \n\n    def getHits(self, timestamp: int) -> int:\n        \n\n\n# Your HitCounter object will be instantiated and called as such:\n# obj = HitCounter()\n# obj.hit(timestamp)\n# param_2 = obj.getHits(timestamp)"}, {"lang": "C", "langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} HitCounter;\n\n\nHitCounter* hitCounterCreate() {\n    \n}\n\nvoid hitCounterHit(HitCounter* obj, int timestamp) {\n    \n}\n\nint hitCounterGetHits(HitCounter* obj, int timestamp) {\n    \n}\n\nvoid hitCounterFree(HitCounter* obj) {\n    \n}\n\n/**\n * Your HitCounter struct will be instantiated and called as such:\n * HitCounter* obj = hitCounterCreate();\n * hitCounterHit(obj, timestamp);\n \n * int param_2 = hitCounterGetHits(obj, timestamp);\n \n * hitCounterFree(obj);\n*/"}, {"lang": "C#", "langSlug": "csharp", "code": "public class HitCounter {\n\n    public HitCounter() {\n        \n    }\n    \n    public void Hit(int timestamp) {\n        \n    }\n    \n    public int GetHits(int timestamp) {\n        \n    }\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * HitCounter obj = new HitCounter();\n * obj.Hit(timestamp);\n * int param_2 = obj.GetHits(timestamp);\n */"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "\nvar HitCounter = function() {\n    \n};\n\n/** \n * @param {number} timestamp\n * @return {void}\n */\nHitCounter.prototype.hit = function(timestamp) {\n    \n};\n\n/** \n * @param {number} timestamp\n * @return {number}\n */\nHitCounter.prototype.getHits = function(timestamp) {\n    \n};\n\n/** \n * Your HitCounter object will be instantiated and called as such:\n * var obj = new HitCounter()\n * obj.hit(timestamp)\n * var param_2 = obj.getHits(timestamp)\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "class HitCounter {\n    constructor() {\n        \n    }\n\n    hit(timestamp: number): void {\n        \n    }\n\n    getHits(timestamp: number): number {\n        \n    }\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * var obj = new HitCounter()\n * obj.hit(timestamp)\n * var param_2 = obj.getHits(timestamp)\n */"}, {"lang": "PHP", "langSlug": "php", "code": "class HitCounter {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $timestamp\n     * @return NULL\n     */\n    function hit($timestamp) {\n        \n    }\n  \n    /**\n     * @param Integer $timestamp\n     * @return Integer\n     */\n    function getHits($timestamp) {\n        \n    }\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * $obj = HitCounter();\n * $obj->hit($timestamp);\n * $ret_2 = $obj->getHits($timestamp);\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "\nclass HitCounter {\n\n    init() {\n        \n    }\n    \n    func hit(_ timestamp: Int) {\n        \n    }\n    \n    func getHits(_ timestamp: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * let obj = HitCounter()\n * obj.hit(timestamp)\n * let ret_2: Int = obj.getHits(timestamp)\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class HitCounter() {\n\n    fun hit(timestamp: Int) {\n        \n    }\n\n    fun getHits(timestamp: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * var obj = HitCounter()\n * obj.hit(timestamp)\n * var param_2 = obj.getHits(timestamp)\n */"}, {"lang": "Dart", "langSlug": "dart", "code": "class HitCounter {\n\n  HitCounter() {\n    \n  }\n  \n  void hit(int timestamp) {\n    \n  }\n  \n  int getHits(int timestamp) {\n    \n  }\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * HitCounter obj = HitCounter();\n * obj.hit(timestamp);\n * int param2 = obj.getHits(timestamp);\n */"}, {"lang": "Go", "langSlug": "golang", "code": "type HitCounter struct {\n    \n}\n\n\nfunc Constructor() HitCounter {\n    \n}\n\n\nfunc (this *HitCounter) Hit(timestamp int)  {\n    \n}\n\n\nfunc (this *HitCounter) GetHits(timestamp int) int {\n    \n}\n\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Hit(timestamp);\n * param_2 := obj.GetHits(timestamp);\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "class HitCounter\n    def initialize()\n        \n    end\n\n\n=begin\n    :type timestamp: Integer\n    :rtype: Void\n=end\n    def hit(timestamp)\n        \n    end\n\n\n=begin\n    :type timestamp: Integer\n    :rtype: Integer\n=end\n    def get_hits(timestamp)\n        \n    end\n\n\nend\n\n# Your HitCounter object will be instantiated and called as such:\n# obj = HitCounter.new()\n# obj.hit(timestamp)\n# param_2 = obj.get_hits(timestamp)"}, {"lang": "Scala", "langSlug": "scala", "code": "class HitCounter() {\n\n    def hit(timestamp: Int): Unit = {\n        \n    }\n\n    def getHits(timestamp: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * val obj = new HitCounter()\n * obj.hit(timestamp)\n * val param_2 = obj.getHits(timestamp)\n */"}, {"lang": "Rust", "langSlug": "rust", "code": "struct HitCounter {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl HitCounter {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn hit(&self, timestamp: i32) {\n        \n    }\n    \n    fn get_hits(&self, timestamp: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your HitCounter object will be instantiated and called as such:\n * let obj = HitCounter::new();\n * obj.hit(timestamp);\n * let ret_2: i32 = obj.get_hits(timestamp);\n */"}, {"lang": "Racket", "langSlug": "racket", "code": "(define hit-counter%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; hit : exact-integer? -> void?\n    (define/public (hit timestamp)\n      )\n    ; get-hits : exact-integer? -> exact-integer?\n    (define/public (get-hits timestamp)\n      )))\n\n;; Your hit-counter% object will be instantiated and called as such:\n;; (define obj (new hit-counter%))\n;; (send obj hit timestamp)\n;; (define param_2 (send obj get-hits timestamp))"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec hit_counter_init_() -> any().\nhit_counter_init_() ->\n  .\n\n-spec hit_counter_hit(Timestamp :: integer()) -> any().\nhit_counter_hit(Timestamp) ->\n  .\n\n-spec hit_counter_get_hits(Timestamp :: integer()) -> integer().\nhit_counter_get_hits(Timestamp) ->\n  .\n\n\n%% Your functions will be called as such:\n%% hit_counter_init_(),\n%% hit_counter_hit(Timestamp),\n%% Param_2 = hit_counter_get_hits(Timestamp),\n\n%% hit_counter_init_ will be called before every test case, in which you can do some necessary initializations."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule HitCounter do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec hit(timestamp :: integer) :: any\n  def hit(timestamp) do\n    \n  end\n\n  @spec get_hits(timestamp :: integer) :: integer\n  def get_hits(timestamp) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# HitCounter.init_()\n# HitCounter.hit(timestamp)\n# param_2 = HitCounter.get_hits(timestamp)\n\n# HitCounter.init_ will be called before every test case, in which you can do some necessary initializations."}], "similarQuestionList": [{"difficulty": "Easy", "titleSlug": "logger-rate-limiter", "title": "Logger Rate Limiter", "isPaidOnly": true}]}