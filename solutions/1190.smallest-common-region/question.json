{"question_id": "1190", "problem_slug": "smallest-common-region", "problem_title": "Smallest Common Region", "content": "You are given some lists of regions where the first region of each list includes all other regions in that list.\nNaturally, if a region x contains another region y then x is bigger than y. Also, by definition, a region x contains itself.\nGiven two regions: region1 and region2, return the smallest region that contains both of them.\nIf you are given regions r1, r2, and r3 such that r1 includes r3, it is guaranteed there is no r2 such that r2 includes r3.\nIt is guaranteed the smallest region exists.\n \nExample 1:\n\nInput:\nregions = [[\"Earth\",\"North America\",\"South America\"],\n[\"North America\",\"United States\",\"Canada\"],\n[\"United States\",\"New York\",\"Boston\"],\n[\"Canada\",\"Ontario\",\"Quebec\"],\n[\"South America\",\"Brazil\"]],\nregion1 = \"Quebec\",\nregion2 = \"New York\"\nOutput: \"North America\"\n\nExample 2:\n\nInput: regions = [[\"Earth\", \"North America\", \"South America\"],[\"North America\", \"United States\", \"Canada\"],[\"United States\", \"New York\", \"Boston\"],[\"Canada\", \"Ontario\", \"Quebec\"],[\"South America\", \"Brazil\"]], region1 = \"Canada\", region2 = \"South America\"\nOutput: \"Earth\"\n\n \nConstraints:\n\n2 <= regions.length <= 104\n2 <= regions[i].length <= 20\n1 <= regions[i][j].length, region1.length, region2.length <= 20\nregion1 != region2\nregions[i][j], region1, and region2 consist of English letters.\n\n", "hints": ["Try to model the problem as a graph problem.", "The given graph is a tree.", "The problem is reduced to finding the lowest common ancestor of two nodes in a tree."], "exampleTestcases": "[[\"Earth\",\"North America\",\"South America\"],[\"North America\",\"United States\",\"Canada\"],[\"United States\",\"New York\",\"Boston\"],[\"Canada\",\"Ontario\",\"Quebec\"],[\"South America\",\"Brazil\"]]\n\"Quebec\"\n\"New York\"\n[[\"Earth\", \"North America\", \"South America\"],[\"North America\", \"United States\", \"Canada\"],[\"United States\", \"New York\", \"Boston\"],[\"Canada\", \"Ontario\", \"Quebec\"],[\"South America\", \"Brazil\"]]\n\"Canada\"\n\"South America\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    string findSmallestRegion(vector<vector<string>>& regions, string region1, string region2) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public String findSmallestRegion(List<List<String>> regions, String region1, String region2) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def findSmallestRegion(self, regions, region1, region2):\n        \"\"\"\n        :type regions: List[List[str]]\n        :type region1: str\n        :type region2: str\n        :rtype: str\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def findSmallestRegion(self, regions: List[List[str]], region1: str, region2: str) -> str:\n        "}, "C": {"langSlug": "c", "code": "char* findSmallestRegion(char*** regions, int regionsSize, int* regionsColSize, char* region1, char* region2) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public string FindSmallestRegion(IList<IList<string>> regions, string region1, string region2) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string[][]} regions\n * @param {string} region1\n * @param {string} region2\n * @return {string}\n */\nvar findSmallestRegion = function(regions, region1, region2) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function findSmallestRegion(regions: string[][], region1: string, region2: string): string {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String[][] $regions\n     * @param String $region1\n     * @param String $region2\n     * @return String\n     */\n    function findSmallestRegion($regions, $region1, $region2) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func findSmallestRegion(_ regions: [[String]], _ region1: String, _ region2: String) -> String {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun findSmallestRegion(regions: List<List<String>>, region1: String, region2: String): String {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  String findSmallestRegion(List<List<String>> regions, String region1, String region2) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func findSmallestRegion(regions [][]string, region1 string, region2 string) string {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String[][]} regions\n# @param {String} region1\n# @param {String} region2\n# @return {String}\ndef find_smallest_region(regions, region1, region2)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def findSmallestRegion(regions: List[List[String]], region1: String, region2: String): String = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn find_smallest_region(regions: Vec<Vec<String>>, region1: String, region2: String) -> String {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (find-smallest-region regions region1 region2)\n  (-> (listof (listof string?)) string? string? string?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec find_smallest_region(Regions :: [[unicode:unicode_binary()]], Region1 :: unicode:unicode_binary(), Region2 :: unicode:unicode_binary()) -> unicode:unicode_binary().\nfind_smallest_region(Regions, Region1, Region2) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec find_smallest_region(regions :: [[String.t]], region1 :: String.t, region2 :: String.t) :: String.t\n  def find_smallest_region(regions, region1, region2) do\n    \n  end\nend"}}}