{"question_id": "251", "problem_slug": "flatten-2d-vector", "problem_title": "Flatten 2D Vector", "content": "Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.\nImplement the Vector2D class:\n\nVector2D(int[][] vec) initializes the object with the 2D vector vec.\nnext() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.\nhasNext() returns true if there are still some elements in the vector, and false otherwise.\n\n \nExample 1:\n\nInput\n[\"Vector2D\", \"next\", \"next\", \"next\", \"hasNext\", \"hasNext\", \"next\", \"hasNext\"]\n[[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]\nOutput\n[null, 1, 2, 3, true, true, 4, false]\n\nExplanation\nVector2D vector2D = new Vector2D([[1, 2], [3], [4]]);\nvector2D.next();    // return 1\nvector2D.next();    // return 2\nvector2D.next();    // return 3\nvector2D.hasNext(); // return True\nvector2D.hasNext(); // return True\nvector2D.next();    // return 4\nvector2D.hasNext(); // return False\n\n \nConstraints:\n\n0 <= vec.length <= 200\n0 <= vec[i].length <= 500\n-500 <= vec[i][j] <= 500\nAt most 105 calls will be made to next and hasNext.\n\n \nFollow up: As an added challenge, try to code it using only iterators in C++ or iterators in Java.\n", "hints": ["How many variables do you need to keep track?", "Two variables is all you need. Try with <code>x</code> and <code>y</code>.", "Beware of empty rows. It could be the first few rows.", "To write correct code, think about the <a href=\"https://en.wikipedia.org/wiki/Invariant_(computer_science)\" target=\"_blank\">invariant</a> to maintain. What is it?", "The invariant is <code>x</code> and <code>y</code> must always point to a valid point in the 2d vector. Should you maintain your invariant <i>ahead of time</i> or <i>right when you need it</i>?", "Not sure? Think about how you would implement <code>hasNext()</code>. Which is more complex?", "Common logic in two different places should be refactored into a common method."], "exampleTestcases": "[\"Vector2D\",\"next\",\"next\",\"next\",\"hasNext\",\"hasNext\",\"next\",\"hasNext\"]\n[[[[1,2],[3],[4]]],[],[],[],[],[],[],[]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Vector2D {\npublic:\n    Vector2D(vector<vector<int>>& vec) {\n        \n    }\n    \n    int next() {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D* obj = new Vector2D(vec);\n * int param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */"}, "Java": {"langSlug": "java", "code": "class Vector2D {\n\n    public Vector2D(int[][] vec) {\n        \n    }\n    \n    public int next() {\n        \n    }\n    \n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = new Vector2D(vec);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"}, "Python": {"langSlug": "python", "code": "class Vector2D(object):\n\n    def __init__(self, vec):\n        \"\"\"\n        :type vec: List[List[int]]\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D(vec)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"}, "Python3": {"langSlug": "python3", "code": "class Vector2D:\n\n    def __init__(self, vec: List[List[int]]):\n        \n\n    def next(self) -> int:\n        \n\n    def hasNext(self) -> bool:\n        \n\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D(vec)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} Vector2D;\n\n\nVector2D* vector2DCreate(int** vec, int vecSize, int* vecColSize) {\n    \n}\n\nint vector2DNext(Vector2D* obj) {\n    \n}\n\nbool vector2DHasNext(Vector2D* obj) {\n    \n}\n\nvoid vector2DFree(Vector2D* obj) {\n    \n}\n\n/**\n * Your Vector2D struct will be instantiated and called as such:\n * Vector2D* obj = vector2DCreate(vec, vecSize, vecColSize);\n * int param_1 = vector2DNext(obj);\n \n * bool param_2 = vector2DHasNext(obj);\n \n * vector2DFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class Vector2D {\n\n    public Vector2D(int[][] vec) {\n        \n    }\n    \n    public int Next() {\n        \n    }\n    \n    public bool HasNext() {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = new Vector2D(vec);\n * int param_1 = obj.Next();\n * bool param_2 = obj.HasNext();\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} vec\n */\nvar Vector2D = function(vec) {\n    \n};\n\n/**\n * @return {number}\n */\nVector2D.prototype.next = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nVector2D.prototype.hasNext = function() {\n    \n};\n\n/** \n * Your Vector2D object will be instantiated and called as such:\n * var obj = new Vector2D(vec)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class Vector2D {\n    constructor(vec: number[][]) {\n        \n    }\n\n    next(): number {\n        \n    }\n\n    hasNext(): boolean {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * var obj = new Vector2D(vec)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, "PHP": {"langSlug": "php", "code": "class Vector2D {\n    /**\n     * @param Integer[][] $vec\n     */\n    function __construct($vec) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function next() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * $obj = Vector2D($vec);\n * $ret_1 = $obj->next();\n * $ret_2 = $obj->hasNext();\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass Vector2D {\n\n    init(_ vec: [[Int]]) {\n        \n    }\n    \n    func next() -> Int {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * let obj = Vector2D(vec)\n * let ret_1: Int = obj.next()\n * let ret_2: Bool = obj.hasNext()\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class Vector2D(vec: Array<IntArray>) {\n\n    fun next(): Int {\n        \n    }\n\n    fun hasNext(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * var obj = Vector2D(vec)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, "Dart": {"langSlug": "dart", "code": "class Vector2D {\n\n  Vector2D(List<List<int>> vec) {\n    \n  }\n  \n  int next() {\n    \n  }\n  \n  bool hasNext() {\n    \n  }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = Vector2D(vec);\n * int param1 = obj.next();\n * bool param2 = obj.hasNext();\n */"}, "Go": {"langSlug": "golang", "code": "type Vector2D struct {\n    \n}\n\n\nfunc Constructor(vec [][]int) Vector2D {\n    \n}\n\n\nfunc (this *Vector2D) Next() int {\n    \n}\n\n\nfunc (this *Vector2D) HasNext() bool {\n    \n}\n\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * obj := Constructor(vec);\n * param_1 := obj.Next();\n * param_2 := obj.HasNext();\n */"}, "Ruby": {"langSlug": "ruby", "code": "class Vector2D\n\n=begin\n    :type vec: Integer[][]\n=end\n    def initialize(vec)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def next()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_next()\n        \n    end\n\n\nend\n\n# Your Vector2D object will be instantiated and called as such:\n# obj = Vector2D.new(vec)\n# param_1 = obj.next()\n# param_2 = obj.has_next()"}, "Scala": {"langSlug": "scala", "code": "class Vector2D(_vec: Array[Array[Int]]) {\n\n    def next(): Int = {\n        \n    }\n\n    def hasNext(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * val obj = new Vector2D(vec)\n * val param_1 = obj.next()\n * val param_2 = obj.hasNext()\n */"}, "Rust": {"langSlug": "rust", "code": "struct Vector2D {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Vector2D {\n\n    fn new(vec: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn next(&self) -> i32 {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * let obj = Vector2D::new(vec);\n * let ret_1: i32 = obj.next();\n * let ret_2: bool = obj.has_next();\n */"}, "Racket": {"langSlug": "racket", "code": "(define vector2-d%\n  (class object%\n    (super-new)\n    \n    ; vec : (listof (listof exact-integer?))\n    (init-field\n      vec)\n    \n    ; next : -> exact-integer?\n    (define/public (next)\n      )\n    ; has-next : -> boolean?\n    (define/public (has-next)\n      )))\n\n;; Your vector2-d% object will be instantiated and called as such:\n;; (define obj (new vector2-d% [vec vec]))\n;; (define param_1 (send obj next))\n;; (define param_2 (send obj has-next))"}, "Erlang": {"langSlug": "erlang", "code": "-spec vector2_d_init_(Vec :: [[integer()]]) -> any().\nvector2_d_init_(Vec) ->\n  .\n\n-spec vector2_d_next() -> integer().\nvector2_d_next() ->\n  .\n\n-spec vector2_d_has_next() -> boolean().\nvector2_d_has_next() ->\n  .\n\n\n%% Your functions will be called as such:\n%% vector2_d_init_(Vec),\n%% Param_1 = vector2_d_next(),\n%% Param_2 = vector2_d_has_next(),\n\n%% vector2_d_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Vector2D do\n  @spec init_(vec :: [[integer]]) :: any\n  def init_(vec) do\n    \n  end\n\n  @spec next() :: integer\n  def next() do\n    \n  end\n\n  @spec has_next() :: boolean\n  def has_next() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Vector2D.init_(vec)\n# param_1 = Vector2D.next()\n# param_2 = Vector2D.has_next()\n\n# Vector2D.init_ will be called before every test case, in which you can do some necessary initializations."}}}