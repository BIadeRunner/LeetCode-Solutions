{"question_id": "716", "problem_slug": "max-stack", "problem_title": "Max Stack", "content": "Design a max stack data structure that supports the stack operations and supports finding the stack's maximum element.\nImplement the MaxStack class:\n\nMaxStack() Initializes the stack object.\nvoid push(int x) Pushes element x onto the stack.\nint pop() Removes the element on top of the stack and returns it.\nint top() Gets the element on the top of the stack without removing it.\nint peekMax() Retrieves the maximum element in the stack without removing it.\nint popMax() Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the top-most one.\n\nYou must come up with a solution that supports O(1) for each top call and O(logn) for each other call.\n \nExample 1:\n\nInput\n[\"MaxStack\", \"push\", \"push\", \"push\", \"top\", \"popMax\", \"top\", \"peekMax\", \"pop\", \"top\"]\n[[], [5], [1], [5], [], [], [], [], [], []]\nOutput\n[null, null, null, null, 5, 5, 1, 5, 1, 5]\n\nExplanation\nMaxStack stk = new MaxStack();\nstk.push(5);   // [5] the top of the stack and the maximum number is 5.\nstk.push(1);   // [5, 1] the top of the stack is 1, but the maximum is 5.\nstk.push(5);   // [5, 1, 5] the top of the stack is 5, which is also the maximum, because it is the top most one.\nstk.top();     // return 5, [5, 1, 5] the stack did not change.\nstk.popMax();  // return 5, [5, 1] the stack is changed now, and the top is different from the max.\nstk.top();     // return 1, [5, 1] the stack did not change.\nstk.peekMax(); // return 5, [5, 1] the stack did not change.\nstk.pop();     // return 1, [5] the top of the stack and the max element is now 5.\nstk.top();     // return 5, [5] the stack did not change.\n\n \nConstraints:\n\n-107 <= x <= 107\nAt most 105 calls will be made to push, pop, top, peekMax, and popMax.\nThere will be at least one element in the stack when pop, top, peekMax, or popMax is called.\n\n", "hints": [], "exampleTestcases": "[\"MaxStack\",\"push\",\"push\",\"push\",\"top\",\"popMax\",\"top\",\"peekMax\",\"pop\",\"top\"]\n[[],[5],[1],[5],[],[],[],[],[],[]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class MaxStack {\npublic:\n    MaxStack() {\n        \n    }\n    \n    void push(int x) {\n        \n    }\n    \n    int pop() {\n        \n    }\n    \n    int top() {\n        \n    }\n    \n    int peekMax() {\n        \n    }\n    \n    int popMax() {\n        \n    }\n};\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack* obj = new MaxStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->peekMax();\n * int param_5 = obj->popMax();\n */"}, "Java": {"langSlug": "java", "code": "class MaxStack {\n\n    public MaxStack() {\n        \n    }\n    \n    public void push(int x) {\n        \n    }\n    \n    public int pop() {\n        \n    }\n    \n    public int top() {\n        \n    }\n    \n    public int peekMax() {\n        \n    }\n    \n    public int popMax() {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = new MaxStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.peekMax();\n * int param_5 = obj.popMax();\n */"}, "Python": {"langSlug": "python", "code": "class MaxStack(object):\n\n    def __init__(self):\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def top(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def peekMax(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n    def popMax(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your MaxStack object will be instantiated and called as such:\n# obj = MaxStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.peekMax()\n# param_5 = obj.popMax()"}, "Python3": {"langSlug": "python3", "code": "class MaxStack:\n\n    def __init__(self):\n        \n\n    def push(self, x: int) -> None:\n        \n\n    def pop(self) -> int:\n        \n\n    def top(self) -> int:\n        \n\n    def peekMax(self) -> int:\n        \n\n    def popMax(self) -> int:\n        \n\n\n# Your MaxStack object will be instantiated and called as such:\n# obj = MaxStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.peekMax()\n# param_5 = obj.popMax()"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} MaxStack;\n\n\nMaxStack* maxStackCreate() {\n    \n}\n\nvoid maxStackPush(MaxStack* obj, int x) {\n    \n}\n\nint maxStackPop(MaxStack* obj) {\n    \n}\n\nint maxStackTop(MaxStack* obj) {\n    \n}\n\nint maxStackPeekMax(MaxStack* obj) {\n    \n}\n\nint maxStackPopMax(MaxStack* obj) {\n    \n}\n\nvoid maxStackFree(MaxStack* obj) {\n    \n}\n\n/**\n * Your MaxStack struct will be instantiated and called as such:\n * MaxStack* obj = maxStackCreate();\n * maxStackPush(obj, x);\n \n * int param_2 = maxStackPop(obj);\n \n * int param_3 = maxStackTop(obj);\n \n * int param_4 = maxStackPeekMax(obj);\n \n * int param_5 = maxStackPopMax(obj);\n \n * maxStackFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class MaxStack {\n\n    public MaxStack() {\n        \n    }\n    \n    public void Push(int x) {\n        \n    }\n    \n    public int Pop() {\n        \n    }\n    \n    public int Top() {\n        \n    }\n    \n    public int PeekMax() {\n        \n    }\n    \n    public int PopMax() {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = new MaxStack();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Top();\n * int param_4 = obj.PeekMax();\n * int param_5 = obj.PopMax();\n */"}, "JavaScript": {"langSlug": "javascript", "code": "\nvar MaxStack = function() {\n    \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMaxStack.prototype.push = function(x) {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.pop = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.top = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.peekMax = function() {\n    \n};\n\n/**\n * @return {number}\n */\nMaxStack.prototype.popMax = function() {\n    \n};\n\n/** \n * Your MaxStack object will be instantiated and called as such:\n * var obj = new MaxStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.peekMax()\n * var param_5 = obj.popMax()\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class MaxStack {\n    constructor() {\n        \n    }\n\n    push(x: number): void {\n        \n    }\n\n    pop(): number {\n        \n    }\n\n    top(): number {\n        \n    }\n\n    peekMax(): number {\n        \n    }\n\n    popMax(): number {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * var obj = new MaxStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.peekMax()\n * var param_5 = obj.popMax()\n */"}, "PHP": {"langSlug": "php", "code": "class MaxStack {\n    /**\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function top() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function peekMax() {\n        \n    }\n  \n    /**\n     * @return Integer\n     */\n    function popMax() {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * $obj = MaxStack();\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->top();\n * $ret_4 = $obj->peekMax();\n * $ret_5 = $obj->popMax();\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass MaxStack {\n\n    init() {\n        \n    }\n    \n    func push(_ x: Int) {\n        \n    }\n    \n    func pop() -> Int {\n        \n    }\n    \n    func top() -> Int {\n        \n    }\n    \n    func peekMax() -> Int {\n        \n    }\n    \n    func popMax() -> Int {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * let obj = MaxStack()\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.top()\n * let ret_4: Int = obj.peekMax()\n * let ret_5: Int = obj.popMax()\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class MaxStack() {\n\n    fun push(x: Int) {\n        \n    }\n\n    fun pop(): Int {\n        \n    }\n\n    fun top(): Int {\n        \n    }\n\n    fun peekMax(): Int {\n        \n    }\n\n    fun popMax(): Int {\n        \n    }\n\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * var obj = MaxStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.peekMax()\n * var param_5 = obj.popMax()\n */"}, "Dart": {"langSlug": "dart", "code": "class MaxStack {\n\n  MaxStack() {\n    \n  }\n  \n  void push(int x) {\n    \n  }\n  \n  int pop() {\n    \n  }\n  \n  int top() {\n    \n  }\n  \n  int peekMax() {\n    \n  }\n  \n  int popMax() {\n    \n  }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = MaxStack();\n * obj.push(x);\n * int param2 = obj.pop();\n * int param3 = obj.top();\n * int param4 = obj.peekMax();\n * int param5 = obj.popMax();\n */"}, "Go": {"langSlug": "golang", "code": "type MaxStack struct {\n    \n}\n\n\nfunc Constructor() MaxStack {\n    \n}\n\n\nfunc (this *MaxStack) Push(x int)  {\n    \n}\n\n\nfunc (this *MaxStack) Pop() int {\n    \n}\n\n\nfunc (this *MaxStack) Top() int {\n    \n}\n\n\nfunc (this *MaxStack) PeekMax() int {\n    \n}\n\n\nfunc (this *MaxStack) PopMax() int {\n    \n}\n\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.PeekMax();\n * param_5 := obj.PopMax();\n */"}, "Ruby": {"langSlug": "ruby", "code": "class MaxStack\n    def initialize()\n        \n    end\n\n\n=begin\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def top()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def peek_max()\n        \n    end\n\n\n=begin\n    :rtype: Integer\n=end\n    def pop_max()\n        \n    end\n\n\nend\n\n# Your MaxStack object will be instantiated and called as such:\n# obj = MaxStack.new()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.peek_max()\n# param_5 = obj.pop_max()"}, "Scala": {"langSlug": "scala", "code": "class MaxStack() {\n\n    def push(x: Int): Unit = {\n        \n    }\n\n    def pop(): Int = {\n        \n    }\n\n    def top(): Int = {\n        \n    }\n\n    def peekMax(): Int = {\n        \n    }\n\n    def popMax(): Int = {\n        \n    }\n\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * val obj = new MaxStack()\n * obj.push(x)\n * val param_2 = obj.pop()\n * val param_3 = obj.top()\n * val param_4 = obj.peekMax()\n * val param_5 = obj.popMax()\n */"}, "Rust": {"langSlug": "rust", "code": "struct MaxStack {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MaxStack {\n\n    fn new() -> Self {\n        \n    }\n    \n    fn push(&self, x: i32) {\n        \n    }\n    \n    fn pop(&self) -> i32 {\n        \n    }\n    \n    fn top(&self) -> i32 {\n        \n    }\n    \n    fn peek_max(&self) -> i32 {\n        \n    }\n    \n    fn pop_max(&self) -> i32 {\n        \n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * let obj = MaxStack::new();\n * obj.push(x);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.top();\n * let ret_4: i32 = obj.peek_max();\n * let ret_5: i32 = obj.pop_max();\n */"}, "Racket": {"langSlug": "racket", "code": "(define max-stack%\n  (class object%\n    (super-new)\n    \n    (init-field)\n    \n    ; push : exact-integer? -> void?\n    (define/public (push x)\n      )\n    ; pop : -> exact-integer?\n    (define/public (pop)\n      )\n    ; top : -> exact-integer?\n    (define/public (top)\n      )\n    ; peek-max : -> exact-integer?\n    (define/public (peek-max)\n      )\n    ; pop-max : -> exact-integer?\n    (define/public (pop-max)\n      )))\n\n;; Your max-stack% object will be instantiated and called as such:\n;; (define obj (new max-stack%))\n;; (send obj push x)\n;; (define param_2 (send obj pop))\n;; (define param_3 (send obj top))\n;; (define param_4 (send obj peek-max))\n;; (define param_5 (send obj pop-max))"}, "Erlang": {"langSlug": "erlang", "code": "-spec max_stack_init_() -> any().\nmax_stack_init_() ->\n  .\n\n-spec max_stack_push(X :: integer()) -> any().\nmax_stack_push(X) ->\n  .\n\n-spec max_stack_pop() -> integer().\nmax_stack_pop() ->\n  .\n\n-spec max_stack_top() -> integer().\nmax_stack_top() ->\n  .\n\n-spec max_stack_peek_max() -> integer().\nmax_stack_peek_max() ->\n  .\n\n-spec max_stack_pop_max() -> integer().\nmax_stack_pop_max() ->\n  .\n\n\n%% Your functions will be called as such:\n%% max_stack_init_(),\n%% max_stack_push(X),\n%% Param_2 = max_stack_pop(),\n%% Param_3 = max_stack_top(),\n%% Param_4 = max_stack_peek_max(),\n%% Param_5 = max_stack_pop_max(),\n\n%% max_stack_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule MaxStack do\n  @spec init_() :: any\n  def init_() do\n    \n  end\n\n  @spec push(x :: integer) :: any\n  def push(x) do\n    \n  end\n\n  @spec pop() :: integer\n  def pop() do\n    \n  end\n\n  @spec top() :: integer\n  def top() do\n    \n  end\n\n  @spec peek_max() :: integer\n  def peek_max() do\n    \n  end\n\n  @spec pop_max() :: integer\n  def pop_max() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# MaxStack.init_()\n# MaxStack.push(x)\n# param_2 = MaxStack.pop()\n# param_3 = MaxStack.top()\n# param_4 = MaxStack.peek_max()\n# param_5 = MaxStack.pop_max()\n\n# MaxStack.init_ will be called before every test case, in which you can do some necessary initializations."}}}