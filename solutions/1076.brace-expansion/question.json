{"question_id": "1076", "problem_slug": "brace-expansion", "problem_title": "Brace Expansion", "content": "You are given a string s representing a list of words. Each letter in the word has one or more options.\n\nIf there is one option, the letter is represented as is.\nIf there is more than one option, then curly braces delimit the options. For example, \"{a,b,c}\" represents options [\"a\", \"b\", \"c\"].\n\nFor example, if s = \"a{b,c}\", the first character is always 'a', but the second character can be 'b' or 'c'. The original list is [\"ab\", \"ac\"].\nReturn all words that can be formed in this manner, sorted in lexicographical order.\n \nExample 1:\nInput: s = \"{a,b}c{d,e}f\"\nOutput: [\"acdf\",\"acef\",\"bcdf\",\"bcef\"]\nExample 2:\nInput: s = \"abcd\"\nOutput: [\"abcd\"]\n\n \nConstraints:\n\n1 <= s.length <= 50\ns consists of curly brackets '{}', commas ',', and lowercase English letters.\ns is guaranteed to be a valid input.\nThere are no nested curly brackets.\nAll characters inside a pair of consecutive opening and ending curly brackets are different.\n\n", "hints": ["All generated strings are of the same size. How can we generate all of these strings?", "Do a backtracking on which each level of it has to choose one single (e.g. 'a') character or any character of the given parenthesized group (e.g. \"{a,b,c}\")"], "exampleTestcases": "\"{a,b}c{d,e}f\"\n\"abcd\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<string> expand(string s) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public String[] expand(String s) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def expand(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def expand(self, s: str) -> List[str]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** expand(char* s, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public string[] Expand(string s) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar expand = function(s) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function expand(s: string): string[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return String[]\n     */\n    function expand($s) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func expand(_ s: String) -> [String] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun expand(s: String): Array<String> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<String> expand(String s) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func expand(s string) []string {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} s\n# @return {String[]}\ndef expand(s)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def expand(s: String): Array[String] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn expand(s: String) -> Vec<String> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (expand s)\n  (-> string? (listof string?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec expand(S :: unicode:unicode_binary()) -> [unicode:unicode_binary()].\nexpand(S) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec expand(s :: String.t) :: [String.t]\n  def expand(s) do\n    \n  end\nend"}}}