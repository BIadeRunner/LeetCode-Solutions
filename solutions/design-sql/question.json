{"questionId": "2555", "acRate": 77.85642062689585, "difficulty": "Medium", "freqBar": 44.73384873877241, "frontendQuestionId": "2408", "paidOnly": true, "status": "ac", "title": "Design SQL", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Hash Table", "id": "VG9waWNUYWdOb2RlOjY=", "slug": "hash-table"}, {"name": "String", "id": "VG9waWNUYWdOb2RlOjEw", "slug": "string"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}], "titleSlug": "design-sql", "content": "<p>You are given <code>n</code> tables represented with two arrays <code>names</code> and <code>columns</code>, where <code>names[i]</code> is the name of the <code>i<sup>th</sup></code> table and <code>columns[i]</code> is the number of columns of the <code>i<sup>th</sup></code> table.</p>\n\n<p>You should be able to perform the following <strong>operations</strong>:</p>\n\n<ul>\n\t<li><strong>Insert</strong> a row in a specific table. Each row you insert has an id. The id is assigned using an auto-increment method where the id of the first inserted row is 1, and the id of each other row inserted into the same table is the id of the last inserted row (even if it was deleted) plus one.</li>\n\t<li><strong>Delete</strong> a row from a specific table. <strong>Note</strong> that deleting a row does not affect the id of the next inserted row.</li>\n\t<li><strong>Select</strong> a specific cell from any table and return its value.</li>\n</ul>\n\n<p>Implement the <code>SQL</code> class:</p>\n\n<ul>\n\t<li><code>SQL(String[] names, int[] columns)</code> Creates the <code>n</code> tables.</li>\n\t<li><code>void insertRow(String name, String[] row)</code> Adds a row to the table <code>name</code>. It is <strong>guaranteed</strong> that the table will exist, and the size of the array <code>row</code> is equal to the number of columns in the table.</li>\n\t<li><code>void deleteRow(String name, int rowId)</code> Removes the row <code>rowId</code> from the table <code>name</code>. It is <strong>guaranteed</strong> that the table and row will <strong>exist</strong>.</li>\n\t<li><code>String selectCell(String name, int rowId, int columnId)</code> Returns the value of the cell in the row <code>rowId</code> and the column <code>columnId</code> from the table <code>name</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SQL&quot;, &quot;insertRow&quot;, &quot;selectCell&quot;, &quot;insertRow&quot;, &quot;deleteRow&quot;, &quot;selectCell&quot;]\n[[[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], [2, 3, 1]], [&quot;two&quot;, [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]], [&quot;two&quot;, 1, 3], [&quot;two&quot;, [&quot;fourth&quot;, &quot;fifth&quot;, &quot;sixth&quot;]], [&quot;two&quot;, 1], [&quot;two&quot;, 2, 2]]\n<strong>Output</strong>\n[null, null, &quot;third&quot;, null, null, &quot;fifth&quot;]\n\n<strong>Explanation</strong>\nSQL sql = new SQL([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], [2, 3, 1]); // creates three tables.\nsql.insertRow(&quot;two&quot;, [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]); // adds a row to the table &quot;two&quot;. Its id is 1.\nsql.selectCell(&quot;two&quot;, 1, 3); // return &quot;third&quot;, finds the value of the third column in the row with id 1 of the table &quot;two&quot;.\nsql.insertRow(&quot;two&quot;, [&quot;fourth&quot;, &quot;fifth&quot;, &quot;sixth&quot;]); // adds another row to the table &quot;two&quot;. Its id is 2.\nsql.deleteRow(&quot;two&quot;, 1); // deletes the first row of the table &quot;two&quot;. Note that the second row will still have the id 2.\nsql.selectCell(&quot;two&quot;, 2, 2); // return &quot;fifth&quot;, finds the value of the second column in the row with id 2 of the table &quot;two&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == names.length == columns.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= names[i].length, row[i].length, name.length &lt;= 20</code></li>\n\t<li><code>names[i]</code>, <code>row[i]</code>, and <code>name</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= columns[i] &lt;= 100</code></li>\n\t<li>All the strings of <code>names</code> are <strong>distinct</strong>.</li>\n\t<li><code>name</code> exists in the array <code>names</code>.</li>\n\t<li><code>row.length</code> equals the number of columns in the chosen table.</li>\n\t<li><code>rowId</code> and <code>columnId</code> will be valid.</li>\n\t<li>At most <code>250</code> calls will be made to <code>insertRow</code> and <code>deleteRow</code>.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>selectCell</code>.</li>\n</ul>\n", "hints": ["What data structure do you need to use for this problem?", "Try using a Hash map, each table name will be the key, and the value will be an array of all rows."], "exampleTestcases": "[\"SQL\",\"insertRow\",\"selectCell\",\"insertRow\",\"deleteRow\",\"selectCell\"]\n[[[\"one\",\"two\",\"three\"],[2,3,1]],[\"two\",[\"first\",\"second\",\"third\"]],[\"two\",1,3],[\"two\",[\"fourth\",\"fifth\",\"sixth\"]],[\"two\",1],[\"two\",2,2]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class SQL {\npublic:\n    SQL(vector<string>& names, vector<int>& columns) {\n        \n    }\n    \n    void insertRow(string name, vector<string> row) {\n        \n    }\n    \n    void deleteRow(string name, int rowId) {\n        \n    }\n    \n    string selectCell(string name, int rowId, int columnId) {\n        \n    }\n};\n\n/**\n * Your SQL object will be instantiated and called as such:\n * SQL* obj = new SQL(names, columns);\n * obj->insertRow(name,row);\n * obj->deleteRow(name,rowId);\n * string param_3 = obj->selectCell(name,rowId,columnId);\n */"}, {"lang": "Java", "langSlug": "java", "code": "class SQL {\n\n    public SQL(List<String> names, List<Integer> columns) {\n        \n    }\n    \n    public void insertRow(String name, List<String> row) {\n        \n    }\n    \n    public void deleteRow(String name, int rowId) {\n        \n    }\n    \n    public String selectCell(String name, int rowId, int columnId) {\n        \n    }\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * SQL obj = new SQL(names, columns);\n * obj.insertRow(name,row);\n * obj.deleteRow(name,rowId);\n * String param_3 = obj.selectCell(name,rowId,columnId);\n */"}, {"lang": "Python", "langSlug": "python", "code": "class SQL(object):\n\n    def __init__(self, names, columns):\n        \"\"\"\n        :type names: List[str]\n        :type columns: List[int]\n        \"\"\"\n        \n\n    def insertRow(self, name, row):\n        \"\"\"\n        :type name: str\n        :type row: List[str]\n        :rtype: None\n        \"\"\"\n        \n\n    def deleteRow(self, name, rowId):\n        \"\"\"\n        :type name: str\n        :type rowId: int\n        :rtype: None\n        \"\"\"\n        \n\n    def selectCell(self, name, rowId, columnId):\n        \"\"\"\n        :type name: str\n        :type rowId: int\n        :type columnId: int\n        :rtype: str\n        \"\"\"\n        \n\n\n# Your SQL object will be instantiated and called as such:\n# obj = SQL(names, columns)\n# obj.insertRow(name,row)\n# obj.deleteRow(name,rowId)\n# param_3 = obj.selectCell(name,rowId,columnId)"}, {"lang": "Python3", "langSlug": "python3", "code": "class SQL:\n\n    def __init__(self, names: List[str], columns: List[int]):\n        \n\n    def insertRow(self, name: str, row: List[str]) -> None:\n        \n\n    def deleteRow(self, name: str, rowId: int) -> None:\n        \n\n    def selectCell(self, name: str, rowId: int, columnId: int) -> str:\n        \n\n\n# Your SQL object will be instantiated and called as such:\n# obj = SQL(names, columns)\n# obj.insertRow(name,row)\n# obj.deleteRow(name,rowId)\n# param_3 = obj.selectCell(name,rowId,columnId)"}, {"lang": "C", "langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} SQL;\n\n\nSQL* sQLCreate(char** names, int namesSize, int* columns, int columnsSize) {\n    \n}\n\nvoid sQLInsertRow(SQL* obj, char* name, char** row, int rowSize) {\n    \n}\n\nvoid sQLDeleteRow(SQL* obj, char* name, int rowId) {\n    \n}\n\nchar* sQLSelectCell(SQL* obj, char* name, int rowId, int columnId) {\n    \n}\n\nvoid sQLFree(SQL* obj) {\n    \n}\n\n/**\n * Your SQL struct will be instantiated and called as such:\n * SQL* obj = sQLCreate(names, namesSize, columns, columnsSize);\n * sQLInsertRow(obj, name, row, rowSize);\n \n * sQLDeleteRow(obj, name, rowId);\n \n * char* param_3 = sQLSelectCell(obj, name, rowId, columnId);\n \n * sQLFree(obj);\n*/"}, {"lang": "C#", "langSlug": "csharp", "code": "public class SQL {\n\n    public SQL(IList<string> names, IList<int> columns) {\n        \n    }\n    \n    public void InsertRow(string name, IList<string> row) {\n        \n    }\n    \n    public void DeleteRow(string name, int rowId) {\n        \n    }\n    \n    public string SelectCell(string name, int rowId, int columnId) {\n        \n    }\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * SQL obj = new SQL(names, columns);\n * obj.InsertRow(name,row);\n * obj.DeleteRow(name,rowId);\n * string param_3 = obj.SelectCell(name,rowId,columnId);\n */"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {string[]} names\n * @param {number[]} columns\n */\nvar SQL = function(names, columns) {\n    \n};\n\n/** \n * @param {string} name \n * @param {string[]} row\n * @return {void}\n */\nSQL.prototype.insertRow = function(name, row) {\n    \n};\n\n/** \n * @param {string} name \n * @param {number} rowId\n * @return {void}\n */\nSQL.prototype.deleteRow = function(name, rowId) {\n    \n};\n\n/** \n * @param {string} name \n * @param {number} rowId \n * @param {number} columnId\n * @return {string}\n */\nSQL.prototype.selectCell = function(name, rowId, columnId) {\n    \n};\n\n/** \n * Your SQL object will be instantiated and called as such:\n * var obj = new SQL(names, columns)\n * obj.insertRow(name,row)\n * obj.deleteRow(name,rowId)\n * var param_3 = obj.selectCell(name,rowId,columnId)\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "class SQL {\n    constructor(names: string[], columns: number[]) {\n        \n    }\n\n    insertRow(name: string, row: string[]): void {\n        \n    }\n\n    deleteRow(name: string, rowId: number): void {\n        \n    }\n\n    selectCell(name: string, rowId: number, columnId: number): string {\n        \n    }\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * var obj = new SQL(names, columns)\n * obj.insertRow(name,row)\n * obj.deleteRow(name,rowId)\n * var param_3 = obj.selectCell(name,rowId,columnId)\n */"}, {"lang": "PHP", "langSlug": "php", "code": "class SQL {\n    /**\n     * @param String[] $names\n     * @param Integer[] $columns\n     */\n    function __construct($names, $columns) {\n        \n    }\n  \n    /**\n     * @param String $name\n     * @param String[] $row\n     * @return NULL\n     */\n    function insertRow($name, $row) {\n        \n    }\n  \n    /**\n     * @param String $name\n     * @param Integer $rowId\n     * @return NULL\n     */\n    function deleteRow($name, $rowId) {\n        \n    }\n  \n    /**\n     * @param String $name\n     * @param Integer $rowId\n     * @param Integer $columnId\n     * @return String\n     */\n    function selectCell($name, $rowId, $columnId) {\n        \n    }\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * $obj = SQL($names, $columns);\n * $obj->insertRow($name, $row);\n * $obj->deleteRow($name, $rowId);\n * $ret_3 = $obj->selectCell($name, $rowId, $columnId);\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "\nclass SQL {\n\n    init(_ names: [String], _ columns: [Int]) {\n        \n    }\n    \n    func insertRow(_ name: String, _ row: [String]) {\n        \n    }\n    \n    func deleteRow(_ name: String, _ rowId: Int) {\n        \n    }\n    \n    func selectCell(_ name: String, _ rowId: Int, _ columnId: Int) -> String {\n        \n    }\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * let obj = SQL(names, columns)\n * obj.insertRow(name, row)\n * obj.deleteRow(name, rowId)\n * let ret_3: String = obj.selectCell(name, rowId, columnId)\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class SQL(names: List<String>, columns: List<Int>) {\n\n    fun insertRow(name: String, row: List<String>) {\n        \n    }\n\n    fun deleteRow(name: String, rowId: Int) {\n        \n    }\n\n    fun selectCell(name: String, rowId: Int, columnId: Int): String {\n        \n    }\n\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * var obj = SQL(names, columns)\n * obj.insertRow(name,row)\n * obj.deleteRow(name,rowId)\n * var param_3 = obj.selectCell(name,rowId,columnId)\n */"}, {"lang": "Dart", "langSlug": "dart", "code": "class SQL {\n\n  SQL(List<String> names, List<int> columns) {\n    \n  }\n  \n  void insertRow(String name, List<String> row) {\n    \n  }\n  \n  void deleteRow(String name, int rowId) {\n    \n  }\n  \n  String selectCell(String name, int rowId, int columnId) {\n    \n  }\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * SQL obj = SQL(names, columns);\n * obj.insertRow(name,row);\n * obj.deleteRow(name,rowId);\n * String param3 = obj.selectCell(name,rowId,columnId);\n */"}, {"lang": "Go", "langSlug": "golang", "code": "type SQL struct {\n    \n}\n\n\nfunc Constructor(names []string, columns []int) SQL {\n    \n}\n\n\nfunc (this *SQL) InsertRow(name string, row []string)  {\n    \n}\n\n\nfunc (this *SQL) DeleteRow(name string, rowId int)  {\n    \n}\n\n\nfunc (this *SQL) SelectCell(name string, rowId int, columnId int) string {\n    \n}\n\n\n/**\n * Your SQL object will be instantiated and called as such:\n * obj := Constructor(names, columns);\n * obj.InsertRow(name,row);\n * obj.DeleteRow(name,rowId);\n * param_3 := obj.SelectCell(name,rowId,columnId);\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "class SQL\n\n=begin\n    :type names: String[]\n    :type columns: Integer[]\n=end\n    def initialize(names, columns)\n        \n    end\n\n\n=begin\n    :type name: String\n    :type row: String[]\n    :rtype: Void\n=end\n    def insert_row(name, row)\n        \n    end\n\n\n=begin\n    :type name: String\n    :type row_id: Integer\n    :rtype: Void\n=end\n    def delete_row(name, row_id)\n        \n    end\n\n\n=begin\n    :type name: String\n    :type row_id: Integer\n    :type column_id: Integer\n    :rtype: String\n=end\n    def select_cell(name, row_id, column_id)\n        \n    end\n\n\nend\n\n# Your SQL object will be instantiated and called as such:\n# obj = SQL.new(names, columns)\n# obj.insert_row(name, row)\n# obj.delete_row(name, row_id)\n# param_3 = obj.select_cell(name, row_id, column_id)"}, {"lang": "Scala", "langSlug": "scala", "code": "class SQL(_names: List[String], _columns: List[Int]) {\n\n    def insertRow(name: String, row: List[String]): Unit = {\n        \n    }\n\n    def deleteRow(name: String, rowId: Int): Unit = {\n        \n    }\n\n    def selectCell(name: String, rowId: Int, columnId: Int): String = {\n        \n    }\n\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * val obj = new SQL(names, columns)\n * obj.insertRow(name,row)\n * obj.deleteRow(name,rowId)\n * val param_3 = obj.selectCell(name,rowId,columnId)\n */"}, {"lang": "Rust", "langSlug": "rust", "code": "struct SQL {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl SQL {\n\n    fn new(names: Vec<String>, columns: Vec<i32>) -> Self {\n        \n    }\n    \n    fn insert_row(&self, name: String, row: Vec<String>) {\n        \n    }\n    \n    fn delete_row(&self, name: String, row_id: i32) {\n        \n    }\n    \n    fn select_cell(&self, name: String, row_id: i32, column_id: i32) -> String {\n        \n    }\n}\n\n/**\n * Your SQL object will be instantiated and called as such:\n * let obj = SQL::new(names, columns);\n * obj.insert_row(name, row);\n * obj.delete_row(name, rowId);\n * let ret_3: String = obj.select_cell(name, rowId, columnId);\n */"}, {"lang": "Racket", "langSlug": "racket", "code": "(define sql%\n  (class object%\n    (super-new)\n    \n    ; names : (listof string?)\n    ; columns : (listof exact-integer?)\n    (init-field\n      names\n      columns)\n    \n    ; insert-row : string? (listof string?) -> void?\n    (define/public (insert-row name row)\n      )\n    ; delete-row : string? exact-integer? -> void?\n    (define/public (delete-row name row-id)\n      )\n    ; select-cell : string? exact-integer? exact-integer? -> string?\n    (define/public (select-cell name row-id column-id)\n      )))\n\n;; Your sql% object will be instantiated and called as such:\n;; (define obj (new sql% [names names] [columns columns]))\n;; (send obj insert-row name row)\n;; (send obj delete-row name row-id)\n;; (define param_3 (send obj select-cell name row-id column-id))"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec sql_init_(Names :: [unicode:unicode_binary()], Columns :: [integer()]) -> any().\nsql_init_(Names, Columns) ->\n  .\n\n-spec sql_insert_row(Name :: unicode:unicode_binary(), Row :: [unicode:unicode_binary()]) -> any().\nsql_insert_row(Name, Row) ->\n  .\n\n-spec sql_delete_row(Name :: unicode:unicode_binary(), RowId :: integer()) -> any().\nsql_delete_row(Name, RowId) ->\n  .\n\n-spec sql_select_cell(Name :: unicode:unicode_binary(), RowId :: integer(), ColumnId :: integer()) -> unicode:unicode_binary().\nsql_select_cell(Name, RowId, ColumnId) ->\n  .\n\n\n%% Your functions will be called as such:\n%% sql_init_(Names, Columns),\n%% sql_insert_row(Name, Row),\n%% sql_delete_row(Name, RowId),\n%% Param_3 = sql_select_cell(Name, RowId, ColumnId),\n\n%% sql_init_ will be called before every test case, in which you can do some necessary initializations."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule SQL do\n  @spec init_(names :: [String.t], columns :: [integer]) :: any\n  def init_(names, columns) do\n    \n  end\n\n  @spec insert_row(name :: String.t, row :: [String.t]) :: any\n  def insert_row(name, row) do\n    \n  end\n\n  @spec delete_row(name :: String.t, row_id :: integer) :: any\n  def delete_row(name, row_id) do\n    \n  end\n\n  @spec select_cell(name :: String.t, row_id :: integer, column_id :: integer) :: String.t\n  def select_cell(name, row_id, column_id) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# SQL.init_(names, columns)\n# SQL.insert_row(name, row)\n# SQL.delete_row(name, row_id)\n# param_3 = SQL.select_cell(name, row_id, column_id)\n\n# SQL.init_ will be called before every test case, in which you can do some necessary initializations."}], "similarQuestionList": []}