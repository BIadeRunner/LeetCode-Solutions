{"question_id": "1934", "problem_slug": "evaluate-the-bracket-pairs-of-a-string", "problem_title": "Evaluate the Bracket Pairs of a String", "content": "You are given a string s that contains some bracket pairs, with each pair containing a non-empty key.\n\nFor example, in the string \"(name)is(age)yearsold\", there are two bracket pairs that contain the keys \"name\" and \"age\".\n\nYou know the values of a wide range of keys. This is represented by a 2D string array knowledge where each knowledge[i] = [keyi, valuei] indicates that key keyi has a value of valuei.\nYou are tasked to evaluate all of the bracket pairs. When you evaluate a bracket pair that contains some key keyi, you will:\n\nReplace keyi and the bracket pair with the key's corresponding valuei.\nIf you do not know the value of the key, you will replace keyi and the bracket pair with a question mark \"?\" (without the quotation marks).\n\nEach key will appear at most once in your knowledge. There will not be any nested brackets in s.\nReturn the resulting string after evaluating all of the bracket pairs.\n \nExample 1:\n\nInput: s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]]\nOutput: \"bobistwoyearsold\"\nExplanation:\nThe key \"name\" has a value of \"bob\", so replace \"(name)\" with \"bob\".\nThe key \"age\" has a value of \"two\", so replace \"(age)\" with \"two\".\n\nExample 2:\n\nInput: s = \"hi(name)\", knowledge = [[\"a\",\"b\"]]\nOutput: \"hi?\"\nExplanation: As you do not know the value of the key \"name\", replace \"(name)\" with \"?\".\n\nExample 3:\n\nInput: s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]]\nOutput: \"yesyesyesaaa\"\nExplanation: The same key can appear multiple times.\nThe key \"a\" has a value of \"yes\", so replace all occurrences of \"(a)\" with \"yes\".\nNotice that the \"a\"s not in a bracket pair are not evaluated.\n\n \nConstraints:\n\n1 <= s.length <= 105\n0 <= knowledge.length <= 105\nknowledge[i].length == 2\n1 <= keyi.length, valuei.length <= 10\ns consists of lowercase English letters and round brackets '(' and ')'.\nEvery open bracket '(' in s will have a corresponding close bracket ')'.\nThe key in each bracket pair of s will be non-empty.\nThere will not be any nested bracket pairs in s.\nkeyi and valuei consist of lowercase English letters.\nEach keyi in knowledge is unique.\n\n", "hints": ["Process pairs from right to left to handle repeats", "Keep track of the current enclosed string using another string"], "exampleTestcases": "\"(name)is(age)yearsold\"\n[[\"name\",\"bob\"],[\"age\",\"two\"]]\n\"hi(name)\"\n[[\"a\",\"b\"]]\n\"(a)(a)(a)aaa\"\n[[\"a\",\"yes\"]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    string evaluate(string s, vector<vector<string>>& knowledge) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public String evaluate(String s, List<List<String>> knowledge) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def evaluate(self, s, knowledge):\n        \"\"\"\n        :type s: str\n        :type knowledge: List[List[str]]\n        :rtype: str\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:\n        "}, "C": {"langSlug": "c", "code": "char* evaluate(char* s, char*** knowledge, int knowledgeSize, int* knowledgeColSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public string Evaluate(string s, IList<IList<string>> knowledge) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} s\n * @param {string[][]} knowledge\n * @return {string}\n */\nvar evaluate = function(s, knowledge) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function evaluate(s: string, knowledge: string[][]): string {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[][] $knowledge\n     * @return String\n     */\n    function evaluate($s, $knowledge) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func evaluate(_ s: String, _ knowledge: [[String]]) -> String {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun evaluate(s: String, knowledge: List<List<String>>): String {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  String evaluate(String s, List<List<String>> knowledge) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func evaluate(s string, knowledge [][]string) string {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} s\n# @param {String[][]} knowledge\n# @return {String}\ndef evaluate(s, knowledge)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def evaluate(s: String, knowledge: List[List[String]]): String = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn evaluate(s: String, knowledge: Vec<Vec<String>>) -> String {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (evaluate s knowledge)\n  (-> string? (listof (listof string?)) string?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec evaluate(S :: unicode:unicode_binary(), Knowledge :: [[unicode:unicode_binary()]]) -> unicode:unicode_binary().\nevaluate(S, Knowledge) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec evaluate(s :: String.t, knowledge :: [[String.t]]) :: String.t\n  def evaluate(s, knowledge) do\n    \n  end\nend"}}}