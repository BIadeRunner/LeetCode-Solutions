{"question_id": "2635", "problem_slug": "check-if-point-is-reachable", "problem_title": "Check if Point Is Reachable", "content": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.\n \nExample 1:\n\nInput: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.\n\nExample 2:\n\nInput: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7).\n\n \nConstraints:\n\n1 <= targetX, targetY <= 109\n\n", "hints": ["Let’s go in reverse order, from (targetX, targetY) to (1, 1). So, now we can move from (x, y) to (x+y, y), (x, y+x), (x/2, y) if x is even, and (x, y/2) if y is even.", "When is it optimal to use the third and fourth operations?", "Think how GCD of (x, y) is affected if we apply the first two operations.", "How can we check if we can reach (1, 1) using the GCD value calculate above?"], "exampleTestcases": "6\n9\n4\n7", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool isReachable(int targetX, int targetY) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean isReachable(int targetX, int targetY) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def isReachable(self, targetX, targetY):\n        \"\"\"\n        :type targetX: int\n        :type targetY: int\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool isReachable(int targetX, int targetY) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool IsReachable(int targetX, int targetY) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} targetX\n * @param {number} targetY\n * @return {boolean}\n */\nvar isReachable = function(targetX, targetY) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function isReachable(targetX: number, targetY: number): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $targetX\n     * @param Integer $targetY\n     * @return Boolean\n     */\n    function isReachable($targetX, $targetY) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func isReachable(_ targetX: Int, _ targetY: Int) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun isReachable(targetX: Int, targetY: Int): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool isReachable(int targetX, int targetY) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func isReachable(targetX int, targetY int) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} target_x\n# @param {Integer} target_y\n# @return {Boolean}\ndef is_reachable(target_x, target_y)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def isReachable(targetX: Int, targetY: Int): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn is_reachable(target_x: i32, target_y: i32) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (is-reachable targetX targetY)\n  (-> exact-integer? exact-integer? boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec is_reachable(TargetX :: integer(), TargetY :: integer()) -> boolean().\nis_reachable(TargetX, TargetY) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec is_reachable(target_x :: integer, target_y :: integer) :: boolean\n  def is_reachable(target_x, target_y) do\n    \n  end\nend"}}}