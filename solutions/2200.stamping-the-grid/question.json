{"question_id": "2200", "problem_slug": "stamping-the-grid", "problem_title": "Stamping the Grid", "content": "You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\nYou are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\n\nCover all the empty cells.\nDo not cover any of the occupied cells.\nWe can put as many stamps as we want.\nStamps can overlap with each other.\nStamps are not allowed to be rotated.\nStamps must stay completely inside the grid.\n\nReturn true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.\n \nExample 1:\n\n\nInput: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\nOutput: true\nExplanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n\nExample 2:\n\n\nInput: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \nOutput: false \nExplanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n\n \nConstraints:\n\nm == grid.length\nn == grid[r].length\n1 <= m, n <= 105\n1 <= m * n <= 2 * 105\ngrid[r][c] is either 0 or 1.\n1 <= stampHeight, stampWidth <= 105\n\n", "hints": ["We can check if every empty cell is a part of a consecutive row of empty cells that has a width of at least stampWidth as well as a consecutive column of empty cells that has a height of at least stampHeight.", "We can prove that this condition is sufficient and necessary to fit the stamps while following the given restrictions and requirements.", "For each row, find every consecutive row of empty cells, and mark all the cells where the consecutive row is at least stampWidth wide. Do the same for the columns with stampHeight. Then, you can check if every cell is marked twice."], "exampleTestcases": "[[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]]\n4\n3\n[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]\n2\n2", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type stampHeight: int\n        :type stampWidth: int\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool PossibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} grid\n * @param {number} stampHeight\n * @param {number} stampWidth\n * @return {boolean}\n */\nvar possibleToStamp = function(grid, stampHeight, stampWidth) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function possibleToStamp(grid: number[][], stampHeight: number, stampWidth: number): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $stampHeight\n     * @param Integer $stampWidth\n     * @return Boolean\n     */\n    function possibleToStamp($grid, $stampHeight, $stampWidth) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func possibleToStamp(_ grid: [[Int]], _ stampHeight: Int, _ stampWidth: Int) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun possibleToStamp(grid: Array<IntArray>, stampHeight: Int, stampWidth: Int): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool possibleToStamp(List<List<int>> grid, int stampHeight, int stampWidth) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func possibleToStamp(grid [][]int, stampHeight int, stampWidth int) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[][]} grid\n# @param {Integer} stamp_height\n# @param {Integer} stamp_width\n# @return {Boolean}\ndef possible_to_stamp(grid, stamp_height, stamp_width)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def possibleToStamp(grid: Array[Array[Int]], stampHeight: Int, stampWidth: Int): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn possible_to_stamp(grid: Vec<Vec<i32>>, stamp_height: i32, stamp_width: i32) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (possible-to-stamp grid stampHeight stampWidth)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer? boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec possible_to_stamp(Grid :: [[integer()]], StampHeight :: integer(), StampWidth :: integer()) -> boolean().\npossible_to_stamp(Grid, StampHeight, StampWidth) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec possible_to_stamp(grid :: [[integer]], stamp_height :: integer, stamp_width :: integer) :: boolean\n  def possible_to_stamp(grid, stamp_height, stamp_width) do\n    \n  end\nend"}}}