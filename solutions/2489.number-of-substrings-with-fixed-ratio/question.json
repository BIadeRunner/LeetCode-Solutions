{"questionId": "2629", "acRate": 57.031630170316305, "difficulty": "Medium", "freqBar": 0.0, "frontendQuestionId": "2489", "paidOnly": true, "status": "ac", "title": "Number of Substrings With Fixed Ratio", "topicTags": [{"name": "Hash Table", "id": "VG9waWNUYWdOb2RlOjY=", "slug": "hash-table"}, {"name": "Math", "id": "VG9waWNUYWdOb2RlOjg=", "slug": "math"}, {"name": "String", "id": "VG9waWNUYWdOb2RlOjEw", "slug": "string"}, {"name": "Prefix Sum", "id": "VG9waWNUYWdOb2RlOjYxMDY4", "slug": "prefix-sum"}], "titleSlug": "number-of-substrings-with-fixed-ratio", "content": "<p>You are given a binary string <code>s</code>, and two integers <code>num1</code> and <code>num2</code>. <code>num1</code> and <code>num2</code> are coprime numbers.</p>\n\n<p>A <strong>ratio substring</strong> is a substring of s where the ratio between the number of <code>0</code>&#39;s and the number of <code>1</code>&#39;s in the substring is exactly <code>num1 : num2</code>.</p>\n\n<ul>\n\t<li>For example, if <code>num1 = 2</code> and <code>num2 = 3</code>, then <code>&quot;01011&quot;</code> and <code>&quot;1110000111&quot;</code> are ratio substrings, while <code>&quot;11000&quot;</code> is not.</li>\n</ul>\n\n<p>Return <em>the number of <strong>non-empty</strong> ratio substrings of </em><code>s</code>.</p>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>A <strong>substring</strong> is a contiguous sequence of characters within a string.</li>\n\t<li>Two values <code>x</code> and <code>y</code> are <strong>coprime</strong> if <code>gcd(x, y) == 1</code> where <code>gcd(x, y)</code> is the greatest common divisor of <code>x</code> and <code>y</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0110011&quot;, num1 = 1, num2 = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There exist 4 non-empty ratio substrings.\n- The substring s[0..2]: &quot;<u>011</u>0011&quot;. It contains one 0 and two 1&#39;s. The ratio is 1 : 2.\n- The substring s[1..4]: &quot;0<u>110</u>011&quot;. It contains one 0 and two 1&#39;s. The ratio is 1 : 2.\n- The substring s[4..6]: &quot;0110<u>011</u>&quot;. It contains one 0 and two 1&#39;s. The ratio is 1 : 2.\n- The substring s[1..6]: &quot;0<u>110011</u>&quot;. It contains two 0&#39;s and four 1&#39;s. The ratio is 2 : 4 == 1 : 2.\nIt can be shown that there are no more ratio substrings.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;10101&quot;, num1 = 3, num2 = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no ratio substrings of s. We return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= num1, num2 &lt;= s.length</code></li>\n\t<li><code>num1</code> and <code>num2</code> are coprime integers.</li>\n</ul>\n", "hints": ["Let Func(i) denote the number of 0\u2019s in the prefix [0\u2026i]. We want to find the number of pairs of indices L and R such that Func(R) - Func(L) : R - L - Func(R) + Func(L) = num1 : num2.", "It is better to simplify the formula.", "Func(R) * (num1 + num2) - R * num1 = Func(L) * (num1 + num2) - L * num1.", "Iterate from left to right and use a hash map to count the number of indices having the same value for the above formula."], "exampleTestcases": "\"0110011\"\n1\n2\n\"10101\"\n3\n1", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    long long fixedRatio(string s, int num1, int num2) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public long fixedRatio(String s, int num1, int num2) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def fixedRatio(self, s, num1, num2):\n        \"\"\"\n        :type s: str\n        :type num1: int\n        :type num2: int\n        :rtype: int\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n        "}, {"lang": "C", "langSlug": "c", "code": "long long fixedRatio(char* s, int num1, int num2) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public long FixedRatio(string s, int num1, int num2) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {string} s\n * @param {number} num1\n * @param {number} num2\n * @return {number}\n */\nvar fixedRatio = function(s, num1, num2) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function fixedRatio(s: string, num1: number, num2: number): number {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param Integer $num1\n     * @param Integer $num2\n     * @return Integer\n     */\n    function fixedRatio($s, $num1, $num2) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func fixedRatio(_ s: String, _ num1: Int, _ num2: Int) -> Int {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun fixedRatio(s: String, num1: Int, num2: Int): Long {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  int fixedRatio(String s, int num1, int num2) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func fixedRatio(s string, num1 int, num2 int) int64 {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {String} s\n# @param {Integer} num1\n# @param {Integer} num2\n# @return {Integer}\ndef fixed_ratio(s, num1, num2)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def fixedRatio(s: String, num1: Int, num2: Int): Long = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn fixed_ratio(s: String, num1: i32, num2: i32) -> i64 {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (fixed-ratio s num1 num2)\n  (-> string? exact-integer? exact-integer? exact-integer?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec fixed_ratio(S :: unicode:unicode_binary(), Num1 :: integer(), Num2 :: integer()) -> integer().\nfixed_ratio(S, Num1, Num2) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec fixed_ratio(s :: String.t, num1 :: integer, num2 :: integer) :: integer\n  def fixed_ratio(s, num1, num2) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Easy", "titleSlug": "count-binary-substrings", "title": "Count Binary Substrings", "isPaidOnly": false}]}