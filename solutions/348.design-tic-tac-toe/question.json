{"question_id": "348", "problem_slug": "design-tic-tac-toe", "problem_title": "Design Tic-Tac-Toe", "content": "Assume the following rules are for the tic-tac-toe game on an n x n board between two players:\n\nA move is guaranteed to be valid and is placed on an empty block.\nOnce a winning condition is reached, no more moves are allowed.\nA player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.\n\nImplement the TicTacToe class:\n\nTicTacToe(int n) Initializes the object the size of the board n.\nint move(int row, int col, int player) Indicates that the player with id player plays at the cell (row, col) of the board. The move is guaranteed to be a valid move, and the two players alternate in making moves. Return\n\t\n0 if there is no winner after the move,\n1 if player 1 is the winner after the move, or\n2 if player 2 is the winner after the move.\n\n\n\n \nExample 1:\n\nInput\n[\"TicTacToe\", \"move\", \"move\", \"move\", \"move\", \"move\", \"move\", \"move\"]\n[[3], [0, 0, 1], [0, 2, 2], [2, 2, 1], [1, 1, 2], [2, 0, 1], [1, 0, 2], [2, 1, 1]]\nOutput\n[null, 0, 0, 0, 0, 0, 0, 1]\n\nExplanation\nTicTacToe ticTacToe = new TicTacToe(3);\nAssume that player 1 is \"X\" and player 2 is \"O\" in the board.\nticTacToe.move(0, 0, 1); // return 0 (no one wins)\n|X| | |\n| | | |    // Player 1 makes a move at (0, 0).\n| | | |\n\nticTacToe.move(0, 2, 2); // return 0 (no one wins)\n|X| |O|\n| | | |    // Player 2 makes a move at (0, 2).\n| | | |\n\nticTacToe.move(2, 2, 1); // return 0 (no one wins)\n|X| |O|\n| | | |    // Player 1 makes a move at (2, 2).\n| | |X|\n\nticTacToe.move(1, 1, 2); // return 0 (no one wins)\n|X| |O|\n| |O| |    // Player 2 makes a move at (1, 1).\n| | |X|\n\nticTacToe.move(2, 0, 1); // return 0 (no one wins)\n|X| |O|\n| |O| |    // Player 1 makes a move at (2, 0).\n|X| |X|\n\nticTacToe.move(1, 0, 2); // return 0 (no one wins)\n|X| |O|\n|O|O| |    // Player 2 makes a move at (1, 0).\n|X| |X|\n\nticTacToe.move(2, 1, 1); // return 1 (player 1 wins)\n|X| |O|\n|O|O| |    // Player 1 makes a move at (2, 1).\n|X|X|X|\n\n \nConstraints:\n\n2 <= n <= 100\nplayer is 1 or 2.\n0 <= row, col < n\n(row, col) are unique for each different call to move.\nAt most n2 calls will be made to move.\n\n \nFollow-up: Could you do better than O(n2) per move() operation?\n", "hints": ["Could you trade extra space such that <code>move()</code> operation can be done in O(1)?", "You need two arrays: int rows[n], int cols[n], plus two variables: diagonal, anti_diagonal."], "exampleTestcases": "[\"TicTacToe\",\"move\",\"move\",\"move\",\"move\",\"move\",\"move\",\"move\"]\n[[3],[0,0,1],[0,2,2],[2,2,1],[1,1,2],[2,0,1],[1,0,2],[2,1,1]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class TicTacToe {\npublic:\n    TicTacToe(int n) {\n        \n    }\n    \n    int move(int row, int col, int player) {\n        \n    }\n};\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * TicTacToe* obj = new TicTacToe(n);\n * int param_1 = obj->move(row,col,player);\n */"}, "Java": {"langSlug": "java", "code": "class TicTacToe {\n\n    public TicTacToe(int n) {\n        \n    }\n    \n    public int move(int row, int col, int player) {\n        \n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * TicTacToe obj = new TicTacToe(n);\n * int param_1 = obj.move(row,col,player);\n */"}, "Python": {"langSlug": "python", "code": "class TicTacToe(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        \n\n    def move(self, row, col, player):\n        \"\"\"\n        :type row: int\n        :type col: int\n        :type player: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your TicTacToe object will be instantiated and called as such:\n# obj = TicTacToe(n)\n# param_1 = obj.move(row,col,player)"}, "Python3": {"langSlug": "python3", "code": "class TicTacToe:\n\n    def __init__(self, n: int):\n        \n\n    def move(self, row: int, col: int, player: int) -> int:\n        \n\n\n# Your TicTacToe object will be instantiated and called as such:\n# obj = TicTacToe(n)\n# param_1 = obj.move(row,col,player)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} TicTacToe;\n\n\nTicTacToe* ticTacToeCreate(int n) {\n    \n}\n\nint ticTacToeMove(TicTacToe* obj, int row, int col, int player) {\n  \n}\n\nvoid ticTacToeFree(TicTacToe* obj) {\n    \n}\n\n/**\n * Your TicTacToe struct will be instantiated and called as such:\n * TicTacToe* obj = ticTacToeCreate(n);\n * int param_1 = ticTacToeMove(obj, row, col, player);\n \n * ticTacToeFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class TicTacToe {\n\n    public TicTacToe(int n) {\n        \n    }\n    \n    public int Move(int row, int col, int player) {\n        \n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * TicTacToe obj = new TicTacToe(n);\n * int param_1 = obj.Move(row,col,player);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n */\nvar TicTacToe = function(n) {\n    \n};\n\n/** \n * @param {number} row \n * @param {number} col \n * @param {number} player\n * @return {number}\n */\nTicTacToe.prototype.move = function(row, col, player) {\n    \n};\n\n/** \n * Your TicTacToe object will be instantiated and called as such:\n * var obj = new TicTacToe(n)\n * var param_1 = obj.move(row,col,player)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class TicTacToe {\n    constructor(n: number) {\n\n    }\n\n    move(row: number, col: number, player: number): number {\n\n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * var obj = new TicTacToe(n)\n * var param_1 = obj.move(row,col,player)\n */"}, "PHP": {"langSlug": "php", "code": "class TicTacToe {\n    /**\n     * @param Integer $n\n     */\n    function __construct($n) {\n        \n    }\n  \n    /**\n     * @param Integer $row\n     * @param Integer $col\n     * @param Integer $player\n     * @return Integer\n     */\n    function move($row, $col, $player) {\n        \n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * $obj = TicTacToe($n);\n * $ret_1 = $obj->move($row, $col, $player);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass TicTacToe {\n\n    init(_ n: Int) {\n        \n    }\n    \n    func move(_ row: Int, _ col: Int, _ player: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * let obj = TicTacToe(n)\n * let ret_1: Int = obj.move(row, col, player)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class TicTacToe(n: Int) {\n\n    fun move(row: Int, col: Int, player: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * var obj = TicTacToe(n)\n * var param_1 = obj.move(row,col,player)\n */"}, "Go": {"langSlug": "golang", "code": "type TicTacToe struct {\n    \n}\n\n\nfunc Constructor(n int) TicTacToe {\n    \n}\n\n\nfunc (this *TicTacToe) Move(row int, col int, player int) int {\n    \n}\n\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * obj := Constructor(n);\n * param_1 := obj.Move(row,col,player);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class TicTacToe\n\n=begin\n    :type n: Integer\n=end\n    def initialize(n)\n        \n    end\n\n\n=begin\n    :type row: Integer\n    :type col: Integer\n    :type player: Integer\n    :rtype: Integer\n=end\n    def move(row, col, player)\n        \n    end\n\n\nend\n\n# Your TicTacToe object will be instantiated and called as such:\n# obj = TicTacToe.new(n)\n# param_1 = obj.move(row, col, player)"}, "Scala": {"langSlug": "scala", "code": "class TicTacToe(_n: Int) {\n\n    def move(row: Int, col: Int, player: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * var obj = new TicTacToe(n)\n * var param_1 = obj.move(row,col,player)\n */"}, "Rust": {"langSlug": "rust", "code": "struct TicTacToe {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl TicTacToe {\n\n    fn new(n: i32) -> Self {\n        \n    }\n    \n    fn make_a_move(&self, row: i32, col: i32, player: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your TicTacToe object will be instantiated and called as such:\n * let obj = TicTacToe::new(n);\n * let ret_1: i32 = obj.move(row, col, player);\n */"}, "Racket": {"langSlug": "racket", "code": "(define tic-tac-toe%\n  (class object%\n    (super-new)\n\n    ; n : exact-integer?\n    (init-field\n      n)\n    \n    ; move : exact-integer? exact-integer? exact-integer? -> exact-integer?\n    (define/public (move row col player)\n\n      )))\n\n;; Your tic-tac-toe% object will be instantiated and called as such:\n;; (define obj (new tic-tac-toe% [n n]))\n;; (define param_1 (send obj move row col player))"}, "Erlang": {"langSlug": "erlang", "code": "-spec tic_tac_toe_init_(N :: integer()) -> any().\ntic_tac_toe_init_(N) ->\n  .\n\n-spec tic_tac_toe_move(Row :: integer(), Col :: integer(), Player :: integer()) -> integer().\ntic_tac_toe_move(Row, Col, Player) ->\n  .\n\n\n%% Your functions will be called as such:\n%% tic_tac_toe_init_(N),\n%% Param_1 = tic_tac_toe_move(Row, Col, Player),\n\n%% tic_tac_toe_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule TicTacToe do\n  @spec init_(n :: integer) :: any\n  def init_(n) do\n\n  end\n\n  @spec move(row :: integer, col :: integer, player :: integer) :: integer\n  def move(row, col, player) do\n\n  end\nend\n\n# Your functions will be called as such:\n# TicTacToe.init_(n)\n# param_1 = TicTacToe.move(row, col, player)\n\n# TicTacToe.init_ will be called before every test case, in which you can do some necessary initializations."}}}