{"questionId": "1085", "acRate": 65.39676779558152, "difficulty": "Medium", "freqBar": 66.25466979227511, "frontendQuestionId": "1101", "paidOnly": true, "status": "ac", "title": "The Earliest Moment When Everyone Become Friends", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Union Find", "id": "VG9waWNUYWdOb2RlOjIz", "slug": "union-find"}, {"name": "Sorting", "id": "VG9waWNUYWdOb2RlOjYxMDQ5", "slug": "sorting"}], "titleSlug": "the-earliest-moment-when-everyone-become-friends", "content": "<p>There are n people in a social group labeled from <code>0</code> to <code>n - 1</code>. You are given an array <code>logs</code> where <code>logs[i] = [timestamp<sub>i</sub>, x<sub>i</sub>, y<sub>i</sub>]</code> indicates that <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> will be friends at the time <code>timestamp<sub>i</sub></code>.</p>\n\n<p>Friendship is <strong>symmetric</strong>. That means if <code>a</code> is friends with <code>b</code>, then <code>b</code> is friends with <code>a</code>. Also, person <code>a</code> is acquainted with a person <code>b</code> if <code>a</code> is friends with <code>b</code>, or <code>a</code> is a friend of someone acquainted with <code>b</code>.</p>\n\n<p>Return <em>the earliest time for which every person became acquainted with every other person</em>. If there is no such earliest time, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], n = 6\n<strong>Output:</strong> 20190301\n<strong>Explanation:</strong> \nThe first event occurs at timestamp = 20190101, and after 0 and 1 become friends, we have the following friendship groups [0,1], [2], [3], [4], [5].\nThe second event occurs at timestamp = 20190104, and after 3 and 4 become friends, we have the following friendship groups [0,1], [2], [3,4], [5].\nThe third event occurs at timestamp = 20190107, and after 2 and 3 become friends, we have the following friendship groups [0,1], [2,3,4], [5].\nThe fourth event occurs at timestamp = 20190211, and after 1 and 5 become friends, we have the following friendship groups [0,1,5], [2,3,4].\nThe fifth event occurs at timestamp = 20190224, and as 2 and 4 are already friends, nothing happens.\nThe sixth event occurs at timestamp = 20190301, and after 0 and 3 become friends, we all become friends.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> At timestamp = 3, all the persons (i.e., 0, 1, 2, and 3) become friends.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>logs[i].length == 3</code></li>\n\t<li><code>0 &lt;= timestamp<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li>All the values <code>timestamp<sub>i</sub></code> are <strong>unique</strong>.</li>\n\t<li>All the pairs <code>(x<sub>i</sub>, y<sub>i</sub>)</code> occur at most one time in the input.</li>\n</ul>\n", "hints": ["Sort the log items by their timestamp.", "How can we model this problem as a graph problem?", "Let's use a union-find data structure. At the beginning we have a graph with N nodes but no edges.", "Then we loop through the events and unite each node until the number of connected components reach to 1. Notice that each time two different connected components are united the number of connected components decreases by 1."], "exampleTestcases": "[[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]]\n6\n[[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]]\n4", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    int earliestAcq(vector<vector<int>>& logs, int n) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public int earliestAcq(int[][] logs, int n) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def earliestAcq(self, logs, n):\n        \"\"\"\n        :type logs: List[List[int]]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def earliestAcq(self, logs: List[List[int]], n: int) -> int:\n        "}, {"lang": "C", "langSlug": "c", "code": "int earliestAcq(int** logs, int logsSize, int* logsColSize, int n) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public int EarliestAcq(int[][] logs, int n) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number[][]} logs\n * @param {number} n\n * @return {number}\n */\nvar earliestAcq = function(logs, n) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function earliestAcq(logs: number[][], n: number): number {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $logs\n     * @param Integer $n\n     * @return Integer\n     */\n    function earliestAcq($logs, $n) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func earliestAcq(_ logs: [[Int]], _ n: Int) -> Int {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun earliestAcq(logs: Array<IntArray>, n: Int): Int {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  int earliestAcq(List<List<int>> logs, int n) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func earliestAcq(logs [][]int, n int) int {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer[][]} logs\n# @param {Integer} n\n# @return {Integer}\ndef earliest_acq(logs, n)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def earliestAcq(logs: Array[Array[Int]], n: Int): Int = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn earliest_acq(logs: Vec<Vec<i32>>, n: i32) -> i32 {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (earliest-acq logs n)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec earliest_acq(Logs :: [[integer()]], N :: integer()) -> integer().\nearliest_acq(Logs, N) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec earliest_acq(logs :: [[integer]], n :: integer) :: integer\n  def earliest_acq(logs, n) do\n    \n  end\nend"}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "number-of-provinces", "title": "Number of Provinces", "isPaidOnly": false}]}