{"question_id": "604", "problem_slug": "design-compressed-string-iterator", "problem_title": "Design Compressed String Iterator", "content": "Design and implement a data structure for a compressed string iterator. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.\nImplement the StringIterator class:\n\nnext() Returns the next character if the original string still has uncompressed characters, otherwise returns a white space.\nhasNext() Returns true if there is any letter needs to be uncompressed in the original string, otherwise returns false.\n\n \nExample 1:\n\nInput\n[\"StringIterator\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[\"L1e2t1C1o1d1e1\"], [], [], [], [], [], [], [], [], []]\nOutput\n[null, \"L\", \"e\", \"e\", \"t\", \"C\", \"o\", true, \"d\", true]\n\nExplanation\nStringIterator stringIterator = new StringIterator(\"L1e2t1C1o1d1e1\");\nstringIterator.next(); // return \"L\"\nstringIterator.next(); // return \"e\"\nstringIterator.next(); // return \"e\"\nstringIterator.next(); // return \"t\"\nstringIterator.next(); // return \"C\"\nstringIterator.next(); // return \"o\"\nstringIterator.hasNext(); // return True\nstringIterator.next(); // return \"d\"\nstringIterator.hasNext(); // return True\n\n \nConstraints:\n\n1 <= compressedString.length <= 1000\ncompressedString consists of lower-case an upper-case English letters and digits.\nThe number of a single character repetitions in compressedString is in the range [1, 10^9]\nAt most 100 calls will be made to next and hasNext.\n\n", "hints": [], "exampleTestcases": "[\"StringIterator\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"hasNext\",\"next\",\"hasNext\"]\n[[\"L1e2t1C1o1d1e1\"],[],[],[],[],[],[],[],[],[]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class StringIterator {\npublic:\n    StringIterator(string compressedString) {\n        \n    }\n    \n    char next() {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator* obj = new StringIterator(compressedString);\n * char param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */"}, "Java": {"langSlug": "java", "code": "class StringIterator {\n\n    public StringIterator(String compressedString) {\n        \n    }\n    \n    public char next() {\n        \n    }\n    \n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = new StringIterator(compressedString);\n * char param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"}, "Python": {"langSlug": "python", "code": "class StringIterator(object):\n\n    def __init__(self, compressedString):\n        \"\"\"\n        :type compressedString: str\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your StringIterator object will be instantiated and called as such:\n# obj = StringIterator(compressedString)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"}, "Python3": {"langSlug": "python3", "code": "class StringIterator:\n\n    def __init__(self, compressedString: str):\n        \n\n    def next(self) -> str:\n        \n\n    def hasNext(self) -> bool:\n        \n\n\n# Your StringIterator object will be instantiated and called as such:\n# obj = StringIterator(compressedString)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} StringIterator;\n\n\nStringIterator* stringIteratorCreate(char* compressedString) {\n    \n}\n\nchar stringIteratorNext(StringIterator* obj) {\n    \n}\n\nbool stringIteratorHasNext(StringIterator* obj) {\n    \n}\n\nvoid stringIteratorFree(StringIterator* obj) {\n    \n}\n\n/**\n * Your StringIterator struct will be instantiated and called as such:\n * StringIterator* obj = stringIteratorCreate(compressedString);\n * char param_1 = stringIteratorNext(obj);\n \n * bool param_2 = stringIteratorHasNext(obj);\n \n * stringIteratorFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class StringIterator {\n\n    public StringIterator(string compressedString) {\n        \n    }\n    \n    public char Next() {\n        \n    }\n    \n    public bool HasNext() {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = new StringIterator(compressedString);\n * char param_1 = obj.Next();\n * bool param_2 = obj.HasNext();\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} compressedString\n */\nvar StringIterator = function(compressedString) {\n    \n};\n\n/**\n * @return {character}\n */\nStringIterator.prototype.next = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nStringIterator.prototype.hasNext = function() {\n    \n};\n\n/** \n * Your StringIterator object will be instantiated and called as such:\n * var obj = new StringIterator(compressedString)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class StringIterator {\n    constructor(compressedString: string) {\n        \n    }\n\n    next(): string {\n        \n    }\n\n    hasNext(): boolean {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * var obj = new StringIterator(compressedString)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, "PHP": {"langSlug": "php", "code": "class StringIterator {\n    /**\n     * @param String $compressedString\n     */\n    function __construct($compressedString) {\n        \n    }\n  \n    /**\n     * @return String\n     */\n    function next() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * $obj = StringIterator($compressedString);\n * $ret_1 = $obj->next();\n * $ret_2 = $obj->hasNext();\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass StringIterator {\n\n    init(_ compressedString: String) {\n        \n    }\n    \n    func next() -> Character {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * let obj = StringIterator(compressedString)\n * let ret_1: Character = obj.next()\n * let ret_2: Bool = obj.hasNext()\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class StringIterator(compressedString: String) {\n\n    fun next(): Char {\n        \n    }\n\n    fun hasNext(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * var obj = StringIterator(compressedString)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, "Dart": {"langSlug": "dart", "code": "class StringIterator {\n\n  StringIterator(String compressedString) {\n    \n  }\n  \n  String next() {\n    \n  }\n  \n  bool hasNext() {\n    \n  }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = StringIterator(compressedString);\n * String param1 = obj.next();\n * bool param2 = obj.hasNext();\n */"}, "Go": {"langSlug": "golang", "code": "type StringIterator struct {\n    \n}\n\n\nfunc Constructor(compressedString string) StringIterator {\n    \n}\n\n\nfunc (this *StringIterator) Next() byte {\n    \n}\n\n\nfunc (this *StringIterator) HasNext() bool {\n    \n}\n\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * obj := Constructor(compressedString);\n * param_1 := obj.Next();\n * param_2 := obj.HasNext();\n */"}, "Ruby": {"langSlug": "ruby", "code": "class StringIterator\n\n=begin\n    :type compressed_string: String\n=end\n    def initialize(compressed_string)\n        \n    end\n\n\n=begin\n    :rtype: Character\n=end\n    def next()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_next()\n        \n    end\n\n\nend\n\n# Your StringIterator object will be instantiated and called as such:\n# obj = StringIterator.new(compressed_string)\n# param_1 = obj.next()\n# param_2 = obj.has_next()"}, "Scala": {"langSlug": "scala", "code": "class StringIterator(_compressedString: String) {\n\n    def next(): Char = {\n        \n    }\n\n    def hasNext(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * val obj = new StringIterator(compressedString)\n * val param_1 = obj.next()\n * val param_2 = obj.hasNext()\n */"}, "Rust": {"langSlug": "rust", "code": "struct StringIterator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StringIterator {\n\n    fn new(compressedString: String) -> Self {\n        \n    }\n    \n    fn next(&self) -> char {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * let obj = StringIterator::new(compressedString);\n * let ret_1: char = obj.next();\n * let ret_2: bool = obj.has_next();\n */"}, "Racket": {"langSlug": "racket", "code": "(define string-iterator%\n  (class object%\n    (super-new)\n    \n    ; compressed-string : string?\n    (init-field\n      compressed-string)\n    \n    ; next : -> char?\n    (define/public (next)\n      )\n    ; has-next : -> boolean?\n    (define/public (has-next)\n      )))\n\n;; Your string-iterator% object will be instantiated and called as such:\n;; (define obj (new string-iterator% [compressed-string compressed-string]))\n;; (define param_1 (send obj next))\n;; (define param_2 (send obj has-next))"}, "Erlang": {"langSlug": "erlang", "code": "-spec string_iterator_init_(CompressedString :: unicode:unicode_binary()) -> any().\nstring_iterator_init_(CompressedString) ->\n  .\n\n-spec string_iterator_next() -> char().\nstring_iterator_next() ->\n  .\n\n-spec string_iterator_has_next() -> boolean().\nstring_iterator_has_next() ->\n  .\n\n\n%% Your functions will be called as such:\n%% string_iterator_init_(CompressedString),\n%% Param_1 = string_iterator_next(),\n%% Param_2 = string_iterator_has_next(),\n\n%% string_iterator_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule StringIterator do\n  @spec init_(compressed_string :: String.t) :: any\n  def init_(compressed_string) do\n    \n  end\n\n  @spec next() :: char\n  def next() do\n    \n  end\n\n  @spec has_next() :: boolean\n  def has_next() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StringIterator.init_(compressed_string)\n# param_1 = StringIterator.next()\n# param_2 = StringIterator.has_next()\n\n# StringIterator.init_ will be called before every test case, in which you can do some necessary initializations."}}}