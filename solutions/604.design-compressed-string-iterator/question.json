{"questionId": "604", "acRate": 39.99700025382468, "difficulty": "Easy", "freqBar": 0.0, "frontendQuestionId": "604", "paidOnly": true, "status": "ac", "title": "Design Compressed String Iterator", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "String", "id": "VG9waWNUYWdOb2RlOjEw", "slug": "string"}, {"name": "Design", "id": "VG9waWNUYWdOb2RlOjI1", "slug": "design"}, {"name": "Iterator", "id": "VG9waWNUYWdOb2RlOjYxMDY0", "slug": "iterator"}], "titleSlug": "design-compressed-string-iterator", "content": "<p>Design and implement a data structure for a compressed string iterator. The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.</p>\n\n<p>Implement the&nbsp;StringIterator class:</p>\n\n<ul>\n\t<li><code>next()</code>&nbsp;Returns <strong>the next character</strong> if the original string still has uncompressed characters, otherwise returns a <strong>white space</strong>.</li>\n\t<li><code>hasNext()</code>&nbsp;Returns true if&nbsp;there is any letter needs to be uncompressed in the original string, otherwise returns <code>false</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;StringIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[&quot;L1e2t1C1o1d1e1&quot;], [], [], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, &quot;L&quot;, &quot;e&quot;, &quot;e&quot;, &quot;t&quot;, &quot;C&quot;, &quot;o&quot;, true, &quot;d&quot;, true]\n\n<strong>Explanation</strong>\nStringIterator stringIterator = new StringIterator(&quot;L1e2t1C1o1d1e1&quot;);\nstringIterator.next(); // return &quot;L&quot;\nstringIterator.next(); // return &quot;e&quot;\nstringIterator.next(); // return &quot;e&quot;\nstringIterator.next(); // return &quot;t&quot;\nstringIterator.next(); // return &quot;C&quot;\nstringIterator.next(); // return &quot;o&quot;\nstringIterator.hasNext(); // return True\nstringIterator.next(); // return &quot;d&quot;\nstringIterator.hasNext(); // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;compressedString.length &lt;= 1000</code></li>\n\t<li><code>compressedString</code> consists of lower-case an upper-case English letters and digits.</li>\n\t<li>The number of a single character repetitions in&nbsp;<code>compressedString</code> is in the range <code>[1, 10^9]</code></li>\n\t<li>At most <code>100</code> calls will be made to <code>next</code> and <code>hasNext</code>.</li>\n</ul>\n", "hints": [], "exampleTestcases": "[\"StringIterator\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"hasNext\",\"next\",\"hasNext\"]\n[[\"L1e2t1C1o1d1e1\"],[],[],[],[],[],[],[],[],[]]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class StringIterator {\npublic:\n    StringIterator(string compressedString) {\n        \n    }\n    \n    char next() {\n        \n    }\n    \n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator* obj = new StringIterator(compressedString);\n * char param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */"}, {"lang": "Java", "langSlug": "java", "code": "class StringIterator {\n\n    public StringIterator(String compressedString) {\n        \n    }\n    \n    public char next() {\n        \n    }\n    \n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = new StringIterator(compressedString);\n * char param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"}, {"lang": "Python", "langSlug": "python", "code": "class StringIterator(object):\n\n    def __init__(self, compressedString):\n        \"\"\"\n        :type compressedString: str\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your StringIterator object will be instantiated and called as such:\n# obj = StringIterator(compressedString)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"}, {"lang": "Python3", "langSlug": "python3", "code": "class StringIterator:\n\n    def __init__(self, compressedString: str):\n        \n\n    def next(self) -> str:\n        \n\n    def hasNext(self) -> bool:\n        \n\n\n# Your StringIterator object will be instantiated and called as such:\n# obj = StringIterator(compressedString)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"}, {"lang": "C", "langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} StringIterator;\n\n\nStringIterator* stringIteratorCreate(char* compressedString) {\n    \n}\n\nchar stringIteratorNext(StringIterator* obj) {\n    \n}\n\nbool stringIteratorHasNext(StringIterator* obj) {\n    \n}\n\nvoid stringIteratorFree(StringIterator* obj) {\n    \n}\n\n/**\n * Your StringIterator struct will be instantiated and called as such:\n * StringIterator* obj = stringIteratorCreate(compressedString);\n * char param_1 = stringIteratorNext(obj);\n \n * bool param_2 = stringIteratorHasNext(obj);\n \n * stringIteratorFree(obj);\n*/"}, {"lang": "C#", "langSlug": "csharp", "code": "public class StringIterator {\n\n    public StringIterator(string compressedString) {\n        \n    }\n    \n    public char Next() {\n        \n    }\n    \n    public bool HasNext() {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = new StringIterator(compressedString);\n * char param_1 = obj.Next();\n * bool param_2 = obj.HasNext();\n */"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {string} compressedString\n */\nvar StringIterator = function(compressedString) {\n    \n};\n\n/**\n * @return {character}\n */\nStringIterator.prototype.next = function() {\n    \n};\n\n/**\n * @return {boolean}\n */\nStringIterator.prototype.hasNext = function() {\n    \n};\n\n/** \n * Your StringIterator object will be instantiated and called as such:\n * var obj = new StringIterator(compressedString)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "class StringIterator {\n    constructor(compressedString: string) {\n        \n    }\n\n    next(): string {\n        \n    }\n\n    hasNext(): boolean {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * var obj = new StringIterator(compressedString)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, {"lang": "PHP", "langSlug": "php", "code": "class StringIterator {\n    /**\n     * @param String $compressedString\n     */\n    function __construct($compressedString) {\n        \n    }\n  \n    /**\n     * @return String\n     */\n    function next() {\n        \n    }\n  \n    /**\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * $obj = StringIterator($compressedString);\n * $ret_1 = $obj->next();\n * $ret_2 = $obj->hasNext();\n */"}, {"lang": "Swift", "langSlug": "swift", "code": "\nclass StringIterator {\n\n    init(_ compressedString: String) {\n        \n    }\n    \n    func next() -> Character {\n        \n    }\n    \n    func hasNext() -> Bool {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * let obj = StringIterator(compressedString)\n * let ret_1: Character = obj.next()\n * let ret_2: Bool = obj.hasNext()\n */"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class StringIterator(compressedString: String) {\n\n    fun next(): Char {\n        \n    }\n\n    fun hasNext(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * var obj = StringIterator(compressedString)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"}, {"lang": "Dart", "langSlug": "dart", "code": "class StringIterator {\n\n  StringIterator(String compressedString) {\n    \n  }\n  \n  String next() {\n    \n  }\n  \n  bool hasNext() {\n    \n  }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = StringIterator(compressedString);\n * String param1 = obj.next();\n * bool param2 = obj.hasNext();\n */"}, {"lang": "Go", "langSlug": "golang", "code": "type StringIterator struct {\n    \n}\n\n\nfunc Constructor(compressedString string) StringIterator {\n    \n}\n\n\nfunc (this *StringIterator) Next() byte {\n    \n}\n\n\nfunc (this *StringIterator) HasNext() bool {\n    \n}\n\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * obj := Constructor(compressedString);\n * param_1 := obj.Next();\n * param_2 := obj.HasNext();\n */"}, {"lang": "Ruby", "langSlug": "ruby", "code": "class StringIterator\n\n=begin\n    :type compressed_string: String\n=end\n    def initialize(compressed_string)\n        \n    end\n\n\n=begin\n    :rtype: Character\n=end\n    def next()\n        \n    end\n\n\n=begin\n    :rtype: Boolean\n=end\n    def has_next()\n        \n    end\n\n\nend\n\n# Your StringIterator object will be instantiated and called as such:\n# obj = StringIterator.new(compressed_string)\n# param_1 = obj.next()\n# param_2 = obj.has_next()"}, {"lang": "Scala", "langSlug": "scala", "code": "class StringIterator(_compressedString: String) {\n\n    def next(): Char = {\n        \n    }\n\n    def hasNext(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * val obj = new StringIterator(compressedString)\n * val param_1 = obj.next()\n * val param_2 = obj.hasNext()\n */"}, {"lang": "Rust", "langSlug": "rust", "code": "struct StringIterator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl StringIterator {\n\n    fn new(compressedString: String) -> Self {\n        \n    }\n    \n    fn next(&self) -> char {\n        \n    }\n    \n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * let obj = StringIterator::new(compressedString);\n * let ret_1: char = obj.next();\n * let ret_2: bool = obj.has_next();\n */"}, {"lang": "Racket", "langSlug": "racket", "code": "(define string-iterator%\n  (class object%\n    (super-new)\n    \n    ; compressed-string : string?\n    (init-field\n      compressed-string)\n    \n    ; next : -> char?\n    (define/public (next)\n      )\n    ; has-next : -> boolean?\n    (define/public (has-next)\n      )))\n\n;; Your string-iterator% object will be instantiated and called as such:\n;; (define obj (new string-iterator% [compressed-string compressed-string]))\n;; (define param_1 (send obj next))\n;; (define param_2 (send obj has-next))"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec string_iterator_init_(CompressedString :: unicode:unicode_binary()) -> any().\nstring_iterator_init_(CompressedString) ->\n  .\n\n-spec string_iterator_next() -> char().\nstring_iterator_next() ->\n  .\n\n-spec string_iterator_has_next() -> boolean().\nstring_iterator_has_next() ->\n  .\n\n\n%% Your functions will be called as such:\n%% string_iterator_init_(CompressedString),\n%% Param_1 = string_iterator_next(),\n%% Param_2 = string_iterator_has_next(),\n\n%% string_iterator_init_ will be called before every test case, in which you can do some necessary initializations."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule StringIterator do\n  @spec init_(compressed_string :: String.t) :: any\n  def init_(compressed_string) do\n    \n  end\n\n  @spec next() :: char\n  def next() do\n    \n  end\n\n  @spec has_next() :: boolean\n  def has_next() do\n    \n  end\nend\n\n# Your functions will be called as such:\n# StringIterator.init_(compressed_string)\n# param_1 = StringIterator.next()\n# param_2 = StringIterator.has_next()\n\n# StringIterator.init_ will be called before every test case, in which you can do some necessary initializations."}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "lru-cache", "title": "LRU Cache", "isPaidOnly": false}, {"difficulty": "Medium", "titleSlug": "string-compression", "title": "String Compression", "isPaidOnly": false}]}