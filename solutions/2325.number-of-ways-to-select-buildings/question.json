{"question_id": "2325", "problem_slug": "number-of-ways-to-select-buildings", "problem_title": "Number of Ways to Select Buildings", "content": "You are given a 0-indexed binary string s which represents the types of buildings along a street where:\n\ns[i] = '0' denotes that the ith building is an office and\ns[i] = '1' denotes that the ith building is a restaurant.\n\nAs a city official, you would like to select 3 buildings for random inspection. However, to ensure variety, no two consecutive buildings out of the selected buildings can be of the same type.\n\nFor example, given s = \"001101\", we cannot select the 1st, 3rd, and 5th buildings as that would form \"011\" which is not allowed due to having two consecutive buildings of the same type.\n\nReturn the number of valid ways to select 3 buildings.\n \nExample 1:\n\nInput: s = \"001101\"\nOutput: 6\nExplanation: \nThe following sets of indices selected are valid:\n- [0,2,4] from \"001101\" forms \"010\"\n- [0,3,4] from \"001101\" forms \"010\"\n- [1,2,4] from \"001101\" forms \"010\"\n- [1,3,4] from \"001101\" forms \"010\"\n- [2,4,5] from \"001101\" forms \"101\"\n- [3,4,5] from \"001101\" forms \"101\"\nNo other selection is valid. Thus, there are 6 total ways.\n\nExample 2:\n\nInput: s = \"11100\"\nOutput: 0\nExplanation: It can be shown that there are no valid selections.\n\n \nConstraints:\n\n3 <= s.length <= 105\ns[i] is either '0' or '1'.\n\n", "hints": ["There are only 2 valid patterns: ‘101’ and ‘010’. Think about how we can construct these 2 patterns from smaller patterns.", "Count the number of subsequences of the form ‘01’ or ‘10’ first. Let n01[i] be the number of ‘01’ subsequences that exist in the prefix of s up to the ith building. How can you compute n01[i]?", "Let n0[i] and n1[i] be the number of ‘0’s and ‘1’s that exists in the prefix of s up to i respectively. Then n01[i] = n01[i – 1] if s[i] == ‘0’, otherwise n01[i] = n01[i – 1] + n0[i – 1].", "The same logic applies to building the n10 array and subsequently the n101 and n010 arrays for the number of ‘101’ and ‘010‘ subsequences."], "exampleTestcases": "\"001101\"\n\"11100\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    long long numberOfWays(string s) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public long numberOfWays(String s) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def numberOfWays(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def numberOfWays(self, s: str) -> int:\n        "}, "C": {"langSlug": "c", "code": "long long numberOfWays(char* s) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public long NumberOfWays(string s) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar numberOfWays = function(s) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function numberOfWays(s: string): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @return Integer\n     */\n    function numberOfWays($s) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func numberOfWays(_ s: String) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun numberOfWays(s: String): Long {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int numberOfWays(String s) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func numberOfWays(s string) int64 {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} s\n# @return {Integer}\ndef number_of_ways(s)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def numberOfWays(s: String): Long = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn number_of_ways(s: String) -> i64 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (number-of-ways s)\n  (-> string? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec number_of_ways(S :: unicode:unicode_binary()) -> integer().\nnumber_of_ways(S) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec number_of_ways(s :: String.t) :: integer\n  def number_of_ways(s) do\n    \n  end\nend"}}}