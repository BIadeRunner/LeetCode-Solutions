{"question_id": "2008", "problem_slug": "minimum-cost-to-change-the-final-value-of-expression", "problem_title": "Minimum Cost to Change the Final Value of Expression", "content": "You are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'.\n\nFor example, \"()1|1\" and \"(1)&()\" are not valid while \"1\", \"(((1))|(0))\", and \"1|(0&(1))\" are valid expressions.\n\nReturn the minimum cost to change the final value of the expression.\n\nFor example, if expression = \"1|1|(0&0)&1\", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1. We want to apply operations so that the new expression evaluates to 0.\n\nThe cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows:\n\nTurn a '1' into a '0'.\nTurn a '0' into a '1'.\nTurn a '&' into a '|'.\nTurn a '|' into a '&'.\n\nNote: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order.\n \nExample 1:\n\nInput: expression = \"1&(0|1)\"\nOutput: 1\nExplanation: We can turn \"1&(0|1)\" into \"1&(0&1)\" by changing the '|' to a '&' using 1 operation.\nThe new expression evaluates to 0. \n\nExample 2:\n\nInput: expression = \"(0&0)&(0&0&0)\"\nOutput: 3\nExplanation: We can turn \"(0&0)&(0&0&0)\" into \"(0|1)|(0&0&0)\" using 3 operations.\nThe new expression evaluates to 1.\n\nExample 3:\n\nInput: expression = \"(0|(1|0&1))\"\nOutput: 1\nExplanation: We can turn \"(0|(1|0&1))\" into \"(0|(0|0&1))\" using 1 operation.\nThe new expression evaluates to 0.\n \nConstraints:\n\n1 <= expression.length <= 105\nexpression only contains '1','0','&','|','(', and ')'\nAll parentheses are properly matched.\nThere will be no empty parentheses (i.e: \"()\" is not a substring of expression).\n\n", "hints": ["How many possible states are there for a given expression?", "Is there a data structure that we can use to solve the problem optimally?"], "exampleTestcases": "\"1&(0|1)\"\n\"(0&0)&(0&0&0)\"\n\"(0|(1|0&1))\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int minOperationsToFlip(string expression) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int minOperationsToFlip(String expression) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def minOperationsToFlip(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n        "}, "C": {"langSlug": "c", "code": "int minOperationsToFlip(char* expression) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int MinOperationsToFlip(string expression) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} expression\n * @return {number}\n */\nvar minOperationsToFlip = function(expression) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function minOperationsToFlip(expression: string): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $expression\n     * @return Integer\n     */\n    function minOperationsToFlip($expression) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func minOperationsToFlip(_ expression: String) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun minOperationsToFlip(expression: String): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int minOperationsToFlip(String expression) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func minOperationsToFlip(expression string) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} expression\n# @return {Integer}\ndef min_operations_to_flip(expression)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def minOperationsToFlip(expression: String): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn min_operations_to_flip(expression: String) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (min-operations-to-flip expression)\n  (-> string? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec min_operations_to_flip(Expression :: unicode:unicode_binary()) -> integer().\nmin_operations_to_flip(Expression) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec min_operations_to_flip(expression :: String.t) :: integer\n  def min_operations_to_flip(expression) do\n    \n  end\nend"}}}