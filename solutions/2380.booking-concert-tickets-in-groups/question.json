{"question_id": "2380", "problem_slug": "booking-concert-tickets-in-groups", "problem_title": "Booking Concert Tickets in Groups", "content": "A concert hall has n rows numbered from 0 to n - 1, each with m seats, numbered from 0 to m - 1. You need to design a ticketing system that can allocate seats in the following cases:\n\nIf a group of k spectators can sit together in a row.\nIf every member of a group of k spectators can get a seat. They may or may not sit together.\n\nNote that the spectators are very picky. Hence:\n\nThey will book seats only if each member of their group can get a seat with row number less than or equal to maxRow. maxRow can vary from group to group.\nIn case there are multiple rows to choose from, the row with the smallest number is chosen. If there are multiple seats to choose in the same row, the seat with the smallest number is chosen.\n\nImplement the BookMyShow class:\n\nBookMyShow(int n, int m) Initializes the object with n as number of rows and m as number of seats per row.\nint[] gather(int k, int maxRow) Returns an array of length 2 denoting the row and seat number (respectively) of the first seat being allocated to the k members of the group, who must sit together. In other words, it returns the smallest possible r and c such that all [c, c + k - 1] seats are valid and empty in row r, and r <= maxRow. Returns [] in case it is not possible to allocate seats to the group.\nboolean scatter(int k, int maxRow) Returns true if all k members of the group can be allocated seats in rows 0 to maxRow, who may or may not sit together. If the seats can be allocated, it allocates k seats to the group with the smallest row numbers, and the smallest possible seat numbers in each row. Otherwise, returns false.\n\n \nExample 1:\n\nInput\n[\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\nOutput\n[null, [0, 0], [], true, false]\n\nExplanation\nBookMyShow bms = new BookMyShow(2, 5); // There are 2 rows with 5 seats each \nbms.gather(4, 0); // return [0, 0]\n                  // The group books seats [0, 3] of row 0. \nbms.gather(2, 0); // return []\n                  // There is only 1 seat left in row 0,\n                  // so it is not possible to book 2 consecutive seats. \nbms.scatter(5, 1); // return True\n                   // The group books seat 4 of row 0 and seats [0, 3] of row 1. \nbms.scatter(5, 1); // return False\n                   // There is only one seat left in the hall.\n\n \nConstraints:\n\n1 <= n <= 5 * 104\n1 <= m, k <= 109\n0 <= maxRow <= n - 1\nAt most 5 * 104 calls in total will be made to gather and scatter.\n\n", "hints": ["Since seats are allocated by smallest row and then by smallest seat numbers, how can we keep a record of the smallest seat number vacant in each row?", "How can range max query help us to check if contiguous seats can be allocated in a range?", "Similarly, can range sum query help us to check if enough seats are available in a range?", "Which data structure can be used to implement the above?"], "exampleTestcases": "[\"BookMyShow\",\"gather\",\"gather\",\"scatter\",\"scatter\"]\n[[2,5],[4,0],[2,0],[5,1],[5,1]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class BookMyShow {\npublic:\n    BookMyShow(int n, int m) {\n        \n    }\n    \n    vector<int> gather(int k, int maxRow) {\n        \n    }\n    \n    bool scatter(int k, int maxRow) {\n        \n    }\n};\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow* obj = new BookMyShow(n, m);\n * vector<int> param_1 = obj->gather(k,maxRow);\n * bool param_2 = obj->scatter(k,maxRow);\n */"}, "Java": {"langSlug": "java", "code": "class BookMyShow {\n\n    public BookMyShow(int n, int m) {\n        \n    }\n    \n    public int[] gather(int k, int maxRow) {\n        \n    }\n    \n    public boolean scatter(int k, int maxRow) {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = new BookMyShow(n, m);\n * int[] param_1 = obj.gather(k,maxRow);\n * boolean param_2 = obj.scatter(k,maxRow);\n */"}, "Python": {"langSlug": "python", "code": "class BookMyShow(object):\n\n    def __init__(self, n, m):\n        \"\"\"\n        :type n: int\n        :type m: int\n        \"\"\"\n        \n\n    def gather(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: List[int]\n        \"\"\"\n        \n\n    def scatter(self, k, maxRow):\n        \"\"\"\n        :type k: int\n        :type maxRow: int\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)"}, "Python3": {"langSlug": "python3", "code": "class BookMyShow:\n\n    def __init__(self, n: int, m: int):\n        \n\n    def gather(self, k: int, maxRow: int) -> List[int]:\n        \n\n    def scatter(self, k: int, maxRow: int) -> bool:\n        \n\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow(n, m)\n# param_1 = obj.gather(k,maxRow)\n# param_2 = obj.scatter(k,maxRow)"}, "C": {"langSlug": "c", "code": "\n\n\ntypedef struct {\n    \n} BookMyShow;\n\n\nBookMyShow* bookMyShowCreate(int n, int m) {\n    \n}\n\nint* bookMyShowGather(BookMyShow* obj, int k, int maxRow, int* retSize) {\n    \n}\n\nbool bookMyShowScatter(BookMyShow* obj, int k, int maxRow) {\n    \n}\n\nvoid bookMyShowFree(BookMyShow* obj) {\n    \n}\n\n/**\n * Your BookMyShow struct will be instantiated and called as such:\n * BookMyShow* obj = bookMyShowCreate(n, m);\n * int* param_1 = bookMyShowGather(obj, k, maxRow, retSize);\n \n * bool param_2 = bookMyShowScatter(obj, k, maxRow);\n \n * bookMyShowFree(obj);\n*/"}, "C#": {"langSlug": "csharp", "code": "public class BookMyShow {\n\n    public BookMyShow(int n, int m) {\n        \n    }\n    \n    public int[] Gather(int k, int maxRow) {\n        \n    }\n    \n    public bool Scatter(int k, int maxRow) {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = new BookMyShow(n, m);\n * int[] param_1 = obj.Gather(k,maxRow);\n * bool param_2 = obj.Scatter(k,maxRow);\n */"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} n\n * @param {number} m\n */\nvar BookMyShow = function(n, m) {\n    \n};\n\n/** \n * @param {number} k \n * @param {number} maxRow\n * @return {number[]}\n */\nBookMyShow.prototype.gather = function(k, maxRow) {\n    \n};\n\n/** \n * @param {number} k \n * @param {number} maxRow\n * @return {boolean}\n */\nBookMyShow.prototype.scatter = function(k, maxRow) {\n    \n};\n\n/** \n * Your BookMyShow object will be instantiated and called as such:\n * var obj = new BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"}, "TypeScript": {"langSlug": "typescript", "code": "class BookMyShow {\n    constructor(n: number, m: number) {\n        \n    }\n\n    gather(k: number, maxRow: number): number[] {\n        \n    }\n\n    scatter(k: number, maxRow: number): boolean {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = new BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"}, "PHP": {"langSlug": "php", "code": "class BookMyShow {\n    /**\n     * @param Integer $n\n     * @param Integer $m\n     */\n    function __construct($n, $m) {\n        \n    }\n  \n    /**\n     * @param Integer $k\n     * @param Integer $maxRow\n     * @return Integer[]\n     */\n    function gather($k, $maxRow) {\n        \n    }\n  \n    /**\n     * @param Integer $k\n     * @param Integer $maxRow\n     * @return Boolean\n     */\n    function scatter($k, $maxRow) {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * $obj = BookMyShow($n, $m);\n * $ret_1 = $obj->gather($k, $maxRow);\n * $ret_2 = $obj->scatter($k, $maxRow);\n */"}, "Swift": {"langSlug": "swift", "code": "\nclass BookMyShow {\n\n    init(_ n: Int, _ m: Int) {\n        \n    }\n    \n    func gather(_ k: Int, _ maxRow: Int) -> [Int] {\n        \n    }\n    \n    func scatter(_ k: Int, _ maxRow: Int) -> Bool {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * let obj = BookMyShow(n, m)\n * let ret_1: [Int] = obj.gather(k, maxRow)\n * let ret_2: Bool = obj.scatter(k, maxRow)\n */"}, "Kotlin": {"langSlug": "kotlin", "code": "class BookMyShow(n: Int, m: Int) {\n\n    fun gather(k: Int, maxRow: Int): IntArray {\n        \n    }\n\n    fun scatter(k: Int, maxRow: Int): Boolean {\n        \n    }\n\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * var obj = BookMyShow(n, m)\n * var param_1 = obj.gather(k,maxRow)\n * var param_2 = obj.scatter(k,maxRow)\n */"}, "Dart": {"langSlug": "dart", "code": "class BookMyShow {\n\n  BookMyShow(int n, int m) {\n    \n  }\n  \n  List<int> gather(int k, int maxRow) {\n    \n  }\n  \n  bool scatter(int k, int maxRow) {\n    \n  }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * BookMyShow obj = BookMyShow(n, m);\n * List<int> param1 = obj.gather(k,maxRow);\n * bool param2 = obj.scatter(k,maxRow);\n */"}, "Go": {"langSlug": "golang", "code": "type BookMyShow struct {\n    \n}\n\n\nfunc Constructor(n int, m int) BookMyShow {\n    \n}\n\n\nfunc (this *BookMyShow) Gather(k int, maxRow int) []int {\n    \n}\n\n\nfunc (this *BookMyShow) Scatter(k int, maxRow int) bool {\n    \n}\n\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * obj := Constructor(n, m);\n * param_1 := obj.Gather(k,maxRow);\n * param_2 := obj.Scatter(k,maxRow);\n */"}, "Ruby": {"langSlug": "ruby", "code": "class BookMyShow\n\n=begin\n    :type n: Integer\n    :type m: Integer\n=end\n    def initialize(n, m)\n        \n    end\n\n\n=begin\n    :type k: Integer\n    :type max_row: Integer\n    :rtype: Integer[]\n=end\n    def gather(k, max_row)\n        \n    end\n\n\n=begin\n    :type k: Integer\n    :type max_row: Integer\n    :rtype: Boolean\n=end\n    def scatter(k, max_row)\n        \n    end\n\n\nend\n\n# Your BookMyShow object will be instantiated and called as such:\n# obj = BookMyShow.new(n, m)\n# param_1 = obj.gather(k, max_row)\n# param_2 = obj.scatter(k, max_row)"}, "Scala": {"langSlug": "scala", "code": "class BookMyShow(_n: Int, _m: Int) {\n\n    def gather(k: Int, maxRow: Int): Array[Int] = {\n        \n    }\n\n    def scatter(k: Int, maxRow: Int): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * val obj = new BookMyShow(n, m)\n * val param_1 = obj.gather(k,maxRow)\n * val param_2 = obj.scatter(k,maxRow)\n */"}, "Rust": {"langSlug": "rust", "code": "struct BookMyShow {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BookMyShow {\n\n    fn new(n: i32, m: i32) -> Self {\n        \n    }\n    \n    fn gather(&self, k: i32, max_row: i32) -> Vec<i32> {\n        \n    }\n    \n    fn scatter(&self, k: i32, max_row: i32) -> bool {\n        \n    }\n}\n\n/**\n * Your BookMyShow object will be instantiated and called as such:\n * let obj = BookMyShow::new(n, m);\n * let ret_1: Vec<i32> = obj.gather(k, maxRow);\n * let ret_2: bool = obj.scatter(k, maxRow);\n */"}, "Racket": {"langSlug": "racket", "code": "(define book-my-show%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; m : exact-integer?\n    (init-field\n      n\n      m)\n    \n    ; gather : exact-integer? exact-integer? -> (listof exact-integer?)\n    (define/public (gather k max-row)\n      )\n    ; scatter : exact-integer? exact-integer? -> boolean?\n    (define/public (scatter k max-row)\n      )))\n\n;; Your book-my-show% object will be instantiated and called as such:\n;; (define obj (new book-my-show% [n n] [m m]))\n;; (define param_1 (send obj gather k max-row))\n;; (define param_2 (send obj scatter k max-row))"}, "Erlang": {"langSlug": "erlang", "code": "-spec book_my_show_init_(N :: integer(), M :: integer()) -> any().\nbook_my_show_init_(N, M) ->\n  .\n\n-spec book_my_show_gather(K :: integer(), MaxRow :: integer()) -> [integer()].\nbook_my_show_gather(K, MaxRow) ->\n  .\n\n-spec book_my_show_scatter(K :: integer(), MaxRow :: integer()) -> boolean().\nbook_my_show_scatter(K, MaxRow) ->\n  .\n\n\n%% Your functions will be called as such:\n%% book_my_show_init_(N, M),\n%% Param_1 = book_my_show_gather(K, MaxRow),\n%% Param_2 = book_my_show_scatter(K, MaxRow),\n\n%% book_my_show_init_ will be called before every test case, in which you can do some necessary initializations."}, "Elixir": {"langSlug": "elixir", "code": "defmodule BookMyShow do\n  @spec init_(n :: integer, m :: integer) :: any\n  def init_(n, m) do\n    \n  end\n\n  @spec gather(k :: integer, max_row :: integer) :: [integer]\n  def gather(k, max_row) do\n    \n  end\n\n  @spec scatter(k :: integer, max_row :: integer) :: boolean\n  def scatter(k, max_row) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# BookMyShow.init_(n, m)\n# param_1 = BookMyShow.gather(k, max_row)\n# param_2 = BookMyShow.scatter(k, max_row)\n\n# BookMyShow.init_ will be called before every test case, in which you can do some necessary initializations."}}}