{"question_id": "1197", "problem_slug": "parsing-a-boolean-expression", "problem_title": "Parsing A Boolean Expression", "content": "A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes:\n\n't' that evaluates to true.\n'f' that evaluates to false.\n'!(subExpr)' that evaluates to the logical NOT of the inner expression subExpr.\n'&(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n'|(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n\nGiven a string expression that represents a boolean expression, return the evaluation of that expression.\nIt is guaranteed that the given expression is valid and follows the given rules.\n \nExample 1:\n\nInput: expression = \"&(|(f))\"\nOutput: false\nExplanation: \nFirst, evaluate |(f) --> f. The expression is now \"&(f)\".\nThen, evaluate &(f) --> f. The expression is now \"f\".\nFinally, return false.\n\nExample 2:\n\nInput: expression = \"|(f,f,f,t)\"\nOutput: true\nExplanation: The evaluation of (false OR false OR false OR true) is true.\n\nExample 3:\n\nInput: expression = \"!(&(f,t))\"\nOutput: true\nExplanation: \nFirst, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now \"!(f)\".\nThen, evaluate !(f) --> NOT false --> true. We return true.\n\n \nConstraints:\n\n1 <= expression.length <= 2 * 104\nexpression[i] is one following characters: '(', ')', '&', '|', '!', 't', 'f', and ','.\n\n", "hints": ["Write a function \"parse\" which calls helper functions \"parse_or\", \"parse_and\", \"parse_not\"."], "exampleTestcases": "\"&(|(f))\"\n\"|(f,f,f,t)\"\n\"!(&(f,t))\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    bool parseBoolExpr(string expression) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public boolean parseBoolExpr(String expression) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def parseBoolExpr(self, expression):\n        \"\"\"\n        :type expression: str\n        :rtype: bool\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def parseBoolExpr(self, expression: str) -> bool:\n        "}, "C": {"langSlug": "c", "code": "bool parseBoolExpr(char* expression) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public bool ParseBoolExpr(string expression) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} expression\n * @return {boolean}\n */\nvar parseBoolExpr = function(expression) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function parseBoolExpr(expression: string): boolean {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $expression\n     * @return Boolean\n     */\n    function parseBoolExpr($expression) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func parseBoolExpr(_ expression: String) -> Bool {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun parseBoolExpr(expression: String): Boolean {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  bool parseBoolExpr(String expression) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func parseBoolExpr(expression string) bool {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} expression\n# @return {Boolean}\ndef parse_bool_expr(expression)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def parseBoolExpr(expression: String): Boolean = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn parse_bool_expr(expression: String) -> bool {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (parse-bool-expr expression)\n  (-> string? boolean?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec parse_bool_expr(Expression :: unicode:unicode_binary()) -> boolean().\nparse_bool_expr(Expression) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec parse_bool_expr(expression :: String.t) :: boolean\n  def parse_bool_expr(expression) do\n    \n  end\nend"}}}