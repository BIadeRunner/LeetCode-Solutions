{"question_id": "1980", "problem_slug": "faulty-sensor", "problem_title": "Faulty Sensor", "content": "An experiment is being conducted in a lab. To ensure accuracy, there are two sensors collecting data simultaneously. You are given two arrays sensor1 and sensor2, where sensor1[i] and sensor2[i] are the ith data points collected by the two sensors.\nHowever, this type of sensor has a chance of being defective, which causes exactly one data point to be dropped. After the data is dropped, all the data points to the right of the dropped data are shifted one place to the left, and the last data point is replaced with some random value. It is guaranteed that this random value will not be equal to the dropped value.\n\nFor example, if the correct data is [1,2,3,4,5] and 3 is dropped, the sensor could return [1,2,4,5,7] (the last position can be any value, not just 7).\n\nWe know that there is a defect in at most one of the sensors. Return the sensor number (1 or 2) with the defect. If there is no defect in either sensor or if it is impossible to determine the defective sensor, return -1.\n \nExample 1:\n\nInput: sensor1 = [2,3,4,5], sensor2 = [2,1,3,4]\nOutput: 1\nExplanation: Sensor 2 has the correct values.\nThe second data point from sensor 2 is dropped, and the last value of sensor 1 is replaced by a 5.\n\nExample 2:\n\nInput: sensor1 = [2,2,2,2,2], sensor2 = [2,2,2,2,5]\nOutput: -1\nExplanation: It is impossible to determine which sensor has a defect.\nDropping the last value for either sensor could produce the output for the other sensor.\n\nExample 3:\n\nInput: sensor1 = [2,3,2,2,3,2], sensor2 = [2,3,2,3,2,7]\nOutput: 2\nExplanation: Sensor 1 has the correct values.\nThe fourth data point from sensor 1 is dropped, and the last value of sensor 1 is replaced by a 7.\n\n \nConstraints:\n\nsensor1.length == sensor2.length\n1 <= sensor1.length <= 100\n1 <= sensor1[i], sensor2[i] <= 100\n\n", "hints": ["Check for a common prefix of the two arrays.", "After this common prefix, there should be one array similar to the other but shifted by one.", "If both arrays can be shifted, return -1."], "exampleTestcases": "[2,3,4,5]\n[2,1,3,4]\n[2,2,2,2,2]\n[2,2,2,2,5]\n[2,3,2,2,3,2]\n[2,3,2,3,2,7]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int badSensor(vector<int>& sensor1, vector<int>& sensor2) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int badSensor(int[] sensor1, int[] sensor2) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def badSensor(self, sensor1, sensor2):\n        \"\"\"\n        :type sensor1: List[int]\n        :type sensor2: List[int]\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def badSensor(self, sensor1: List[int], sensor2: List[int]) -> int:\n        "}, "C": {"langSlug": "c", "code": "int badSensor(int* sensor1, int sensor1Size, int* sensor2, int sensor2Size) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int BadSensor(int[] sensor1, int[] sensor2) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} sensor1\n * @param {number[]} sensor2\n * @return {number}\n */\nvar badSensor = function(sensor1, sensor2) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function badSensor(sensor1: number[], sensor2: number[]): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $sensor1\n     * @param Integer[] $sensor2\n     * @return Integer\n     */\n    function badSensor($sensor1, $sensor2) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func badSensor(_ sensor1: [Int], _ sensor2: [Int]) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun badSensor(sensor1: IntArray, sensor2: IntArray): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int badSensor(List<int> sensor1, List<int> sensor2) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func badSensor(sensor1 []int, sensor2 []int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} sensor1\n# @param {Integer[]} sensor2\n# @return {Integer}\ndef bad_sensor(sensor1, sensor2)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def badSensor(sensor1: Array[Int], sensor2: Array[Int]): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn bad_sensor(sensor1: Vec<i32>, sensor2: Vec<i32>) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (bad-sensor sensor1 sensor2)\n  (-> (listof exact-integer?) (listof exact-integer?) exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec bad_sensor(Sensor1 :: [integer()], Sensor2 :: [integer()]) -> integer().\nbad_sensor(Sensor1, Sensor2) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec bad_sensor(sensor1 :: [integer], sensor2 :: [integer]) :: integer\n  def bad_sensor(sensor1, sensor2) do\n    \n  end\nend"}}}