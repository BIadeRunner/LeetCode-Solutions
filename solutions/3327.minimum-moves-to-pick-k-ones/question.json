{"question_id": "3327", "problem_slug": "minimum-moves-to-pick-k-ones", "problem_title": "Minimum Moves to Pick K Ones", "content": "You are given a binary array nums of length n, a positive integer k and a non-negative integer maxChanges.\nAlice plays a game, where the goal is for Alice to pick up k ones from nums using the minimum number of moves. When the game starts, Alice picks up any index aliceIndex in the range [0, n - 1] and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice can make any number of moves (including zero) where in each move Alice must perform exactly one of the following actions:\n\nSelect any index j != aliceIndex such that nums[j] == 0 and set nums[j] = 1. This action can be performed at most maxChanges times.\nSelect any two adjacent indices x and y (|x - y| == 1) such that nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move and nums[y] becomes 0.\n\nReturn the minimum number of moves required by Alice to pick exactly k ones.\n \nExample 1:\n\nInput: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\nOutput: 3\nExplanation: Alice can pick up 3 ones in 3 moves, if Alice performs the following actions in each move when standing at aliceIndex == 1:\n\nAt the start of the game Alice picks up the one and nums[1] becomes 0. nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect j == 2 and perform an action of the first type. nums becomes [1,0,1,0,0,1,1,0,0,1]\nSelect x == 2 and y == 1, and perform an action of the second type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].\nSelect x == 0 and y == 1, and perform an action of the second type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].\n\nNote that it may be possible for Alice to pick up 3 ones using some other sequence of 3 moves.\n\nExample 2:\n\nInput: nums = [0,0,0,0], k = 2, maxChanges = 3\nOutput: 4\nExplanation: Alice can pick up 2 ones in 4 moves, if Alice performs the following actions in each move when standing at aliceIndex == 0:\n\nSelect j == 1 and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\nSelect j == 1 again and perform an action of the first type. nums becomes [0,1,0,0].\nSelect x == 1 and y == 0 again, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\n\n\n \nConstraints:\n\n2 <= n <= 105\n0 <= nums[i] <= 1\n1 <= k <= 105\n0 <= maxChanges <= 105\nmaxChanges + sum(nums) >= k\n\n", "hints": ["Ones created using a change require <code>2</code> moves. Hence except for the immediate neighbors of the index where we move all the ones, we should try to use change operations.", "For some subset of ones, it is always better to move the ones to the median position.", "We only need to be concerned with the indices where <code>nums[i] == 1</code>."], "exampleTestcases": "[1,1,0,0,0,1,1,0,0,1]\n3\n1\n[0,0,0,0]\n2\n3", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    long long minimumMoves(vector<int>& nums, int k, int maxChanges) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public long minimumMoves(int[] nums, int k, int maxChanges) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def minimumMoves(self, nums, k, maxChanges):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type maxChanges: int\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n        "}, "C": {"langSlug": "c", "code": "long long minimumMoves(int* nums, int numsSize, int k, int maxChanges) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public long MinimumMoves(int[] nums, int k, int maxChanges) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @param {number} maxChanges\n * @return {number}\n */\nvar minimumMoves = function(nums, k, maxChanges) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function minimumMoves(nums: number[], k: number, maxChanges: number): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @param Integer $maxChanges\n     * @return Integer\n     */\n    function minimumMoves($nums, $k, $maxChanges) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func minimumMoves(_ nums: [Int], _ k: Int, _ maxChanges: Int) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun minimumMoves(nums: IntArray, k: Int, maxChanges: Int): Long {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int minimumMoves(List<int> nums, int k, int maxChanges) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func minimumMoves(nums []int, k int, maxChanges int) int64 {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @param {Integer} max_changes\n# @return {Integer}\ndef minimum_moves(nums, k, max_changes)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def minimumMoves(nums: Array[Int], k: Int, maxChanges: Int): Long = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn minimum_moves(nums: Vec<i32>, k: i32, max_changes: i32) -> i64 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (minimum-moves nums k maxChanges)\n  (-> (listof exact-integer?) exact-integer? exact-integer? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec minimum_moves(Nums :: [integer()], K :: integer(), MaxChanges :: integer()) -> integer().\nminimum_moves(Nums, K, MaxChanges) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec minimum_moves(nums :: [integer], k :: integer, max_changes :: integer) :: integer\n  def minimum_moves(nums, k, max_changes) do\n    \n  end\nend"}}}