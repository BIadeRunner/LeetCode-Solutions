{"question_id": "3495", "problem_slug": "k-th-nearest-obstacle-queries", "problem_title": "K-th Nearest Obstacle Queries", "content": "There is an infinite 2D plane.\nYou are given a positive integer k. You are also given a 2D array queries, which contains the following queries:\n\nqueries[i] = [x, y]: Build an obstacle at coordinate (x, y) in the plane. It is guaranteed that there is no obstacle at this coordinate when this query is made.\n\nAfter each query, you need to find the distance of the kth nearest obstacle from the origin.\nReturn an integer array results where results[i] denotes the kth nearest obstacle after query i, or results[i] == -1 if there are less than k obstacles.\nNote that initially there are no obstacles anywhere.\nThe distance of an obstacle at coordinate (x, y) from the origin is given by |x| + |y|.\n \nExample 1:\n\nInput: queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2\nOutput: [-1,7,5,3]\nExplanation:\n\nInitially, there are 0 obstacles.\nAfter queries[0], there are less than 2 obstacles.\nAfter queries[1], there are obstacles at distances 3 and 7.\nAfter queries[2], there are obstacles at distances 3, 5, and 7.\nAfter queries[3], there are obstacles at distances 3, 3, 5, and 7.\n\n\nExample 2:\n\nInput: queries = [[5,5],[4,4],[3,3]], k = 1\nOutput: [10,8,6]\nExplanation:\n\nAfter queries[0], there is an obstacle at distance 10.\nAfter queries[1], there are obstacles at distances 8 and 10.\nAfter queries[2], there are obstacles at distances 6, 8, and 10.\n\n\n \nConstraints:\n\n1 <= queries.length <= 2 * 105\nAll queries[i] are unique.\n-109 <= queries[i][0], queries[i][1] <= 109\n1 <= k <= 105\n\n", "hints": ["Consider if there are more than <code>k</code> obstacles. Can the <code>k + 1<sup>th</sup></code> obstacle ever be the answer to any query?", "Maintain a max heap of size <code>k</code>, thus heap will contain minimum element at the top in that queue.", "Remove top element and insert new element from input array if current max is larger than this."], "exampleTestcases": "[[1,2],[3,4],[2,3],[-3,0]]\n2\n[[5,5],[4,4],[3,3]]\n1", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> resultsArray(vector<vector<int>>& queries, int k) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[] resultsArray(int[][] queries, int k) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def resultsArray(self, queries, k):\n        \"\"\"\n        :type queries: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* resultsArray(int** queries, int queriesSize, int* queriesColSize, int k, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[] ResultsArray(int[][] queries, int k) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} queries\n * @param {number} k\n * @return {number[]}\n */\nvar resultsArray = function(queries, k) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function resultsArray(queries: number[][], k: number): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $queries\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function resultsArray($queries, $k) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func resultsArray(_ queries: [[Int]], _ k: Int) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun resultsArray(queries: Array<IntArray>, k: Int): IntArray {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> resultsArray(List<List<int>> queries, int k) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func resultsArray(queries [][]int, k int) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[][]} queries\n# @param {Integer} k\n# @return {Integer[]}\ndef results_array(queries, k)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def resultsArray(queries: Array[Array[Int]], k: Int): Array[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn results_array(queries: Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (results-array queries k)\n  (-> (listof (listof exact-integer?)) exact-integer? (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec results_array(Queries :: [[integer()]], K :: integer()) -> [integer()].\nresults_array(Queries, K) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec results_array(queries :: [[integer]], k :: integer) :: [integer]\n  def results_array(queries, k) do\n    \n  end\nend"}}}