{"question_id": "3273", "problem_slug": "most-expensive-item-that-can-not-be-bought", "problem_title": "Most Expensive Item That Can Not Be Bought", "content": "You are given two distinct prime numbers primeOne and primeTwo.\nAlice and Bob are visiting a market. The market has an infinite number of items, for any positive integer x there exists an item whose price is x. Alice wants to buy some items from the market to gift to Bob. She has an infinite number of coins in the denomination primeOne and primeTwo. She wants to know the most expensive item she can not buy to gift to Bob.\nReturn the price of the most expensive item which Alice can not gift to Bob.\n \nExample 1:\n\nInput: primeOne = 2, primeTwo = 5\nOutput: 3\nExplanation: The prices of items which cannot be bought are [1,3]. It can be shown that all items with a price greater than 3 can be bought using a combination of coins of denominations 2 and 5.\n\nExample 2:\n\nInput: primeOne = 5, primeTwo = 7\nOutput: 23\nExplanation: The prices of items which cannot be bought are [1,2,3,4,6,8,9,11,13,16,18,23]. It can be shown that all items with a price greater than 23 can be bought.\n\n \nConstraints:\n\n1 < primeOne, primeTwo < 104\nprimeOne, primeTwo are prime numbers.\nprimeOne * primeTwo < 105\n\n", "hints": ["Write out a few cases. It can be seen that all items greater than <code>primeOne * primeTwo</code> can always be bought.", "If we can buy items with cost <code>i</code>, we can also buy items with price <code>i + primeOne</code> and <code>i + primeTwo</code>.", "Use dynamic programming.", "There is an O(1) solution: Use the Chicken McNugget Theorem."], "exampleTestcases": "2\n5\n5\n7", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int mostExpensiveItem(int primeOne, int primeTwo) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int mostExpensiveItem(int primeOne, int primeTwo) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def mostExpensiveItem(self, primeOne, primeTwo):\n        \"\"\"\n        :type primeOne: int\n        :type primeTwo: int\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n        "}, "C": {"langSlug": "c", "code": "int mostExpensiveItem(int primeOne, int primeTwo) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int MostExpensiveItem(int primeOne, int primeTwo) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number} primeOne\n * @param {number} primeTwo\n * @return {number}\n */\nvar mostExpensiveItem = function(primeOne, primeTwo) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function mostExpensiveItem(primeOne: number, primeTwo: number): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer $primeOne\n     * @param Integer $primeTwo\n     * @return Integer\n     */\n    function mostExpensiveItem($primeOne, $primeTwo) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func mostExpensiveItem(_ primeOne: Int, _ primeTwo: Int) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun mostExpensiveItem(primeOne: Int, primeTwo: Int): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int mostExpensiveItem(int primeOne, int primeTwo) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func mostExpensiveItem(primeOne int, primeTwo int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer} prime_one\n# @param {Integer} prime_two\n# @return {Integer}\ndef most_expensive_item(prime_one, prime_two)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def mostExpensiveItem(primeOne: Int, primeTwo: Int): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn most_expensive_item(prime_one: i32, prime_two: i32) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (most-expensive-item primeOne primeTwo)\n  (-> exact-integer? exact-integer? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec most_expensive_item(PrimeOne :: integer(), PrimeTwo :: integer()) -> integer().\nmost_expensive_item(PrimeOne, PrimeTwo) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec most_expensive_item(prime_one :: integer, prime_two :: integer) :: integer\n  def most_expensive_item(prime_one, prime_two) do\n    \n  end\nend"}}}