{"question_id": "2019", "problem_slug": "product-of-two-run-length-encoded-arrays", "problem_title": "Product of Two Run-Length Encoded Arrays", "content": "Run-length encoding is a compression algorithm that allows for an integer array nums with many segments of consecutive repeated numbers to be represented by a (generally smaller) 2D array encoded. Each encoded[i] = [vali, freqi] describes the ith segment of repeated numbers in nums where vali is the value that is repeated freqi times.\n\nFor example, nums = [1,1,1,2,2,2,2,2] is represented by the run-length encoded array encoded = [[1,3],[2,5]]. Another way to read this is \"three 1's followed by five 2's\".\n\nThe product of two run-length encoded arrays encoded1 and encoded2 can be calculated using the following steps:\n\nExpand both encoded1 and encoded2 into the full arrays nums1 and nums2 respectively.\nCreate a new array prodNums of length nums1.length and set prodNums[i] = nums1[i] * nums2[i].\nCompress prodNums into a run-length encoded array and return it.\n\nYou are given two run-length encoded arrays encoded1 and encoded2 representing full arrays nums1 and nums2 respectively. Both nums1 and nums2 have the same length. Each encoded1[i] = [vali, freqi] describes the ith segment of nums1, and each encoded2[j] = [valj, freqj] describes the jth segment of nums2.\nReturn the product of encoded1 and encoded2.\nNote: Compression should be done such that the run-length encoded array has the minimum possible length.\n \nExample 1:\n\nInput: encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]\nOutput: [[6,6]]\nExplanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3].\nprodNums = [6,6,6,6,6,6], which is compressed into the run-length encoded array [[6,6]].\n\nExample 2:\n\nInput: encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]\nOutput: [[2,3],[6,1],[9,2]]\nExplanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3].\nprodNums = [2,2,2,6,9,9], which is compressed into the run-length encoded array [[2,3],[6,1],[9,2]].\n\n \nConstraints:\n\n1 <= encoded1.length, encoded2.length <= 105\nencoded1[i].length == 2\nencoded2[j].length == 2\n1 <= vali, freqi <= 104 for each encoded1[i].\n1 <= valj, freqj <= 104 for each encoded2[j].\nThe full arrays that encoded1 and encoded2 represent are the same length.\n\n", "hints": ["Keep track of the indices on both RLE arrays and join the parts together.", "What is the maximum number of segments if we took the minimum number of elements left on both the current segments every time?"], "exampleTestcases": "[[1,3],[2,3]]\n[[6,3],[3,3]]\n[[1,3],[2,1],[3,2]]\n[[2,3],[3,3]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<vector<int>> findRLEArray(vector<vector<int>>& encoded1, vector<vector<int>>& encoded2) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public List<List<Integer>> findRLEArray(int[][] encoded1, int[][] encoded2) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def findRLEArray(self, encoded1, encoded2):\n        \"\"\"\n        :type encoded1: List[List[int]]\n        :type encoded2: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def findRLEArray(self, encoded1: List[List[int]], encoded2: List[List[int]]) -> List[List[int]]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findRLEArray(int** encoded1, int encoded1Size, int* encoded1ColSize, int** encoded2, int encoded2Size, int* encoded2ColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public IList<IList<int>> FindRLEArray(int[][] encoded1, int[][] encoded2) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} encoded1\n * @param {number[][]} encoded2\n * @return {number[][]}\n */\nvar findRLEArray = function(encoded1, encoded2) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function findRLEArray(encoded1: number[][], encoded2: number[][]): number[][] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $encoded1\n     * @param Integer[][] $encoded2\n     * @return Integer[][]\n     */\n    function findRLEArray($encoded1, $encoded2) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func findRLEArray(_ encoded1: [[Int]], _ encoded2: [[Int]]) -> [[Int]] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun findRLEArray(encoded1: Array<IntArray>, encoded2: Array<IntArray>): List<List<Int>> {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<List<int>> findRLEArray(List<List<int>> encoded1, List<List<int>> encoded2) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func findRLEArray(encoded1 [][]int, encoded2 [][]int) [][]int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[][]} encoded1\n# @param {Integer[][]} encoded2\n# @return {Integer[][]}\ndef find_rle_array(encoded1, encoded2)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def findRLEArray(encoded1: Array[Array[Int]], encoded2: Array[Array[Int]]): List[List[Int]] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn find_rle_array(encoded1: Vec<Vec<i32>>, encoded2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (find-rle-array encoded1 encoded2)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec find_rle_array(Encoded1 :: [[integer()]], Encoded2 :: [[integer()]]) -> [[integer()]].\nfind_rle_array(Encoded1, Encoded2) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec find_rle_array(encoded1 :: [[integer]], encoded2 :: [[integer]]) :: [[integer]]\n  def find_rle_array(encoded1, encoded2) do\n    \n  end\nend"}}}