{"question_id": "1875", "problem_slug": "tree-of-coprimes", "problem_title": "Tree of Coprimes", "content": "There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. Each node has a value associated with it, and the root of the tree is node 0.\nTo represent this tree, you are given an integer array nums and a 2D array edges. Each nums[i] represents the ith node's value, and each edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree.\nTwo values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y.\nAn ancestor of a node i is any other node on the shortest path from node i to the root. A node is not considered an ancestor of itself.\nReturn an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor.\n \nExample 1:\n\n\nInput: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\nOutput: [-1,0,0,1]\nExplanation: In the above figure, each node's value is in parentheses.\n- Node 0 has no coprime ancestors.\n- Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).\n- Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's\n  value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.\n- Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its\n  closest valid ancestor.\n\nExample 2:\n\n\nInput: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\nOutput: [-1,0,-1,0,0,0,-1]\n\n \nConstraints:\n\nnums.length == n\n1 <= nums[i] <= 50\n1 <= n <= 105\nedges.length == n - 1\nedges[j].length == 2\n0 <= uj, vj < n\nuj != vj\n\n", "hints": ["Note that for a node, it's not optimal to consider two nodes with the same value.", "Note that the values are small enough for you to iterate over them instead of iterating over the parent nodes."], "exampleTestcases": "[2,3,3,2]\n[[0,1],[1,2],[1,3]]\n[5,6,10,2,3,6,15]\n[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int[] getCoprimes(int[] nums, int[][] edges) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def getCoprimes(self, nums, edges):\n        \"\"\"\n        :type nums: List[int]\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n        "}, "C": {"langSlug": "c", "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* getCoprimes(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int[] GetCoprimes(int[] nums, int[][] edges) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[]} nums\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar getCoprimes = function(nums, edges) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function getCoprimes(nums: number[], edges: number[][]): number[] {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function getCoprimes($nums, $edges) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func getCoprimes(_ nums: [Int], _ edges: [[Int]]) -> [Int] {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun getCoprimes(nums: IntArray, edges: Array<IntArray>): IntArray {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  List<int> getCoprimes(List<int> nums, List<List<int>> edges) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func getCoprimes(nums []int, edges [][]int) []int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[]} nums\n# @param {Integer[][]} edges\n# @return {Integer[]}\ndef get_coprimes(nums, edges)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def getCoprimes(nums: Array[Int], edges: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn get_coprimes(nums: Vec<i32>, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (get-coprimes nums edges)\n  (-> (listof exact-integer?) (listof (listof exact-integer?)) (listof exact-integer?))\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec get_coprimes(Nums :: [integer()], Edges :: [[integer()]]) -> [integer()].\nget_coprimes(Nums, Edges) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec get_coprimes(nums :: [integer], edges :: [[integer]]) :: [integer]\n  def get_coprimes(nums, edges) do\n    \n  end\nend"}}}