{"questionId": "2782", "acRate": 92.17687074829932, "difficulty": "Medium", "freqBar": 0.0, "frontendQuestionId": "2776", "paidOnly": true, "status": "ac", "title": "Convert Callback Based Function to Promise Based Function", "topicTags": [], "titleSlug": "convert-callback-based-function-to-promise-based-function", "content": "<p>Write a function that accepts another function <code>fn</code> and converts the callback-based function&nbsp;into a promise-based function.&nbsp;</p>\n\n<p>The function <code>fn</code> takes a callback as its first argument, along with any additional arguments <code>args</code>&nbsp;passed as separate inputs.</p>\n\n<p>The&nbsp;<code>promisify</code>&nbsp;function returns a new function that should return a promise. The promise should resolve with the argument passed as the first parameter of the callback when the callback is invoked without error, and reject with the error when the callback is called with an error as the second argument.</p>\n\n<p>The following is an example of a function that could be passed into&nbsp;<code>promisify</code>.</p>\n\n<pre>\nfunction sum(callback, a, b) {\n  if (a &lt; 0 || b &lt; 0) {\n&nbsp;   const err = Error(&#39;a and b must be positive&#39;);\n    callback(undefined, err);\n&nbsp; } else {\n    callback(a + b);\n&nbsp; }\n}\n</pre>\n\n<p>This is the equivalent code based on promises:</p>\n\n<pre>\nasync function sum(a, b) {\n  if (a &lt; 0 || b &lt; 0) {\n    throw Error(&#39;a and b must be positive&#39;);\n&nbsp; } else {\n    return a + b;\n&nbsp; }\n}\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nfn = (callback, a, b, c) =&gt; {\n    callback(a * b * c);\n}\nargs = [1, 2, 3]\n<strong>Output:</strong> {&quot;resolved&quot;: 6}\n<strong>Explanation:</strong> \nconst asyncFunc = promisify(fn);\nasyncFunc(1, 2, 3).then(console.log); // 6\n\nfn is called with a callback as the first argument and args as the rest. The promise based version of fn resolves a value of 6 when called with (1, 2, 3).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nfn = (callback, a, b, c) =&gt; {\n    callback(a * b * c, &quot;Promise Rejected&quot;);\n}\nargs = [4, 5, 6]\n<strong>Output:</strong> {&quot;rejected&quot;: &quot;Promise Rejected&quot;}\n<strong>Explanation:</strong> \nconst asyncFunc = promisify(fn);\nasyncFunc(4, 5, 6).catch(console.log); // &quot;Promise Rejected&quot;\n\nfn is called with a callback as the first argument and args as the rest. As the second argument, the callback accepts an error message, so when fn is called, the promise is rejected with a error message provided in the callback. Note that it did not matter what was passed as the first argument into the callback.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= args.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= args[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "hints": [], "exampleTestcases": "(callback, a, b, c) => { callback(a * b * c) }\n[1, 2, 3]\n(callback, a, b, c) => { callback(a * b * c, \"Promise Rejected\") }\n[4, 5, 6]", "codeSnippets": [{"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {Function} fn\n * @return {Function<Promise<number>>}\n */\nvar promisify = function(fn) {\n    \n    return async function(...args) {\n        \n    }\n};\n\n/**\n * const asyncFunc = promisify(callback => callback(42));\n * asyncFunc().then(console.log); // 42\n */"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "type CallbackFn = (\n    next: (data: number, error: string) => void, \n    ...args: number[]\n) => void\ntype Promisified = (...args: number[]) => Promise<number>\n\nfunction promisify(fn: CallbackFn): Promisified {\n    \n    return async function(...args) {\n        \n    };\n};\n\n/**\n * const asyncFunc = promisify(callback => callback(42));\n * asyncFunc().then(console.log); // 42\n */"}], "similarQuestionList": []}