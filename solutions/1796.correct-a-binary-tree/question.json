{"questionId": "1796", "acRate": 74.43465491923642, "difficulty": "Medium", "freqBar": 0.0, "frontendQuestionId": "1660", "paidOnly": true, "status": "ac", "title": "Correct a Binary Tree", "topicTags": [{"name": "Hash Table", "id": "VG9waWNUYWdOb2RlOjY=", "slug": "hash-table"}, {"name": "Tree", "id": "VG9waWNUYWdOb2RlOjIw", "slug": "tree"}, {"name": "Depth-First Search", "id": "VG9waWNUYWdOb2RlOjIx", "slug": "depth-first-search"}, {"name": "Breadth-First Search", "id": "VG9waWNUYWdOb2RlOjIy", "slug": "breadth-first-search"}, {"name": "Binary Tree", "id": "VG9waWNUYWdOb2RlOjYxMDU3", "slug": "binary-tree"}], "titleSlug": "correct-a-binary-tree", "content": "<p>You have a binary tree with a small defect. There is <strong>exactly one</strong> invalid node where its right child incorrectly points to another node at the <strong>same depth</strong> but to the <b>invalid node&#39;s right</b>.</p>\r\n\r\n<p>Given the root of the binary tree with this defect, <code>root</code>, return <em>the root of the binary tree after <strong>removing</strong> this invalid node <strong>and every node underneath it</strong> (minus the node it incorrectly points to).</em></p>\r\n\r\n<p><strong>Custom testing:</strong></p>\r\n\r\n<p>The test input is read as 3 lines:</p>\r\n\r\n<ul>\r\n\t<li><code>TreeNode root</code></li>\r\n\t<li><code>int fromNode</code> (<strong>not available to </strong><code>correctBinaryTree</code>)</li>\r\n\t<li><code>int toNode</code> (<strong>not available to </strong><code>correctBinaryTree</code>)</li>\r\n</ul>\r\n\r\n<p>After the binary tree rooted at <code>root</code> is parsed, the <code>TreeNode</code> with value of <code>fromNode</code> will have its right child pointer pointing to the <code>TreeNode</code> with a value of <code>toNode</code>. Then, <code>root</code> is passed to <code>correctBinaryTree</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/22/ex1v2.png\" style=\"width: 250px; height: 177px;\" /></strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [1,2,3], fromNode = 2, toNode = 3\r\n<strong>Output:</strong> [1,null,3]\r\n<strong>Explanation:</strong> The node with value 2 is invalid, so remove it.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/22/ex2v3.png\" style=\"width: 350px; height: 255px;\" /></strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4\r\n<strong>Output:</strong> [8,3,1,null,null,9,4,null,null,5,6]\r\n<strong>Explanation:</strong> The node with value 7 is invalid, so remove it and the node underneath it, node 2.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li>The number of nodes in the tree is in the range <code>[3, 10<sup>4</sup>]</code>.</li>\r\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\r\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\r\n\t<li><code>fromNode != toNode</code></li>\r\n\t<li><code>fromNode</code> and <code>toNode</code> will exist in the tree and will be on the same depth.</li>\r\n\t<li><code>toNode</code> is to the <strong>right</strong> of <code>fromNode</code>.</li>\r\n\t<li><code>fromNode.right</code> is <code>null</code> in the initial tree from the test data.</li>\r\n</ul>", "hints": ["If you traverse the tree from right to left, the invalid node will point to a node that has already been visited."], "exampleTestcases": "[1,2,3]\n2\n3\n[8,3,1,7,null,9,4,2,null,null,null,5,6]\n7\n4", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* correctBinaryTree(TreeNode* root) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode correctBinaryTree(TreeNode root) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def correctBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def correctBinaryTree(self, root: TreeNode) -> TreeNode:\n        "}, {"lang": "C#", "langSlug": "csharp", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public TreeNode CorrectBinaryTree(TreeNode root) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} from\n * @param {number} to\n * @return {TreeNode}\n */\nvar correctBinaryTree = function(root) {\n    \n};"}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "flatten-binary-tree-to-linked-list", "title": "Flatten Binary Tree to Linked List", "isPaidOnly": false}, {"difficulty": "Medium", "titleSlug": "flatten-a-multilevel-doubly-linked-list", "title": "Flatten a Multilevel Doubly Linked List", "isPaidOnly": false}]}