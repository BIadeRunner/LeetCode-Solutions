{"question_id": "1931", "problem_slug": "shortest-path-in-a-hidden-grid", "problem_title": "Shortest Path in a Hidden Grid", "content": "This is an interactive problem.\nThere is a robot in a hidden grid, and you are trying to get it from its starting cell to the target cell in this grid. The grid is of size m x n, and each cell in the grid is either empty or blocked. It is guaranteed that the starting cell and the target cell are different, and neither of them is blocked.\nYou want to find the minimum distance to the target cell. However, you do not know the grid's dimensions, the starting cell, nor the target cell. You are only allowed to ask queries to the GridMaster object.\nThr GridMaster class has the following functions:\n\nboolean canMove(char direction) Returns true if the robot can move in that direction. Otherwise, it returns false.\nvoid move(char direction) Moves the robot in that direction. If this move would move the robot to a blocked cell or off the grid, the move will be ignored, and the robot will remain in the same position.\nboolean isTarget() Returns true if the robot is currently on the target cell. Otherwise, it returns false.\n\nNote that direction in the above functions should be a character from {'U','D','L','R'}, representing the directions up, down, left, and right, respectively.\nReturn the minimum distance between the robot's initial starting cell and the target cell. If there is no valid path between the cells, return -1.\nCustom testing:\nThe test input is read as a 2D matrix grid of size m x n where:\n\ngrid[i][j] == -1 indicates that the robot is in cell (i, j) (the starting cell).\ngrid[i][j] == 0 indicates that the cell (i, j) is blocked.\ngrid[i][j] == 1 indicates that the cell (i, j) is empty.\ngrid[i][j] == 2 indicates that the cell (i, j) is the target cell.\n\nThere is exactly one -1 and 2 in grid. Remember that you will not have this information in your code.\n \nExample 1:\n\nInput: grid = [[1,2],[-1,0]]\nOutput: 2\nExplanation: One possible interaction is described below:\nThe robot is initially standing on cell (1, 0), denoted by the -1.\n- master.canMove('U') returns true.\n- master.canMove('D') returns false.\n- master.canMove('L') returns false.\n- master.canMove('R') returns false.\n- master.move('U') moves the robot to the cell (0, 0).\n- master.isTarget() returns false.\n- master.canMove('U') returns false.\n- master.canMove('D') returns true.\n- master.canMove('L') returns false.\n- master.canMove('R') returns true.\n- master.move('R') moves the robot to the cell (0, 1).\n- master.isTarget() returns true. \nWe now know that the target is the cell (0, 1), and the shortest path to the target cell is 2.\n\nExample 2:\n\nInput: grid = [[0,0,-1],[1,1,1],[2,0,0]]\nOutput: 4\nExplanation: The minimum distance between the robot and the target cell is 4.\nExample 3:\n\nInput: grid = [[-1,0],[0,2]]\nOutput: -1\nExplanation: There is no path from the robot to the target cell.\n \nConstraints:\n\n1 <= n, m <= 500\nm == grid.length\nn == grid[i].length\ngrid[i][j] is either -1, 0, 1, or 2.\nThere is exactly one -1 in grid.\nThere is exactly one 2 in grid.\n\n", "hints": ["The grid is at a maximum 500 x 500, so it is clever to assume that the robot's initial cell is grid[501][501]", "Run a DFS from the robot's position to make sure that you can reach the target, otherwise you should return -1.", "Now that you are sure you can reach the target, run BFS to find the shortest path."], "exampleTestcases": "[[1,2],[-1,0]]\n[[0,0,-1],[1,1,1],[2,0,0]]\n[[-1,0],[0,2]]", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *   public:\n *     bool canMove(char direction);\n *     void move(char direction);\n *     boolean isTarget();\n * };\n */\n\nclass Solution {\npublic:\n    int findShortestPath(GridMaster &master) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *     boolean canMove(char direction);\n *     void move(char direction);\n *     boolean isTarget();\n * }\n */\n\nclass Solution {\n    public int findShortestPath(GridMaster master) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "# \"\"\"\n# This is GridMaster's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class GridMaster(object):\n#    def canMove(self, direction):\n#        \"\"\"\n#        :type direction: str\n#        :rtype bool\n#        \"\"\"\n#\n#    def move(self, direction):\n#        \"\"\"\n#        :type direction: str\n#        \"\"\"\n#\n#    def isTarget(self):\n#        \"\"\"\n#        :rtype bool\n#        \"\"\"\n#\n\nclass Solution(object):\n    def findShortestPath(self, master):\n        \"\"\"\n        :type master: GridMaster\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "# \"\"\"\n# This is GridMaster's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class GridMaster(object):\n#    def canMove(self, direction: str) -> bool:\n#        \n#\n#    def move(self, direction: str) -> bool:\n#        \n#\n#    def isTarget(self) -> None:\n#        \n#\n\nclass Solution(object):\n    def findShortestPath(self, master: 'GridMaster') -> int:\n        \n"}, "C#": {"langSlug": "csharp", "code": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *     bool canMove(char direction);\n *     void move(char direction);\n *     bool isTarget();\n * };\n */\n\nclass Solution {\n    public int FindShortestPath(GridMaster master) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * function GridMaster() {\n *\n *     @param {character} direction\n *     @return {boolean}\n *     this.canMove = function(direction) {\n *         ...\n *     };\n *     @param {character} direction\n *     @return {void}\n *     this.move = function(direction) {\n *         ...\n *     };\n *     @return {boolean}\n *     this.isTarget = function() {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {GridMaster} master\n * @return {integer}\n */\nvar findShortestPath = function(master) {\n    \n};"}, "Swift": {"langSlug": "swift", "code": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *     public func canMove(direction: Character) -> Bool {}\n *     public func move(direction: Character) {}\n *     public func isTarget() -> Bool {}\n * }\n */\n\nclass Solution {\n    func findShortestPath( _ master: gridMaster) -> Int {\n        \n    }\n}"}}}