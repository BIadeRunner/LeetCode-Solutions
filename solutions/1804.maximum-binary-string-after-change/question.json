{"question_id": "1804", "problem_slug": "maximum-binary-string-after-change", "problem_title": "Maximum Binary String After Change", "content": "You are given a binary string binary consisting of only 0's or 1's. You can apply each of the following operations any number of times:\n\nOperation 1: If the number contains the substring \"00\", you can replace it with \"10\".\n\n\t\nFor example, \"00010\" -> \"10010\"\n\n\nOperation 2: If the number contains the substring \"10\", you can replace it with \"01\".\n\t\nFor example, \"00010\" -> \"00001\"\n\n\n\nReturn the maximum binary string you can obtain after any number of operations. Binary string x is greater than binary string y if x's decimal representation is greater than y's decimal representation.\n \nExample 1:\n\nInput: binary = \"000110\"\nOutput: \"111011\"\nExplanation: A valid transformation sequence can be:\n\"000110\" -> \"000101\" \n\"000101\" -> \"100101\" \n\"100101\" -> \"110101\" \n\"110101\" -> \"110011\" \n\"110011\" -> \"111011\"\n\nExample 2:\n\nInput: binary = \"01\"\nOutput: \"01\"\nExplanation: \"01\" cannot be transformed any further.\n\n \nConstraints:\n\n1 <= binary.length <= 105\nbinary consist of '0' and '1'.\n\n", "hints": ["Note that with the operations, you can always make the string only contain at most 1 zero."], "exampleTestcases": "\"000110\"\n\"01\"", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    string maximumBinaryString(string binary) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public String maximumBinaryString(String binary) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def maximumBinaryString(self, binary):\n        \"\"\"\n        :type binary: str\n        :rtype: str\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def maximumBinaryString(self, binary: str) -> str:\n        "}, "C": {"langSlug": "c", "code": "char* maximumBinaryString(char* binary) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public string MaximumBinaryString(string binary) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {string} binary\n * @return {string}\n */\nvar maximumBinaryString = function(binary) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function maximumBinaryString(binary: string): string {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String $binary\n     * @return String\n     */\n    function maximumBinaryString($binary) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func maximumBinaryString(_ binary: String) -> String {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun maximumBinaryString(binary: String): String {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  String maximumBinaryString(String binary) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func maximumBinaryString(binary string) string {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {String} binary\n# @return {String}\ndef maximum_binary_string(binary)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def maximumBinaryString(binary: String): String = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn maximum_binary_string(binary: String) -> String {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (maximum-binary-string binary)\n  (-> string? string?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec maximum_binary_string(Binary :: unicode:unicode_binary()) -> unicode:unicode_binary().\nmaximum_binary_string(Binary) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec maximum_binary_string(binary :: String.t) :: String.t\n  def maximum_binary_string(binary) do\n    \n  end\nend"}}}