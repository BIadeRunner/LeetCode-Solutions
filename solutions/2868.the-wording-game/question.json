{"questionId": "3173", "acRate": 58.767772511848335, "difficulty": "Hard", "freqBar": 0.0, "frontendQuestionId": "2868", "paidOnly": true, "status": "ac", "title": "The Wording Game", "titleSlug": "the-wording-game", "topicTags": [{"name": "Array", "id": "VG9waWNUYWdOb2RlOjU=", "slug": "array"}, {"name": "Math", "id": "VG9waWNUYWdOb2RlOjg=", "slug": "math"}, {"name": "Two Pointers", "id": "VG9waWNUYWdOb2RlOjk=", "slug": "two-pointers"}, {"name": "String", "id": "VG9waWNUYWdOb2RlOjEw", "slug": "string"}, {"name": "Greedy", "id": "VG9waWNUYWdOb2RlOjE3", "slug": "greedy"}, {"name": "Game Theory", "id": "VG9waWNUYWdOb2RlOjYxMDcz", "slug": "game-theory"}], "content": "<p>Alice and Bob each have a <strong>lexicographically sorted</strong> array of strings named <code>a</code> and <code>b</code> respectively.</p>\n\n<p>They are playing a wording game with the following rules:</p>\n\n<ul>\n\t<li>On each turn, the current player should play a word from their list such that the new word is <strong>closely greater</strong> than the last played word; then it&#39;s the other player&#39;s turn.</li>\n\t<li>If a player can&#39;t play a word on their turn, they lose.</li>\n</ul>\n\n<p>Alice starts the game by playing her <strong>lexicographically </strong><strong>smallest </strong>word.</p>\n\n<p>Given <code>a</code> and <code>b</code>, return <code>true</code> <em>if Alice can win knowing that both players play their best, and</em> <code>false</code> <em>otherwise.</em></p>\n\n<p>A word <code>w</code> is <strong>closely greater</strong> than a word <code>z</code> if the following conditions are met:</p>\n\n<ul>\n\t<li><code>w</code> is <strong>lexicographically greater</strong> than <code>z</code>.</li>\n\t<li>If <code>w<sub>1</sub></code> is the first letter of <code>w</code> and <code>z<sub>1</sub></code> is the first letter of <code>z</code>, <code>w<sub>1</sub></code> should either be <strong>equal</strong> to <code>z<sub>1</sub></code> or be the <strong>letter after</strong> <code>z<sub>1</sub></code> in the alphabet.</li>\n\t<li>For example, the word <code>&quot;care&quot;</code> is closely greater than <code>&quot;book&quot;</code> and <code>&quot;car&quot;</code>, but is not closely greater than <code>&quot;ant&quot;</code> or <code>&quot;cook&quot;</code>.</li>\n</ul>\n\n<p>A string <code>s</code> is <b>lexicographically </b><strong>greater</strong> than a string <code>t</code> if in the first position where <code>s</code> and <code>t</code> differ, string <code>s</code> has a letter that appears later in the alphabet than the corresponding letter in <code>t</code>. If the first <code>min(s.length, t.length)</code> characters do not differ, then the longer string is the lexicographically greater one.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = [&quot;avokado&quot;,&quot;dabar&quot;], b = [&quot;brazil&quot;]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Alice must start the game by playing the word &quot;avokado&quot; since it&#39;s her smallest word, then Bob plays his only word, &quot;brazil&quot;, which he can play because its first letter, &#39;b&#39;, is the letter after Alice&#39;s word&#39;s first letter, &#39;a&#39;.\nAlice can&#39;t play a word since the first letter of the only word left is not equal to &#39;b&#39; or the letter after &#39;b&#39;, &#39;c&#39;.\nSo, Alice loses, and the game ends.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = [&quot;ananas&quot;,&quot;atlas&quot;,&quot;banana&quot;], b = [&quot;albatros&quot;,&quot;cikla&quot;,&quot;nogomet&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Alice must start the game by playing the word &quot;ananas&quot;.\nBob can&#39;t play a word since the only word he has that starts with the letter &#39;a&#39; or &#39;b&#39; is &quot;albatros&quot;, which is smaller than Alice&#39;s word.\nSo Alice wins, and the game ends.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = [&quot;hrvatska&quot;,&quot;zastava&quot;], b = [&quot;bijeli&quot;,&quot;galeb&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Alice must start the game by playing the word &quot;hrvatska&quot;.\nBob can&#39;t play a word since the first letter of both of his words are smaller than the first letter of Alice&#39;s word, &#39;h&#39;.\nSo Alice wins, and the game ends.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a[i]</code> and <code>b[i]</code> consist only of lowercase English letters.</li>\n\t<li><code>a</code> and <code>b</code> are <strong>lexicographically sorted</strong>.</li>\n\t<li>All the words in <code>a</code> and <code>b</code> combined are <strong>distinct</strong>.</li>\n\t<li>The sum of the lengths of all the words in <code>a</code> and <code>b</code> combined does not exceed <code>10<sup>6</sup></code>.</li>\n</ul>\n", "hints": ["If both Alice and Bob for each letter of the alphabet have at least one word beginning with that letter, then the winner is the player who has the lexicographically greatest word.", "What happens if both have words that begin with the first <code>x</code> letters of the alphabet, but only one of them has a word beginning with the <code>x + 1<sup>th</sup></code> letter?", "Suppose Alice has a word beginning with the <code>x + 1<sup>th</sup></code> letter. Note that if Alice has the lexicographically greatest word beginning with one of the first <code>x</code> letters, then she is the winner. But if Bob has such a word, then the game continues.", "Now, we can conclude the winner is determined by the first letter which a player doesnâ€™t have a word beginning with, and the other player has the lexicographically greatest word among all the words beginning with the letters before that letter."], "exampleTestcases": "[\"avokado\",\"dabar\"]\n[\"brazil\"]\n[\"ananas\",\"atlas\",\"banana\"]\n[\"albatros\",\"cikla\",\"nogomet\"]\n[\"hrvatska\",\"zastava\"]\n[\"bijeli\",\"galeb\"]", "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    bool canAliceWin(vector<string>& a, vector<string>& b) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public boolean canAliceWin(String[] a, String[] b) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def canAliceWin(self, a, b):\n        \"\"\"\n        :type a: List[str]\n        :type b: List[str]\n        :rtype: bool\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def canAliceWin(self, a: List[str], b: List[str]) -> bool:\n        "}, {"lang": "C", "langSlug": "c", "code": "bool canAliceWin(char** a, int aSize, char** b, int bSize) {\n    \n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public bool CanAliceWin(string[] a, string[] b) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {string[]} a\n * @param {string[]} b\n * @return {boolean}\n */\nvar canAliceWin = function(a, b) {\n    \n};"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function canAliceWin(a: string[], b: string[]): boolean {\n    \n};"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param String[] $a\n     * @param String[] $b\n     * @return Boolean\n     */\n    function canAliceWin($a, $b) {\n        \n    }\n}"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func canAliceWin(_ a: [String], _ b: [String]) -> Bool {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun canAliceWin(a: Array<String>, b: Array<String>): Boolean {\n        \n    }\n}"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  bool canAliceWin(List<String> a, List<String> b) {\n    \n  }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func canAliceWin(a []string, b []string) bool {\n    \n}"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {String[]} a\n# @param {String[]} b\n# @return {Boolean}\ndef can_alice_win(a, b)\n    \nend"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def canAliceWin(a: Array[String], b: Array[String]): Boolean = {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn can_alice_win(a: Vec<String>, b: Vec<String>) -> bool {\n        \n    }\n}"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (can-alice-win a b)\n  (-> (listof string?) (listof string?) boolean?)\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec can_alice_win(A :: [unicode:unicode_binary()], B :: [unicode:unicode_binary()]) -> boolean().\ncan_alice_win(A, B) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec can_alice_win(a :: [String.t], b :: [String.t]) :: boolean\n  def can_alice_win(a, b) do\n    \n  end\nend"}], "similarQuestionList": []}