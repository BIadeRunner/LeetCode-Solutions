{"question_id": "1085", "problem_slug": "the-earliest-moment-when-everyone-become-friends", "problem_title": "The Earliest Moment When Everyone Become Friends", "content": "There are n people in a social group labeled from 0 to n - 1. You are given an array logs where logs[i] = [timestampi, xi, yi] indicates that xi and yi will be friends at the time timestampi.\nFriendship is symmetric. That means if a is friends with b, then b is friends with a. Also, person a is acquainted with a person b if a is friends with b, or a is a friend of someone acquainted with b.\nReturn the earliest time for which every person became acquainted with every other person. If there is no such earliest time, return -1.\n \nExample 1:\n\nInput: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], n = 6\nOutput: 20190301\nExplanation: \nThe first event occurs at timestamp = 20190101, and after 0 and 1 become friends, we have the following friendship groups [0,1], [2], [3], [4], [5].\nThe second event occurs at timestamp = 20190104, and after 3 and 4 become friends, we have the following friendship groups [0,1], [2], [3,4], [5].\nThe third event occurs at timestamp = 20190107, and after 2 and 3 become friends, we have the following friendship groups [0,1], [2,3,4], [5].\nThe fourth event occurs at timestamp = 20190211, and after 1 and 5 become friends, we have the following friendship groups [0,1,5], [2,3,4].\nThe fifth event occurs at timestamp = 20190224, and as 2 and 4 are already friends, nothing happens.\nThe sixth event occurs at timestamp = 20190301, and after 0 and 3 become friends, we all become friends.\n\nExample 2:\n\nInput: logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4\nOutput: 3\nExplanation: At timestamp = 3, all the persons (i.e., 0, 1, 2, and 3) become friends.\n\n \nConstraints:\n\n2 <= n <= 100\n1 <= logs.length <= 104\nlogs[i].length == 3\n0 <= timestampi <= 109\n0 <= xi, yi <= n - 1\nxi != yi\nAll the values timestampi are unique.\nAll the pairs (xi, yi) occur at most one time in the input.\n\n", "hints": ["Sort the log items by their timestamp.", "How can we model this problem as a graph problem?", "Let's use a union-find data structure. At the beginning we have a graph with N nodes but no edges.", "Then we loop through the events and unite each node until the number of connected components reach to 1. Notice that each time two different connected components are united the number of connected components decreases by 1."], "exampleTestcases": "[[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]]\n6\n[[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]]\n4", "codeSnippets": {"C++": {"langSlug": "cpp", "code": "class Solution {\npublic:\n    int earliestAcq(vector<vector<int>>& logs, int n) {\n        \n    }\n};"}, "Java": {"langSlug": "java", "code": "class Solution {\n    public int earliestAcq(int[][] logs, int n) {\n        \n    }\n}"}, "Python": {"langSlug": "python", "code": "class Solution(object):\n    def earliestAcq(self, logs, n):\n        \"\"\"\n        :type logs: List[List[int]]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        "}, "Python3": {"langSlug": "python3", "code": "class Solution:\n    def earliestAcq(self, logs: List[List[int]], n: int) -> int:\n        "}, "C": {"langSlug": "c", "code": "int earliestAcq(int** logs, int logsSize, int* logsColSize, int n) {\n    \n}"}, "C#": {"langSlug": "csharp", "code": "public class Solution {\n    public int EarliestAcq(int[][] logs, int n) {\n        \n    }\n}"}, "JavaScript": {"langSlug": "javascript", "code": "/**\n * @param {number[][]} logs\n * @param {number} n\n * @return {number}\n */\nvar earliestAcq = function(logs, n) {\n    \n};"}, "TypeScript": {"langSlug": "typescript", "code": "function earliestAcq(logs: number[][], n: number): number {\n    \n};"}, "PHP": {"langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $logs\n     * @param Integer $n\n     * @return Integer\n     */\n    function earliestAcq($logs, $n) {\n        \n    }\n}"}, "Swift": {"langSlug": "swift", "code": "class Solution {\n    func earliestAcq(_ logs: [[Int]], _ n: Int) -> Int {\n        \n    }\n}"}, "Kotlin": {"langSlug": "kotlin", "code": "class Solution {\n    fun earliestAcq(logs: Array<IntArray>, n: Int): Int {\n        \n    }\n}"}, "Dart": {"langSlug": "dart", "code": "class Solution {\n  int earliestAcq(List<List<int>> logs, int n) {\n    \n  }\n}"}, "Go": {"langSlug": "golang", "code": "func earliestAcq(logs [][]int, n int) int {\n    \n}"}, "Ruby": {"langSlug": "ruby", "code": "# @param {Integer[][]} logs\n# @param {Integer} n\n# @return {Integer}\ndef earliest_acq(logs, n)\n    \nend"}, "Scala": {"langSlug": "scala", "code": "object Solution {\n    def earliestAcq(logs: Array[Array[Int]], n: Int): Int = {\n        \n    }\n}"}, "Rust": {"langSlug": "rust", "code": "impl Solution {\n    pub fn earliest_acq(logs: Vec<Vec<i32>>, n: i32) -> i32 {\n        \n    }\n}"}, "Racket": {"langSlug": "racket", "code": "(define/contract (earliest-acq logs n)\n  (-> (listof (listof exact-integer?)) exact-integer? exact-integer?)\n  )"}, "Erlang": {"langSlug": "erlang", "code": "-spec earliest_acq(Logs :: [[integer()]], N :: integer()) -> integer().\nearliest_acq(Logs, N) ->\n  ."}, "Elixir": {"langSlug": "elixir", "code": "defmodule Solution do\n  @spec earliest_acq(logs :: [[integer]], n :: integer) :: integer\n  def earliest_acq(logs, n) do\n    \n  end\nend"}}}